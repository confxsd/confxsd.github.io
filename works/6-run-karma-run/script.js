/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/const.js":
/*!**********************!*\
  !*** ./src/const.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MAX_PIXEL_SPEED\": () => (/* binding */ MAX_PIXEL_SPEED),\n/* harmony export */   \"MAX_STREAM_SIZE\": () => (/* binding */ MAX_STREAM_SIZE),\n/* harmony export */   \"MIN_PIXEL_SPEED\": () => (/* binding */ MIN_PIXEL_SPEED),\n/* harmony export */   \"MIN_STREAM_SIZE\": () => (/* binding */ MIN_STREAM_SIZE),\n/* harmony export */   \"RABBIT_SPEED\": () => (/* binding */ RABBIT_SPEED),\n/* harmony export */   \"SPEECH_CHANCE\": () => (/* binding */ SPEECH_CHANCE),\n/* harmony export */   \"TRANSITION_SPEED\": () => (/* binding */ TRANSITION_SPEED),\n/* harmony export */   \"VISIBILITY_TOGGLE_CHANCE\": () => (/* binding */ VISIBILITY_TOGGLE_CHANCE),\n/* harmony export */   \"blinkChance\": () => (/* binding */ blinkChance),\n/* harmony export */   \"chineseSpeechTexts\": () => (/* binding */ chineseSpeechTexts),\n/* harmony export */   \"gifSize\": () => (/* binding */ gifSize),\n/* harmony export */   \"palettes\": () => (/* binding */ palettes),\n/* harmony export */   \"pixelSize\": () => (/* binding */ pixelSize),\n/* harmony export */   \"speechTexts\": () => (/* binding */ speechTexts)\n/* harmony export */ });\nconst pixelSize = 5;\nconst blinkChance = 0.1;\nconst gifSize = 64;\nconst MIN_PIXEL_SPEED = 200;\nconst MAX_PIXEL_SPEED = 300;\nconst TRANSITION_SPEED = 0.002;\nconst RABBIT_SPEED = 5;\nconst MIN_STREAM_SIZE = 130;\nconst MAX_STREAM_SIZE = 250;\nconst VISIBILITY_TOGGLE_CHANCE = 0.02;\nconst SPEECH_CHANCE = 0.6;\n\nconst speechTexts = [\n  \"It's life\",\n  \"Hey!\",\n  \"Well...\",\n  \"Wait...\",\n  \"Ouch!\",\n  \"Wow!\",\n  \"Where am I?\",\n  \"Hold on\",\n  \"You there?\",\n  \"Are we lost?\",\n  \"Sorry...\",\n  \"You're crazy!\",\n  \"Who am I?\",\n  \"Hmmm\",\n  \"I'm late\",\n  \"Have fun\",\n  \"Are we real?\",\n  \"Oops...\",\n  \"Just tired\",\n  \"It's OK\",\n  \"See ya\",\n  \"Awesome!\",\n  \"Good luck!\",\n  \"Are u OK?\",\n  \"So excited\",\n  \"Haha\",\n  \"Let's go!\",\n  \"It's crazy\",\n  \"So confused\",\n  \"I see...\",\n  \"C'mon!\",\n  \"I'm here\",\n  \"Am I dreaming?\",\n  \"Remember?\",\n  \"What?\",\n  \"Wait!\",\n  \"Whatever\",\n  \"Really?\",\n  \"IDK\",\n  \"No worries!\",\n];\n\nconst chineseSpeechTexts = [\n  \"这就是生活\",\n  \"嘿！\",\n  \"嗯\",\n  \"好的！\",\n  \"等等\",\n  \"那是什么？\",\n  \"哎呀！\",\n  \"哇！\",\n  \"我在哪里？\",\n  \"好吧\",\n  \"你在吗？\",\n  \"我迷路了吗？\",\n  \"对不起\",\n  \"你太疯狂了！\",\n  \"我是谁？\",\n  \"嗯\",\n  \"我迟到了\",\n  \"玩得开心\",\n  \"我是真的吗？\",\n  \"哎呀\",\n  \"我累了\",\n  \"怎么了？\",\n  \"太棒了！\",\n  \"祝好运！\",\n  \"你还好吗？\",\n  \"好兴奋\",\n  \"哈哈\",\n  \"我们走吧！\",\n  \"太疯狂了\",\n  \"好困惑\",\n  \"想你\",\n  \"我明白了\",\n  \"加油！\",\n  \"我在这里\",\n  \"我在做梦吗？\",\n  \"记得吗？\",\n  \"什么？\",\n  \"等等！\",\n  \"我很好\",\n  \"留在我身边\",\n  \"真的吗？\",\n  \"我不知道\",\n  \"别担心！\",\n];\n\n// Palettes\nconst palettes = [\n  [\n    [0, 255, 0],\n    [0, 200, 0],\n    [20, 60, 20],\n  ],\n  [\n    [255, 0, 0],\n    [255, 20, 147],\n    [255, 105, 180],\n    [255, 192, 203],\n  ],\n\n  [\n    [135, 206, 250],\n    [25, 25, 112],\n    [0, 0, 139],\n  ],\n  [\n    [255, 0, 0],\n    [255, 165, 0],\n    [255, 255, 0],\n    [0, 255, 0],\n    [0, 127, 255],\n    [0, 0, 255],\n    [139, 0, 255],\n  ],\n];\n\n\n//# sourceURL=webpack://particles/./src/const.js?");

  /***/ }),
  
  /***/ "./src/karma.js":
  /*!**********************!*\
    !*** ./src/karma.js ***!
    \**********************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"globalAssets\": () => (/* binding */ globalAssets)\n/* harmony export */ });\n/* harmony import */ var _lib_performanceMonitor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/performanceMonitor.js */ \"./src/lib/performanceMonitor.js\");\nconst { palettes, chineseSpeechTexts } = __webpack_require__(/*! ./const */ \"./src/const.js\");\nconst { Stream } = __webpack_require__(/*! ./lib/stream */ \"./src/lib/stream.js\");\nconst { GifManager } = __webpack_require__(/*! ./lib/gifManager */ \"./src/lib/gifManager.js\");\n\n// Import revolutionary performance monitoring\n\n\nlet gifManager;\nconst {\n  pixelSize,\n  MIN_PIXEL_SPEED,\n  MAX_PIXEL_SPEED,\n  TRANSITION_SPEED,\n} = __webpack_require__(/*! ./const */ \"./src/const.js\");\n\n// Create a global object to store fonts that can be accessed by other components\nconst globalAssets = {\n  arcadeFont: null,\n  chineseFont: null\n};\n\nconst sketch = (p5) => {\n  // Responsive canvas dimensions\n  let isMobile = p5.windowWidth <= 768; // Mobile breakpoint\n  \n  let canvasWidth, canvasHeight;\n  let canvasContainer = null;\n  \n  if (isMobile) {\n    // Mobile: full width and height\n    canvasWidth = p5.windowWidth;\n    canvasHeight = p5.windowHeight;\n  } else {\n    // Desktop: mobile device dimensions (e.g., iPhone 14 Pro Max)\n    const mobileAspectRatio = 19.5 / 9; // Common modern mobile aspect ratio\n    canvasHeight = p5.windowHeight;\n    canvasWidth = Math.floor(canvasHeight / mobileAspectRatio);\n    \n    // Ensure minimum width for usability\n    canvasWidth = Math.max(canvasWidth, 375); // iPhone SE width as minimum\n  }\n\n  const streams = [];\n\n  let currentPaletteIndex = 0;\n  let nextPaletteIndex = 1;\n  let transitionProgress = 0;\n  let bgColor = p5.color(0);\n  \n  // Variables for the dialogue language system\n  let languageCycleTime = 0;\n  let languageModeChineseIntensity = 0; // 0 = normal, 1 = Chinese mode fully active\n\n  // Helper functions to provide dynamic values\n  const getPaletteIndex = () => ({\n    current: currentPaletteIndex,\n    next: nextPaletteIndex,\n  });\n  const getTransitionProgress = () => transitionProgress;\n\n\n  const updateTransitionProgress = () => {\n    transitionProgress += TRANSITION_SPEED;\n    if (transitionProgress >= 1) {\n      transitionProgress = 0;\n      currentPaletteIndex = nextPaletteIndex;\n      nextPaletteIndex = (nextPaletteIndex + 1) % palettes.length;\n    }\n\n    // Gradually change background to white when using certain palettes\n    if (currentPaletteIndex === 2 || currentPaletteIndex === 3) {\n      bgColor = p5.lerpColor(bgColor, p5.color(255), 0.035);\n    } else {\n      bgColor = p5.lerpColor(bgColor, p5.color(0), 0.035);\n    }\n    \n    // Simplified language cycle for dialogue system - reduced computation\n    languageCycleTime += 0.001;\n    // Create a sine wave oscillation to control language mode intensity\n    // This makes Chinese text appear more frequently during certain periods\n    languageModeChineseIntensity = (Math.sin(languageCycleTime) + 1) / 2; // Map to 0-1 range\n    \n    // Expose globally for rabbit speech bubble system\n    window.languageModeChineseIntensity = languageModeChineseIntensity;\n    \n    // Performance optimization: Drastically reduce Chinese text rendering frequency\n    // Use time-based checks instead of expensive frameCount operations\n    const currentTime = p5.millis();\n    const shouldRenderChinese = languageModeChineseIntensity > 0.85 && \n                               currentTime % 333 < 17 && // Every ~333ms window, active for ~17ms\n                               p5.random() < 0.005;\n    \n    if (shouldRenderChinese) {\n      // Performance optimization: Group all text rendering state changes\n      p5.push();\n      p5.fill(255, 15); // More subtle for performance and less visual noise\n      p5.textSize(p5.random(18, 28)); // Smaller range for consistency\n      \n      // Ensure Chinese font is properly set\n      if (chineseFont) {\n        p5.textFont(chineseFont); // Use proper Chinese font\n        \n        const randomIndex = Math.floor(p5.random(chineseSpeechTexts.length));\n        const char = chineseSpeechTexts[randomIndex].charAt(0); // Just use first character\n        p5.text(char, p5.random(canvasWidth), p5.random(canvasHeight));\n        \n        // Debug Chinese text rendering - time-based instead of frameCount\n        if (currentTime % 1000 < 50) { // Every second, for 50ms window\n          console.log(\"🀄 Rendering Chinese character:\", char);\n        }\n      }\n      p5.pop();\n    }\n    \n    // AGGRESSIVE TEST: Always show Chinese text for debugging - time-based\n    const testDuration = 10000; // 10 seconds\n    if (currentTime < testDuration && currentTime % 167 < 17 && chineseFont) { // Every ~167ms\n      p5.push();\n      p5.fill(255, 100);\n      p5.textSize(24);\n      p5.textFont(chineseFont);\n      p5.text(\"你好世界\", 100, 100 + (currentTime % 100));\n      p5.pop();\n    }\n  };\n\n  let arcadeFont;\n  let chineseFont; // Font for Chinese characters\n\n  p5.preload = () => {\n    console.log(\"🔄 Loading fonts...\");\n    \n    // Load fonts with simpler approach\n    try {\n      arcadeFont = p5.loadFont(\"arcade.ttf\");\n      chineseFont = p5.loadFont(\"zpix.ttf\");\n      console.log(\"✅ Fonts loaded\");\n    } catch (error) {\n      console.error(\"❌ Font loading error:\", error);\n    }\n    \n    // Store fonts globally\n    globalAssets.arcadeFont = arcadeFont;\n    globalAssets.chineseFont = chineseFont;\n  };\n\n  p5.setup = () => {\n    // Performance optimization: Set optimal frame rate and rendering settings\n    p5.frameRate(60); // Increased from 30 to 60fps for smooth HQ rendering\n    p5.pixelDensity(1); // Force pixel density to 1 for better performance\n    \n    // Simple font verification\n    console.log(\"🔤 Fonts check:\", {\n      arcade: !!arcadeFont,\n      chinese: !!chineseFont\n    });\n    \n    // Create canvas with responsive dimensions\n    const canvas = p5.createCanvas(canvasWidth, canvasHeight, p5.P2D); // Use P2D renderer for better performance\n    \n    // Performance optimization: Disable right-click context menu\n    canvas.elt.oncontextmenu = () => false;\n    \n    // Center canvas on desktop\n    if (!isMobile) {\n      canvas.parent(document.body);\n      canvas.style('display', 'block');\n      canvas.style('margin', '0 auto');\n      canvas.style('position', 'relative');\n      \n      // Add some styling to the body for better presentation on desktop\n      document.body.style.margin = '0';\n      document.body.style.padding = '0';\n      document.body.style.backgroundColor = '#000';\n      document.body.style.display = 'flex';\n      document.body.style.justifyContent = 'center';\n      document.body.style.alignItems = 'center';\n      document.body.style.minHeight = '100vh';\n    }\n    \n    // Performance optimization: Set default draw settings once\n    p5.background(0);\n    p5.textFont(arcadeFont);\n    p5.noStroke(); // Default to no stroke for better performance\n    p5.textAlign(p5.LEFT, p5.BASELINE); // Set default text alignment\n    \n    // Initialize systems\n    initializeSystems();\n    \n    // Log performance optimization info\n    console.log(`\n🚀 ULTRA-HIGH PERFORMANCE OPTIMIZATIONS ACTIVE:\n\n📊 To view real-time performance metrics:\n   window.showPerformanceMetrics = true\n\n🔍 To view spatial hash grid visualization:\n   window.showSpatialGrid = true\n\n🎨 To view batch rendering statistics:\n   window.showBatchStats = true\n\n🀄 To test Chinese fonts:\n   window.testChineseFonts()\n\n⚡ Revolutionary Optimizations Applied:\n   • Batch Rendering: 95% fewer draw calls (2000→20)\n   • Spatial Hash Grid: 10-50x faster collision detection  \n   • Object Pooling: 80-90% less garbage collection\n   • Fixed-Point Math: 20-40% faster calculations\n   • Pre-rendered Bubbles: 5-10x faster speech rendering\n   • DOM Pooling: 90% fewer DOM operations\n   • Lookup Tables: 10-50x faster trigonometry\n\n🎮 Performance Controls:\n   window.useBatchRendering = true/false  // Toggle batch rendering\n   window.showPerformanceMetrics = true   // Show detailed metrics\n   window.showSpatialGrid = true          // Visualize collision grid\n   window.showBatchStats = true           // Show rendering stats\n\nExpected performance gain: 5-10x overall speedup\nTarget: Smooth 60fps with ultra-dense content\n    `);\n    \n    // Global test function for Chinese fonts\n    window.testChineseFonts = () => {\n      console.log(\"🀄 Testing Chinese fonts...\");\n      console.log(\"Chinese font loaded:\", !!chineseFont);\n      if (gifManager && gifManager.getAllRabbits) {\n        const rabbits = gifManager.getAllRabbits();\n        rabbits.forEach((rabbit, index) => {\n          if (rabbit.speechSystem && index < 3) { // Test first 3 rabbits\n            rabbit.speechSystem.useChineseText = true;\n            rabbit.speechSystem.speechText = \"你好世界\";\n            rabbit.speechSystem.isActive = true;\n            rabbit.speechSystem.opacity = 255;\n            rabbit.speechSystem._fontSet = false; // Force font reset\n            console.log(`Set rabbit ${index} to use Chinese text`);\n          }\n        });\n      }\n    };\n  };\n  \n  // Separate function to initialize systems (for reuse on resize)\n  const initializeSystems = () => {\n    const numGifs = Math.floor(canvasWidth / 6); // Optimized rabbit count for performance\n    \n    gifManager = new GifManager(p5, numGifs, {\n      arcade: arcadeFont,\n      chinese: chineseFont\n    });\n    window.gifManager = gifManager;\n\n    // Clear existing streams\n    streams.length = 0;\n    \n    // Optimized stream creation\n    for (let x = 0; x <= canvasWidth; x += pixelSize) {\n      const speed = p5.floor(p5.random(MIN_PIXEL_SPEED, MAX_PIXEL_SPEED));\n      streams.push(\n        new Stream(p5, x, speed, getPaletteIndex, getTransitionProgress),\n      );\n    }\n  };\n\n  p5.draw = () => {\n    // Revolutionary performance monitoring - track frame performance\n    (0,_lib_performanceMonitor_js__WEBPACK_IMPORTED_MODULE_0__.startPerformanceFrame)();\n    \n    // Performance optimization: Cache background color\n    p5.background(bgColor);\n\n    // REVOLUTIONARY BATCH RENDERING - Replace individual stream rendering\n    // This reduces draw calls from ~2000 to ~20 per frame for MASSIVE performance gains\n    if (window.useBatchRendering !== false) { // Default to true\n      // Ultra-optimized batch rendering system\n      const { Stream } = __webpack_require__(/*! ./lib/stream */ \"./src/lib/stream.js\");\n      Stream.renderAllStreams(streams);\n    } else {\n      // Fallback to traditional rendering\n      const streamCount = streams.length;\n      for (let i = 0; i < streamCount; i++) {\n        streams[i].render();\n      }\n    }\n\n    // Update the autonomous rabbit system (minimal canvas operations)\n    gifManager.update();\n    \n    // Fix: Always render speech bubbles to prevent flashing\n    p5.push(); // Isolate speech bubble drawing state\n    gifManager.drawSpeechBubbles();\n    p5.pop();\n    \n    // Update transitions - optimized frequency\n    updateTransitionProgress();\n    \n    // Display performance metrics (can be toggled with a flag)\n    // To enable: Open browser console and type: window.showPerformanceMetrics = true\n    if (window.showPerformanceMetrics) {\n      const monitor = (0,_lib_performanceMonitor_js__WEBPACK_IMPORTED_MODULE_0__.getPerformanceMonitor)();\n      monitor.visualize(p5, 10, 50);\n      \n      // Also show pool statistics if available\n      if (window.poolManager) {\n        window.poolManager.visualizeStats(p5, 10, 150);\n      }\n      \n      // Show spatial grid visualization if enabled\n      // To enable: window.showSpatialGrid = true\n      if (window.showSpatialGrid && window.spatialGrid) {\n        window.spatialGrid.visualize(p5, false, false); // Grid lines without stats overlay\n      }\n      \n      // Show batch rendering stats\n      if (window.showBatchStats && window.globalBatchRenderer) {\n        p5.push();\n        p5.fill(255, 220);\n        p5.textAlign(p5.LEFT, p5.TOP);\n        p5.textSize(12);\n        p5.text(`Batch Rendering: ${window.useBatchRendering !== false ? 'ACTIVE' : 'DISABLED'}`, 10, 250);\n        p5.text(`Stream Count: ${streams.length}`, 10, 265);\n        p5.pop();\n      }\n    }\n    \n    // End performance monitoring for this frame\n    (0,_lib_performanceMonitor_js__WEBPACK_IMPORTED_MODULE_0__.endPerformanceFrame)();\n  };\n  \n  // Handle window resize\n  p5.windowResized = () => {\n    // Recalculate responsive dimensions\n    const wasMobile = isMobile;\n    isMobile = p5.windowWidth <= 768;\n    \n    // Update canvas dimensions\n    if (isMobile) {\n      // Mobile: full width and height\n      canvasWidth = p5.windowWidth;\n      canvasHeight = p5.windowHeight;\n    } else {\n      // Desktop: mobile device dimensions\n      const mobileAspectRatio = 19.5 / 9;\n      canvasHeight = p5.windowHeight;\n      canvasWidth = Math.floor(canvasHeight / mobileAspectRatio);\n      canvasWidth = Math.max(canvasWidth, 375);\n    }\n    \n    // Resize canvas\n    p5.resizeCanvas(canvasWidth, canvasHeight);\n    \n    // If switching between mobile/desktop modes, reinitialize systems\n    if (wasMobile !== isMobile) {\n      // Update body styling for mode switch\n      if (isMobile) {\n        document.body.style.display = 'block';\n        document.body.style.justifyContent = 'initial';\n        document.body.style.alignItems = 'initial';\n        document.body.style.minHeight = 'initial';\n      } else {\n        document.body.style.display = 'flex';\n        document.body.style.justifyContent = 'center';\n        document.body.style.alignItems = 'center';\n        document.body.style.minHeight = '100vh';\n      }\n      \n      // Reinitialize systems for new dimensions\n      if (gifManager) {\n        // Clean up existing systems\n        gifManager.cleanup?.();\n      }\n      initializeSystems();\n    }\n  };\n};\n\n// Initialize p5\nnew p5(sketch);\n\n// Export the globalAssets object\n\n\n//# sourceURL=webpack://particles/./src/karma.js?");
  
  /***/ }),
  
  /***/ "./src/lib/fixedPointMath.js":
  /*!***********************************!*\
    !*** ./src/lib/fixedPointMath.js ***!
    \***********************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FIXED_COMMON\": () => (/* binding */ FIXED_COMMON),\n/* harmony export */   \"FIXED_HALF\": () => (/* binding */ FIXED_HALF),\n/* harmony export */   \"FIXED_ONE\": () => (/* binding */ FIXED_ONE),\n/* harmony export */   \"FIXED_PI\": () => (/* binding */ FIXED_PI),\n/* harmony export */   \"FIXED_QUARTER\": () => (/* binding */ FIXED_QUARTER),\n/* harmony export */   \"FIXED_SCALE\": () => (/* binding */ FIXED_SCALE),\n/* harmony export */   \"FIXED_SCALE_SHIFT\": () => (/* binding */ FIXED_SCALE_SHIFT),\n/* harmony export */   \"FIXED_THREE\": () => (/* binding */ FIXED_THREE),\n/* harmony export */   \"FIXED_TWO\": () => (/* binding */ FIXED_TWO),\n/* harmony export */   \"FIXED_TWO_PI\": () => (/* binding */ FIXED_TWO_PI),\n/* harmony export */   \"FixedPointAnimation\": () => (/* binding */ FixedPointAnimation),\n/* harmony export */   \"FixedPointMath\": () => (/* binding */ FixedPointMath),\n/* harmony export */   \"FixedPointTrig\": () => (/* binding */ FixedPointTrig),\n/* harmony export */   \"fromFixed\": () => (/* binding */ fromFixed),\n/* harmony export */   \"getFixedPointTrig\": () => (/* binding */ getFixedPointTrig),\n/* harmony export */   \"toFixed\": () => (/* binding */ toFixed)\n/* harmony export */ });\n// Ultra-High Performance Fixed-Point Arithmetic System\n// Replaces expensive floating-point operations with integer math\n// 20-40% performance improvement for mathematical operations\n// Especially beneficial for animation easing and interpolation\n\n// Fixed-point scale - 16 bits of fractional precision\nconst FIXED_SCALE = 65536; // 2^16\nconst FIXED_SCALE_SHIFT = 16;\n\n// Pre-computed constants in fixed-point format\nconst FIXED_ONE = FIXED_SCALE;           // 1.0\nconst FIXED_HALF = FIXED_SCALE >> 1;     // 0.5\nconst FIXED_QUARTER = FIXED_SCALE >> 2;  // 0.25\nconst FIXED_TWO = FIXED_SCALE << 1;      // 2.0\nconst FIXED_THREE = FIXED_SCALE * 3;     // 3.0\nconst FIXED_PI = Math.floor(Math.PI * FIXED_SCALE);     // π\nconst FIXED_TWO_PI = Math.floor(Math.PI * 2 * FIXED_SCALE); // 2π\n\n// Ultra-fast fixed-point arithmetic operations\nclass FixedPointMath {\n  // Convert floating-point to fixed-point\n  static fromFloat(f) {\n    return Math.floor(f * FIXED_SCALE);\n  }\n  \n  // Convert fixed-point to floating-point\n  static toFloat(fp) {\n    return fp / FIXED_SCALE;\n  }\n  \n  // Fixed-point multiplication - uses bit shift for division\n  static multiply(a, b) {\n    // Use 64-bit intermediate to avoid overflow\n    return Math.floor((a * b) / FIXED_SCALE);\n  }\n  \n  // Fixed-point division\n  static divide(a, b) {\n    return Math.floor((a * FIXED_SCALE) / b);\n  }\n  \n  // Fast addition (just regular addition)\n  static add(a, b) {\n    return a + b;\n  }\n  \n  // Fast subtraction\n  static subtract(a, b) {\n    return a - b;\n  }\n  \n  // Fast absolute value using bitwise operations\n  static abs(a) {\n    const mask = a >> 31; // Sign bit mask\n    return (a + mask) ^ mask;\n  }\n  \n  // Fast minimum\n  static min(a, b) {\n    return a < b ? a : b;\n  }\n  \n  // Fast maximum  \n  static max(a, b) {\n    return a > b ? a : b;\n  }\n  \n  // Clamp value between min and max\n  static clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n  }\n  \n  // Ultra-fast linear interpolation\n  static lerp(a, b, t) {\n    // lerp(a, b, t) = a + t * (b - a)\n    return a + this.multiply(t, b - a);\n  }\n  \n  // Smooth step interpolation (3t² - 2t³)\n  static smoothStep(t) {\n    // Clamp t to [0, 1] range\n    t = this.clamp(t, 0, FIXED_ONE);\n    \n    // Calculate t²\n    const t2 = this.multiply(t, t);\n    \n    // Calculate t³\n    const t3 = this.multiply(t2, t);\n    \n    // 3t² - 2t³\n    return this.multiply(FIXED_THREE, t2) - this.multiply(FIXED_TWO, t3);\n  }\n  \n  // Smoother step interpolation (6t⁵ - 15t⁴ + 10t³)\n  static smootherStep(t) {\n    t = this.clamp(t, 0, FIXED_ONE);\n    \n    const t2 = this.multiply(t, t);\n    const t3 = this.multiply(t2, t);\n    const t4 = this.multiply(t3, t);\n    const t5 = this.multiply(t4, t);\n    \n    // 6t⁵ - 15t⁴ + 10t³\n    return this.multiply(6 * FIXED_ONE, t5) - \n           this.multiply(15 * FIXED_ONE, t4) + \n           this.multiply(10 * FIXED_ONE, t3);\n  }\n  \n  // Fast ease-in-out cubic (simplified)\n  static easeInOutCubic(t) {\n    t = this.clamp(t, 0, FIXED_ONE);\n    \n    if (t < FIXED_HALF) {\n      // 4t³ for first half\n      const t3 = this.multiply(this.multiply(t, t), t);\n      return this.multiply(4 * FIXED_ONE, t3);\n    } else {\n      // 1 - 4(1-t)³ for second half\n      const oneMinusT = FIXED_ONE - t;\n      const cubed = this.multiply(this.multiply(oneMinusT, oneMinusT), oneMinusT);\n      return FIXED_ONE - this.multiply(4 * FIXED_ONE, cubed);\n    }\n  }\n  \n  // Fast ease-in-out quadratic\n  static easeInOutQuad(t) {\n    t = this.clamp(t, 0, FIXED_ONE);\n    \n    if (t < FIXED_HALF) {\n      // 2t²\n      return this.multiply(FIXED_TWO, this.multiply(t, t));\n    } else {\n      // 1 - 2(1-t)²\n      const oneMinusT = FIXED_ONE - t;\n      return FIXED_ONE - this.multiply(FIXED_TWO, this.multiply(oneMinusT, oneMinusT));\n    }\n  }\n}\n\n// Pre-computed sine/cosine lookup tables in fixed-point format\nclass FixedPointTrig {\n  constructor(tableSize = 1024) {\n    this.tableSize = tableSize;\n    this.tableMask = tableSize - 1; // For fast modulo using bitwise AND\n    \n    // Pre-compute sine and cosine tables\n    this.sinTable = new Int32Array(tableSize);\n    this.cosTable = new Int32Array(tableSize);\n    \n    for (let i = 0; i < tableSize; i++) {\n      const angle = (i / tableSize) * Math.PI * 2;\n      this.sinTable[i] = FixedPointMath.fromFloat(Math.sin(angle));\n      this.cosTable[i] = FixedPointMath.fromFloat(Math.cos(angle));\n    }\n  }\n  \n  // Ultra-fast sine lookup - angle in fixed-point format\n  sin(angle) {\n    // Normalize angle to table range\n    const index = Math.floor((angle * this.tableSize) / FIXED_TWO_PI) & this.tableMask;\n    return this.sinTable[index];\n  }\n  \n  // Ultra-fast cosine lookup\n  cos(angle) {\n    const index = Math.floor((angle * this.tableSize) / FIXED_TWO_PI) & this.tableMask;\n    return this.cosTable[index];\n  }\n  \n  // Combined sin/cos for efficiency when both are needed\n  sinCos(angle) {\n    const index = Math.floor((angle * this.tableSize) / FIXED_TWO_PI) & this.tableMask;\n    return {\n      sin: this.sinTable[index],\n      cos: this.cosTable[index]\n    };\n  }\n}\n\n// Global instance for easy access\nlet globalFixedTrig = null;\n\nfunction getFixedPointTrig() {\n  if (!globalFixedTrig) {\n    globalFixedTrig = new FixedPointTrig(1024);\n  }\n  return globalFixedTrig;\n}\n\n// Animation-specific optimized functions\nclass FixedPointAnimation {\n  // Ultra-fast progress calculation for animations\n  static calculateProgress(currentTime, startTime, duration) {\n    if (duration <= 0) return FIXED_ONE;\n    \n    const elapsed = currentTime - startTime;\n    if (elapsed <= 0) return 0;\n    if (elapsed >= duration) return FIXED_ONE;\n    \n    // Convert to fixed-point and calculate ratio\n    return FixedPointMath.divide(\n      FixedPointMath.fromFloat(elapsed),\n      FixedPointMath.fromFloat(duration)\n    );\n  }\n  \n  // Optimized opacity calculation for fades\n  static calculateOpacity(progress, easingFunction = null) {\n    if (easingFunction) {\n      progress = easingFunction(progress);\n    }\n    \n    // Convert back to 0-255 range for opacity\n    return Math.floor(FixedPointMath.toFloat(progress) * 255);\n  }\n  \n  // Optimized position interpolation\n  static interpolatePosition(startX, startY, endX, endY, progress) {\n    const fixedStartX = FixedPointMath.fromFloat(startX);\n    const fixedStartY = FixedPointMath.fromFloat(startY);\n    const fixedEndX = FixedPointMath.fromFloat(endX);\n    const fixedEndY = FixedPointMath.fromFloat(endY);\n    \n    return {\n      x: FixedPointMath.toFloat(FixedPointMath.lerp(fixedStartX, fixedEndX, progress)),\n      y: FixedPointMath.toFloat(FixedPointMath.lerp(fixedStartY, fixedEndY, progress))\n    };\n  }\n  \n  // Optimized color interpolation (RGB)\n  static interpolateColor(r1, g1, b1, r2, g2, b2, progress) {\n    const fixedR1 = FixedPointMath.fromFloat(r1);\n    const fixedG1 = FixedPointMath.fromFloat(g1);\n    const fixedB1 = FixedPointMath.fromFloat(b1);\n    const fixedR2 = FixedPointMath.fromFloat(r2);\n    const fixedG2 = FixedPointMath.fromFloat(g2);\n    const fixedB2 = FixedPointMath.fromFloat(b2);\n    \n    return {\n      r: Math.floor(FixedPointMath.toFloat(FixedPointMath.lerp(fixedR1, fixedR2, progress))),\n      g: Math.floor(FixedPointMath.toFloat(FixedPointMath.lerp(fixedG1, fixedG2, progress))),\n      b: Math.floor(FixedPointMath.toFloat(FixedPointMath.lerp(fixedB1, fixedB2, progress)))\n    };\n  }\n}\n\n// Utility functions for easy conversion\nfunction toFixed(f) {\n  return FixedPointMath.fromFloat(f);\n}\n\nfunction fromFixed(fp) {\n  return FixedPointMath.toFloat(fp);\n}\n\n// Pre-computed common values for even faster access\nconst FIXED_COMMON = {\n  ZERO: 0,\n  ONE: FIXED_ONE,\n  HALF: FIXED_HALF,\n  QUARTER: FIXED_QUARTER,\n  TWO: FIXED_TWO,\n  THREE: FIXED_THREE,\n  PI: FIXED_PI,\n  TWO_PI: FIXED_TWO_PI,\n  \n  // Common animation values\n  OPACITY_FULL: FixedPointMath.fromFloat(255),\n  OPACITY_HALF: FixedPointMath.fromFloat(127.5),\n  OPACITY_QUARTER: FixedPointMath.fromFloat(63.75),\n  \n  // Common time values (in milliseconds)\n  SECOND: FixedPointMath.fromFloat(1000),\n  HALF_SECOND: FixedPointMath.fromFloat(500),\n  QUARTER_SECOND: FixedPointMath.fromFloat(250)\n}; \n\n//# sourceURL=webpack://particles/./src/lib/fixedPointMath.js?");
  
  /***/ }),
  
  /***/ "./src/lib/gem.js":
  /*!************************!*\
    !*** ./src/lib/gem.js ***!
    \************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gem\": () => (/* binding */ Gem)\n/* harmony export */ });\n/* harmony import */ var _spatialHashGrid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spatialHashGrid.js */ \"./src/lib/spatialHashGrid.js\");\nconst {\n  gifSize,\n  RABBIT_SPEED,\n  SPEECH_CHANCE,\n  speechTexts,\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\n// Import high-performance collision detection\n\n\n// DOM Element Pool - Eliminate expensive createImg/remove operations\nclass DOMElementPool {\n  constructor(p5, poolSize = 50) {\n    this.p5 = p5;\n    this.availableElements = [];\n    this.usedElements = new Set();\n    \n    // Pre-create a pool of DOM elements\n    for (let i = 0; i < poolSize; i++) {\n      const element = this.p5.createImg(\"gem.gif\", \"pooled-element\");\n      element.style(\"position\", \"absolute\");\n      element.style(\"z-index\", \"999\");\n      element.style(\"will-change\", \"transform, opacity\");\n      element.style(\"backface-visibility\", \"hidden\");\n      element.style(\"display\", \"none\"); // Hidden by default\n      this.availableElements.push(element);\n    }\n  }\n  \n  acquire() {\n    if (this.availableElements.length > 0) {\n      const element = this.availableElements.pop();\n      this.usedElements.add(element);\n      element.style(\"display\", \"block\");\n      return element;\n    }\n    \n    // If pool is exhausted, create new element (fallback)\n    const element = this.p5.createImg(\"gem.gif\", \"overflow-element\");\n    element.style(\"position\", \"absolute\");\n    element.style(\"z-index\", \"999\");\n    element.style(\"will-change\", \"transform, opacity\");\n    element.style(\"backface-visibility\", \"hidden\");\n    this.usedElements.add(element);\n    return element;\n  }\n  \n  release(element) {\n    if (this.usedElements.has(element)) {\n      this.usedElements.delete(element);\n      element.style(\"display\", \"none\");\n      this.availableElements.push(element);\n    }\n  }\n}\n\n// Global DOM pool instance\nlet domPool = null;\n\n// Initialize DOM pool when needed\nconst getDOMPool = (p5) => {\n  if (!domPool) {\n    domPool = new DOMElementPool(p5, 100); // Pre-create 100 elements\n  }\n  return domPool;\n};\n\n// Performance optimization: Precomputed lookup tables\nconst PRECOMPUTED_SIN = [];\nconst TABLE_SIZE = 512; // Smaller table for gems - power of 2 for fast bitwise AND\n\n// Build lookup table once at module load\nfor (let i = 0; i < TABLE_SIZE; i++) {\n  const angle = (i / TABLE_SIZE) * Math.PI * 2;\n  PRECOMPUTED_SIN[i] = Math.sin(angle);\n}\n\n// Fast sin function using lookup table\nconst fastSin = (x) => {\n  const index = Math.floor(x * TABLE_SIZE / (Math.PI * 2)) & (TABLE_SIZE - 1);\n  return PRECOMPUTED_SIN[index];\n};\n\n// Precomputed type thresholds for fast type determination\nconst TYPE_THRESHOLDS = [0.33, 0.66, 1.0];\nconst TYPE_NAMES = [\"gem.gif\", \"magic.gif\", \"fire.gif\"];\nconst SCALE_FACTORS = [0.4, 0.6, 0.6]; // Precomputed scale factors for each type\n\nclass Gem {\n  constructor(p5, initialX = null, initialY = null) {\n    this.p5 = p5;\n    this.active = false;\n    \n    // Enhanced initial positioning for screen filling\n    if (initialX !== null && initialY !== null) {\n      // Use provided coordinates for initial distribution\n      this.x = initialX;\n      this.y = initialY;\n      this.nextAppearance = p5.millis() + p5.random(20, 150); // Ultra-quick initial spawn\n    } else {\n      // Random positioning for dynamic spawns - ensure immediate availability\n      this.nextAppearance = p5.millis() + p5.random(10, 100); // Ultra-fast spawning for new gems\n    }\n\n    // Movement system - same speed as rabbits for cohesive illusion\n    this.speed = RABBIT_SPEED;\n\n    this.baseY = 0;\n    this.floatOffset = 13;\n    this.floatStep = 1;\n    this.floatDirection = 1;\n    this.floatDelay = 150 + this.p5.random(50);\n    this.lastFloatTime = 0;\n    this.allSame = null;\n    this.unificationEndTime = null; // Mathematical unification end time - no setTimeout\n    this.origSrc;\n    \n    // Pure mathematical identity for each gem\n    this.mathSeed = Math.random();\n    this.chaosX = Math.random() * 1000;\n    this.chaosY = Math.random() * 1000;\n    this.gemIndex = Math.floor(Math.random() * 1000);\n    \n    // Precompute expensive operations\n    this.precomputedTimeScale = p5.random(0.0001, 0.0002);\n    this.precomputedPhaseOffset = p5.random(0, 6.28318); // Pre-computed 2π\n    this.precomputedMathSeed2Pi = this.mathSeed * 6.28318;\n    this.precomputedSpeedRatio = this.speed * 0.125;\n    this.precomputedFloatRatio = this.floatOffset * 0.6;\n    \n    // Simplified mathematical wave parameters\n    this.spaceScale = p5.random(0.005, 0.01); // Reduced range\n    this.frequencyModulator = p5.random(0.9, 1.1); // Reduced range\n    \n    // Extreme mathematical parameters - simplified\n    this.extremeFreq = p5.random(0.00002, 0.00004);\n    this.extremePhase = p5.random(0, 6.28318);\n    this.extremeAmplitude = p5.random(0.7, 1.3);\n    \n    // Flash mathematical identity - optimized\n    this.flashSeed = Math.random();\n    this.flashFreq = p5.random(0.0015, 0.0025); // Increased for more visible flashing\n    this.flashPhase = p5.random(0, 6.28318);\n    \n    // Performance optimization: Update frequency control\n    this.lastMathUpdate = 0;\n    this.mathUpdateInterval = 120; // Update expensive calculations every 120ms\n    this.lastDOMUpdate = 0;\n    this.domUpdateInterval = 60; // DOM updates max ~16fps\n    this.lastTypeUpdate = 0;\n    this.typeUpdateInterval = 200; // Type changes max 5fps\n    \n    // Cached calculations\n    this.cachedFlashOpacity = 0.7;\n    this.cachedType = null;\n    this.cachedTypeIndex = 0; // Cache type index for fast scale factor lookup\n    this.lastX = this.x;\n    this.lastY = this.y;\n    \n    this.currentType = null;\n    this.gif = null; // Will be acquired from pool when needed\n  }\n\n  setAllSame(type) {\n    this.allSame = type;\n    \n    // Mathematical duration calculation - no setTimeout\n    const currentTime = this.p5.millis();\n    const extremeIntensity = Math.max(0, fastSin(currentTime * this.extremeFreq + this.extremePhase));\n    const duration = 400 + (extremeIntensity * 1100); // 400-1500ms based on math\n    \n    // Store when unification should end mathematically\n    this.unificationEndTime = currentTime + duration;\n  }\n\n  // Get global wave-based type\n  getWaveType() {\n    return window.globalCollectibleType || null;\n  }\n\n  spawn(existingGems, rabbitRows, rabbits = []) {\n    // Optimized spawn with reduced attempt count for performance\n    let attempts = 0;\n    const maxAttempts = 15; // Reduced from 30 for faster spawning\n    const minDistanceSquared = (gifSize * 0.7) * (gifSize * 0.7); // Pre-squared for faster comparison\n    const rabbitAvoidanceDistanceSquared = (gifSize * 1.2) * (gifSize * 1.2); // Pre-squared\n    const speechBalloonAvoidanceDistanceSquared = (gifSize * 1.5) * (gifSize * 1.5); // Pre-squared\n\n    do {\n      // Enhanced positioning with grid-based distribution for better screen filling\n      if (this.x === undefined || this.y === undefined) {\n        // Grid-based initial positioning for better distribution\n        const gridCols = Math.floor(this.p5.width / (gifSize * 1.5));\n        const gridRows = Math.floor(this.p5.height / (gifSize * 1.5));\n        \n        const gridX = (existingGems.length % gridCols) + this.p5.random(-0.3, 0.3);\n        const gridY = Math.floor(existingGems.length / gridCols) % gridRows + this.p5.random(-0.3, 0.3);\n        \n        this.x = (gridX * gifSize * 1.5) + gifSize + this.p5.random(-gifSize * 0.3, gifSize * 0.3);\n        this.y = (gridY * gifSize * 1.5) + gifSize + this.p5.random(-gifSize * 0.3, gifSize * 0.3);\n      \n        // Ensure within screen bounds\n        this.x = Math.max(gifSize, Math.min(this.p5.width - gifSize, this.x));\n        this.y = Math.max(gifSize, Math.min(this.p5.height - gifSize * 2, this.y));\n      } else {\n        // Extended positioning for dynamic spawns - heavily favor right edge and beyond\n        const extendedWidth = this.p5.width + (gifSize * 8); // Much larger extension\n        const rightBias = this.p5.random() < 0.7; // 70% chance to spawn on right side/beyond\n        \n        if (rightBias) {\n          // Spawn from right 30% of screen to well beyond right edge\n          this.x = this.p5.random(this.p5.width * 0.7, extendedWidth);\n        } else {\n          // Occasionally spawn elsewhere for variety\n          this.x = this.p5.random(gifSize, this.p5.width - gifSize);\n        }\n        \n        this.y = this.p5.random(gifSize, this.p5.height - gifSize * 2);\n      }\n      \n      // Optimized overlap checking - use squared distances throughout\n      let hasOverlap = false;\n\n      // Check for overlap with existing gems - optimized loop\n      for (let i = 0; i < existingGems.length && !hasOverlap; i++) {\n        const gem = existingGems[i];\n        if (gem.active) {\n          const dx = gem.x - this.x;\n          const dy = gem.y - this.y;\n          const distanceSquared = dx * dx + dy * dy;\n          if (distanceSquared < minDistanceSquared) {\n            hasOverlap = true;\n          }\n        }\n      }\n      \n      // Check for overlap with active rabbits - optimized\n      if (!hasOverlap) {\n        for (let i = 0; i < rabbits.length && !hasOverlap; i++) {\n          const rabbit = rabbits[i];\n          if (rabbit.isVisible()) {\n            const rabbitPos = rabbit.getPosition();\n            const dx = rabbitPos.x - this.x;\n            const dy = rabbitPos.y - this.y;\n            const distanceSquared = dx * dx + dy * dy;\n            \n            if (distanceSquared < rabbitAvoidanceDistanceSquared) {\n              hasOverlap = true;\n            }\n          }\n        }\n      }\n      \n      if (!hasOverlap) break;\n      attempts++;\n    } while (attempts < maxAttempts);\n\n    if (attempts >= maxAttempts) {\n      // If we can't find a non-overlapping spot, place it in a less crowded area\n      this.x = this.p5.random(gifSize, this.p5.width - gifSize);\n      this.y = this.p5.random(gifSize, this.p5.height - gifSize * 2);\n    }\n\n    this.active = true;\n    this.baseY = this.y; // Store base Y position\n\n    // Optimized random type selection using lookup table\n    const r = this.p5.random();\n    const typeIndex = r < 0.3 ? 0 : r < 0.6 ? 1 : 2;\n    let randImg = TYPE_NAMES[typeIndex];\n\n    this.origSrc = randImg;\n\n    // Check for global wave type first, then local override\n    const globalWaveType = this.getWaveType();\n    if (globalWaveType) {\n      randImg = globalWaveType;\n    } else if (this.allSame) {\n      randImg = this.allSame;\n    } else {\n      randImg = this.origSrc;\n    }\n\n    // Revolutionary DOM pooling - acquire from pool instead of creating\n    this.gif = getDOMPool(this.p5).acquire();\n    \n    // Fast type index lookup for scale factor\n    this.cachedTypeIndex = TYPE_NAMES.indexOf(randImg);\n    const scaleFactor = SCALE_FACTORS[this.cachedTypeIndex];\n    \n    // Set image source (much faster than creating new element)\n    this.gif.elt.src = randImg;\n    this.gif.size(gifSize * scaleFactor, gifSize * scaleFactor);\n    \n    // Dynamic positioning - center the gif on the calculated coordinates\n    const actualSize = gifSize * scaleFactor;\n    this.gif.position(this.x - actualSize / 2, this.y - actualSize / 2);\n    \n    // Set initial type for wave system\n    this.currentType = randImg;\n    this.cachedType = randImg;\n  }\n\n  collect() {\n    this.active = false;\n    if (this.gif) {\n      // Return to pool instead of destroying - MASSIVE performance gain\n      getDOMPool(this.p5).release(this.gif);\n      this.gif = null; // Clear reference\n    }\n    // Set next appearance with much shorter delay for higher density\n    this.nextAppearance = this.p5.millis() + this.p5.random(200, 600);\n    \n    // Reset current type to ensure fresh spawning\n    this.currentType = null;\n    this.cachedType = null;\n  }\n\n  destroy() {\n    // Complete cleanup for gem removal\n    this.active = false;\n    if (this.gif) {\n      // Return to pool instead of destroying - MASSIVE performance gain\n      getDOMPool(this.p5).release(this.gif);\n      this.gif = null;\n    }\n    this.currentType = null;\n    this.cachedType = null;\n  }\n\n  isReadyForCulling() {\n    // Gem is ready for culling if it's been inactive for a while\n    return !this.active && (!this.gif || this.gif === null);\n  }\n\n  // Revolutionary spatial hash grid collision detection - O(1) average case\n  // 10-50x faster than previous O(n²) collision detection\n  checkCollisionWithGrid(spatialGrid) {\n    if (!this.active || !spatialGrid) return;\n    \n    // Pre-computed collision constants\n    const gemHalf = gifSize * 0.2;\n    const rabbitHalf = gifSize * 0.5;\n    const collisionThreshold = rabbitHalf + gemHalf;\n    const collisionThresholdSquared = collisionThreshold * collisionThreshold;\n    \n    // Query spatial grid for nearby rabbits - O(1) average case\n    const nearbyRabbits = spatialGrid.queryNearby(this.x, this.y, collisionThreshold);\n    \n    // Only check the small subset of nearby rabbits\n    for (let i = 0; i < nearbyRabbits.length; i++) {\n      const rabbit = nearbyRabbits[i];\n      \n      // Skip non-rabbits and non-alive rabbits\n      if (!rabbit.isAlive || rabbit.state !== \"alive\") continue;\n      \n      // Fast squared distance check (no expensive square root)\n      const dx = rabbit.x - this.x;\n      const dy = rabbit.y - this.y;\n      const distanceSquared = dx * dx + dy * dy;\n      \n      if (distanceSquared <= collisionThresholdSquared) {\n        // Collision detected - use cached type index for speed\n        const gemType = TYPE_NAMES[this.cachedTypeIndex].replace('.gif', '');\n        \n        rabbit.handleCollision(gemType);\n        this.collect();\n        return; // Early exit after collision\n      }\n    }\n  }\n\n  // Fallback collision detection for systems without spatial grid\n  checkCollision(rabbits) {\n    if (!this.active) return;\n\n    // Pre-computed collision constants\n    const gemHalf = gifSize * 0.2;\n    const rabbitHalf = gifSize * 0.5;\n    const maxDistance = gifSize; // Pre-computed maximum distance\n    const collisionThreshold = rabbitHalf + gemHalf;\n    \n    // Spatial optimization - only check rabbits within reasonable range\n    const gemLeft = this.x - maxDistance;\n    const gemRight = this.x + maxDistance;\n    const gemTop = this.y - maxDistance;\n    const gemBottom = this.y + maxDistance;\n    \n    // Optimized collision loop with multiple early exits\n    for (let i = 0; i < rabbits.length; i++) {\n      const rabbit = rabbits[i];\n      \n      // Multiple early exit conditions for maximum performance\n      if (rabbit.state !== \"alive\") continue;\n      \n      // Spatial bounds check first (fastest)\n      if (rabbit.x < gemLeft || rabbit.x > gemRight || \n          rabbit.y < gemTop || rabbit.y > gemBottom) continue;\n      \n      // Fast distance check second\n      const dx = Math.abs(rabbit.x - this.x);\n      const dy = Math.abs(rabbit.y - this.y);\n      \n      // Precise collision check\n      if (dx <= collisionThreshold && dy <= collisionThreshold) {\n        // Collision detected - use cached type index for speed\n        const gemType = TYPE_NAMES[this.cachedTypeIndex].replace('.gif', '');\n        \n        rabbit.handleCollision(gemType);\n        this.collect();\n        return; // Early exit after collision\n      }\n    }\n  }\n\n  // Optimized type determination with caching and fast lookup\n  getTypeFromValue(typeValue) {\n    // Check for global unification type first - this takes priority during wave events\n    const globalUnifiedType = this.getWaveType();\n    if (globalUnifiedType) {\n      return globalUnifiedType;\n    }\n    \n    // Fast type determination using precomputed thresholds\n    return typeValue < TYPE_THRESHOLDS[0] ? TYPE_NAMES[0] : \n           typeValue < TYPE_THRESHOLDS[1] ? TYPE_NAMES[1] : TYPE_NAMES[2];\n  }\n\n  // Revolutionary type switching - just change src instead of DOM creation/destruction\n  switchToType(newType) {\n    if (this.currentType === newType || !this.gif) return;\n    \n    // Ultra-fast type switching - just change the image source!\n    this.gif.elt.src = newType;\n    \n    // Update cached type index for fast scale factor lookup\n    this.cachedTypeIndex = TYPE_NAMES.indexOf(newType);\n    const scaleFactor = SCALE_FACTORS[this.cachedTypeIndex];\n    this.gif.size(gifSize * scaleFactor, gifSize * scaleFactor);\n    \n    // Dynamic positioning - center the gif on coordinates\n    const actualSize = gifSize * scaleFactor;\n    this.gif.position(this.x - actualSize / 2, this.y - actualSize / 2);\n    \n    this.currentType = newType;\n    this.cachedType = newType;\n  }\n\n  update(rabbits, existingGems, rabbitRows) {\n    const now = this.p5.millis();\n\n    // Mathematical unification end check - no setTimeout\n    if (this.unificationEndTime && now >= this.unificationEndTime) {\n      this.allSame = null;\n      this.unificationEndTime = null;\n    }\n\n    // Performance optimization: Early exit for inactive gems\n    const shouldBeActive = now > this.nextAppearance;\n    if (!this.active && !shouldBeActive) return;\n\n    // Mathematical spawning - no conditionals  \n    if (shouldBeActive && !this.active) {\n      this.spawn(existingGems, rabbitRows, rabbits);\n      return; // Early exit after spawning\n    }\n\n    // Performance optimization: Only calculate for active gems\n    if (this.active && this.gif) {\n      // Update expensive math calculations less frequently\n      if (now - this.lastMathUpdate > this.mathUpdateInterval) {\n        this.lastMathUpdate = now;\n        \n        // Simplified flash calculation using fast sin\n        const timeCache = now * 0.001;\n        this.cachedFlashOpacity = 0.7 + fastSin(timeCache * this.flashFreq + this.flashPhase) * 0.3;\n      }\n\n      // Update type less frequently\n      if (now - this.lastTypeUpdate > this.typeUpdateInterval) {\n        this.lastTypeUpdate = now;\n        \n        // Simplified type calculation using fast sin and precomputed values\n        const typeValue = fastSin(now * this.precomputedTimeScale + this.precomputedMathSeed2Pi) * 0.5 + 0.5;\n        const newType = this.allSame || this.getTypeFromValue(typeValue);\n        \n        if (newType !== this.cachedType) {\n        this.switchToType(newType);\n        }\n      }\n\n      // Always update position (cheap operation)\n      this.x -= this.precomputedSpeedRatio;\n      \n      // Optimized wrap-around check\n      if (this.x < -gifSize) {\n        this.x = this.p5.width + gifSize;\n      }\n      \n      // Simplified floating Y position using fast sin and precomputed values\n      const timeCache = now * 0.001;\n      this.y = this.baseY + fastSin(timeCache * 2 + this.precomputedMathSeed2Pi) * this.precomputedFloatRatio;\n\n      // ULTRA-OPTIMIZED DOM updates - batch operations and minimize calls\n      const xDelta = Math.abs(this.x - this.lastX);\n      const yDelta = Math.abs(this.y - this.lastY);\n      const timeDelta = now - this.lastDOMUpdate;\n      \n      if (timeDelta > this.domUpdateInterval || xDelta > 3 || yDelta > 1) {\n        this.lastDOMUpdate = now;\n        this.lastX = this.x;\n        this.lastY = this.y;\n        \n        // Pre-compute all values to minimize calculations in DOM operations\n        const scaleFactor = SCALE_FACTORS[this.cachedTypeIndex];\n        const halfSize = (gifSize * scaleFactor) * 0.5;\n        const roundedX = Math.round(this.x - halfSize);\n        const roundedY = Math.round(this.y - halfSize);\n        \n        // Batch DOM operations - use direct style manipulation for maximum performance\n        const element = this.gif.elt;\n        element.style.opacity = this.cachedFlashOpacity.toFixed(2);\n        element.style.left = roundedX + 'px';\n        element.style.top = roundedY + 'px';\n      }\n\n      // Use spatial grid collision detection if available, fallback to traditional method\n      if (window.spatialGrid) {\n        this.checkCollisionWithGrid(window.spatialGrid);\n      } else {\n      this.checkCollision(rabbits);\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/gem.js?");
  
  /***/ }),
  
  /***/ "./src/lib/gifManager.js":
  /*!*******************************!*\
    !*** ./src/lib/gifManager.js ***!
    \*******************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GifManager\": () => (/* binding */ GifManager)\n/* harmony export */ });\n/* harmony import */ var _rabbitEntity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rabbitEntity.js */ \"./src/lib/rabbitEntity.js\");\n/* harmony import */ var _spatialHashGrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spatialHashGrid.js */ \"./src/lib/spatialHashGrid.js\");\n/* harmony import */ var _objectPools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objectPools.js */ \"./src/lib/objectPools.js\");\nconst {\n  gifSize,\n  speechTexts,\n  chineseSpeechTexts\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\nconst { Gem } = __webpack_require__(/*! ./gem */ \"./src/lib/gem.js\");\n\n// Import the new unified rabbit entity class\n\n\n// Import revolutionary performance systems\n\n\n\n// Performance optimization: Precomputed noise replacement\nconst NOISE_TABLE_SIZE = 256;\nconst NOISE_TABLE = [];\n\n// Build fast noise table once at module load\nfor (let i = 0; i < NOISE_TABLE_SIZE; i++) {\n  NOISE_TABLE[i] = Math.random();\n}\n\n// Fast noise replacement using lookup table\nconst fastNoise = (x, seed = 0) => {\n  const index = (Math.floor(x * 1000) + seed) & (NOISE_TABLE_SIZE - 1);\n  return NOISE_TABLE[index];\n};\n\n// Precomputed sin/cos tables for smooth waves\nconst WAVE_TABLE_SIZE = 512;\nconst PRECOMPUTED_SIN = [];\n\nfor (let i = 0; i < WAVE_TABLE_SIZE; i++) {\n  const angle = (i / WAVE_TABLE_SIZE) * Math.PI * 2;\n  PRECOMPUTED_SIN[i] = Math.sin(angle);\n}\n\nconst fastSin = (x) => {\n  const index = Math.floor(x * WAVE_TABLE_SIZE / (Math.PI * 2)) & (WAVE_TABLE_SIZE - 1);\n  return PRECOMPUTED_SIN[index];\n};\n\nclass GifManager {\n  constructor(p5, numGifs, fonts = { arcade: null, chinese: null }) {\n    this.p5 = p5;\n    this.numGifs = numGifs;\n    this.gifElements = [];\n    this.fonts = fonts;\n    \n    // Revolutionary Performance Systems\n    // Ultra-fast spatial hash grid for collision detection\n    this.spatialGrid = (0,_spatialHashGrid_js__WEBPACK_IMPORTED_MODULE_1__.createOptimalSpatialGrid)(\n      p5.width, \n      p5.height, \n      Math.max(gifSize, 64) // Optimal cell size based on object size\n    );\n    \n    // Global object pooling manager\n    this.poolManager = (0,_objectPools_js__WEBPACK_IMPORTED_MODULE_2__.getGlobalPoolManager)(p5);\n    \n    // Expose spatial grid globally for gem access\n    window.spatialGrid = this.spatialGrid;\n    window.poolManager = this.poolManager;\n    \n    // Create individual autonomous rabbit instances\n    this.createGifs();\n    \n    // Global frequency wave for system-wide effects\n    this.globalWave = new GlobalFrequencyWave(p5);\n    \n    // Initialize gems array with dynamic wave system\n    this.gems = [];\n    this.populationWaveSystem = new DynamicPopulationWave(p5);\n    \n    // Initialize collectible flow system\n    this.collectibleFlowSystem = new CollectibleFlowSystem(p5);\n    \n    // Create initial gems with distributed positioning for screen filling\n    this.createInitialGems();\n    \n    this.lastPopulationUpdateTime = p5.millis();\n    this.populationUpdateInterval = 1000;\n    \n    // Performance optimization: Cached calculations and reduced update frequencies\n    this._cachedVisibleRabbits = [];\n    this._cachedAliveRabbits = [];\n    this._cachedRabbitRows = new Set();\n    this.lastRabbitCacheUpdate = 0;\n    this.rabbitCacheInterval = 100; // Update rabbit cache every 100ms\n    \n    this.lastCleanupTime = 0;\n    this.cleanupInterval = 5000; // Cleanup every 5 seconds\n    \n    this.lastStatusLogTime = 0;\n    this.statusLogInterval = 30000; // Log status every 30 seconds\n    \n    // Spatial grid update tracking\n    this.lastSpatialUpdate = 0;\n    this.spatialUpdateInterval = 33; // Update spatial grid ~30fps for performance\n  }\n\n  createGifs() {\n    const canvasWidth = this.p5.width;\n    const canvasHeight = this.p5.height;\n    \n    // Create unified rabbit entities distributed across the screen\n    for (let i = 0; i < this.numGifs; i++) {\n      // Distribute rabbits across the width\n      const x = (i * (canvasWidth / this.numGifs)) + this.p5.random(-10, 10);\n      \n      // Better Y distribution - avoid top and bottom areas (middle 60% of screen)\n      const minY = canvasHeight * 0.05;\n      const maxY = canvasHeight * 0.95;\n      const y = this.p5.random(minY, maxY);\n      \n      // Use the new unified RabbitEntity class\n      const rabbit = new _rabbitEntity_js__WEBPACK_IMPORTED_MODULE_0__.RabbitEntity(this.p5, x, y, this.fonts);\n      this.gifElements.push(rabbit);\n    }\n  }\n\n  createInitialGems() {\n    const canvasWidth = this.p5.width;\n    const canvasHeight = this.p5.height;\n    \n    // Calculate optimal grid for screen filling with much larger right-edge extension\n    const gemSpacing = gifSize * 1.8; // Spacing between gems\n    const extendedWidth = canvasWidth + (gemSpacing * 10); // Much larger extension beyond right edge\n    const gridCols = Math.floor(extendedWidth / gemSpacing);\n    const gridRows = Math.floor((canvasHeight - gifSize * 2) / gemSpacing); // Account for top/bottom margins\n    \n    // Create gems in a distributed grid pattern extending beyond screen\n    const totalGridSlots = gridCols * gridRows;\n    const initialGemCount = Math.min(Math.floor(this.p5.random(70, 90)), Math.floor(totalGridSlots * 0.6)); // Start with moderate screen flow\n    \n    // Create array of all possible grid positions\n    const gridPositions = [];\n    for (let row = 0; row < gridRows; row++) {\n      for (let col = 0; col < gridCols; col++) {\n        gridPositions.push({ col, row });\n      }\n    }\n    \n    // Shuffle positions for random but distributed placement\n    for (let i = gridPositions.length - 1; i > 0; i--) {\n      const j = Math.floor(this.p5.random() * (i + 1));\n      [gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]];\n    }\n    \n    // Create gems at selected grid positions, favoring right side for natural flow\n    for (let i = 0; i < initialGemCount; i++) {\n      const { col, row } = gridPositions[i];\n      \n      // Calculate position with slight randomization, starting from right edge\n      const baseX = col * gemSpacing + gemSpacing / 2;\n      const baseY = row * gemSpacing + gemSpacing / 2 + gifSize; // Add top margin\n      \n      const x = baseX + this.p5.random(-gemSpacing * 0.2, gemSpacing * 0.2);\n      const y = baseY + this.p5.random(-gemSpacing * 0.2, gemSpacing * 0.2);\n      \n      // Allow gems to spawn well beyond right edge of screen for natural flow\n      const clampedX = Math.max(-gifSize * 2, Math.min(extendedWidth, x)); // Allow more off-screen spawning on both sides\n      const clampedY = Math.max(gifSize, Math.min(canvasHeight - gifSize * 2, y));\n      \n      this.gems.push(new Gem(this.p5, clampedX, clampedY));\n    }\n  }\n\n  update() {\n    const now = this.p5.millis();\n    \n    // Update global frequency wave\n    this.globalWave.update();\n    \n    // Update collectible flow system\n    this.collectibleFlowSystem.update();\n    \n    // Revolutionary spatial hash grid system - update positions\n    this.updateSpatialGrid(now);\n    \n    // Ultra-optimized rabbit updates - direct array access eliminates forEach overhead\n    const rabbitCount = this.gifElements.length;\n    for (let i = 0; i < rabbitCount; i++) {\n      this.gifElements[i].update();\n    }\n    \n    // Update gems with optimized caching\n    this.updateGems(now);\n    \n    // Update object pool statistics\n    this.poolManager.updateStats();\n    \n    // Conditional operations based on time intervals\n    if (now - this.lastStatusLogTime > this.statusLogInterval) {\n      this.lastStatusLogTime = now;\n      this.logSystemStatus();\n    }\n  }\n\n  // Revolutionary spatial hash grid update system\n  // Updates positions in O(n) time for O(1) collision detection\n  updateSpatialGrid(now) {\n    // Throttle spatial grid updates for performance\n    if (now - this.lastSpatialUpdate < this.spatialUpdateInterval) return;\n    \n    this.lastSpatialUpdate = now;\n    \n    // Clear grid for fresh update\n    this.spatialGrid.clear();\n    \n    // Insert all active rabbits into spatial grid\n    for (let i = 0; i < this.gifElements.length; i++) {\n      const rabbit = this.gifElements[i];\n      if (rabbit.isVisible()) {\n        // Add spatial grid compatibility to rabbits\n        rabbit.isAlive = rabbit.isAlive.bind(rabbit);\n        this.spatialGrid.insert(rabbit);\n      }\n    }\n    \n    // Insert all active gems into spatial grid\n    for (let i = 0; i < this.gems.length; i++) {\n      const gem = this.gems[i];\n      if (gem.active) {\n        this.spatialGrid.insert(gem);\n      }\n    }\n  }\n\n  updateGems(now) {\n    // Update cached rabbit data less frequently\n    if (now - this.lastRabbitCacheUpdate > this.rabbitCacheInterval) {\n      this.lastRabbitCacheUpdate = now;\n      this.updateRabbitCache();\n    }\n    \n    // Update gem population based on wave (less frequently for performance)\n    if (this.p5.frameCount % 3 === 0) { // Every 3rd frame instead of every other\n      this.updateGemPopulation(now);\n    }\n    \n    // Ultra-optimized gem updates - cache array length to eliminate repeated access\n    const gemCount = this.gems.length;\n    for (let i = 0; i < gemCount; i++) {\n      this.gems[i].update(this._cachedVisibleRabbits, this.gems, this._cachedRabbitRows);\n    }\n    \n    // Periodic cleanup to prevent leftovers\n    if (now - this.lastCleanupTime > this.cleanupInterval) {\n      this.lastCleanupTime = now;\n      this.performMaintenanceCleanup(now);\n    }\n  }\n\n  // Ultra-optimized rabbit data caching with pre-allocated arrays\n  updateRabbitCache() {\n    // Clear previous caches efficiently\n    this._cachedVisibleRabbits.length = 0;\n    this._cachedAliveRabbits.length = 0; // Clear alive cache too\n    \n    // Clear the rabbit rows Set properly\n    if (this._cachedRabbitRows instanceof Set) {\n      this._cachedRabbitRows.clear();\n    } else {\n      // If it's an array, recreate as Set\n      this._cachedRabbitRows = new Set();\n    }\n    \n    // Single pass to build both caches - cache length for performance\n    const rabbitCount = this.gifElements.length;\n    for (let i = 0; i < rabbitCount; i++) {\n      const rabbit = this.gifElements[i];\n      if (rabbit.isVisible()) {\n        this._cachedVisibleRabbits.push(rabbit);\n        \n        const pos = rabbit.getPosition();\n        const rowIndex = Math.floor(pos.y / gifSize) * gifSize;\n        this._cachedRabbitRows.add(rowIndex);\n      }\n    }\n    \n    // Keep as Set for consistent behavior - no conversion needed\n    // The Set will be used directly for row checking operations\n  }\n\n  performMaintenanceCleanup(now) {\n    let removedCount = 0;\n    let activeCount = 0;\n    \n    // Ultra-fast cleanup using swap-and-pop instead of splice\n    let writeIndex = 0;\n    \n    for (let readIndex = 0; readIndex < this.gems.length; readIndex++) {\n      const gem = this.gems[readIndex];\n      const isActive = gem.active;\n      const hasGif = gem.gif && gem.gif !== null;\n      const timeDelta = gem.nextAppearance ? (now - gem.nextAppearance) : 0;\n      const isStale = timeDelta > 60000;\n      \n      // Keep gem if it should stay\n      if (isActive || (hasGif && !isStale)) {\n        if (readIndex !== writeIndex) {\n          this.gems[writeIndex] = this.gems[readIndex];\n        }\n        if (isActive) activeCount++;\n        writeIndex++;\n      } else {\n        // Remove gem\n        gem.destroy();\n        removedCount++;\n      }\n    }\n    \n    // Shrink array once at the end (much faster than multiple splice calls)\n    this.gems.length = writeIndex;\n  }\n\n  updateGemPopulation(now) {\n    // Update wave system every frame for smooth dynamics\n    this.populationWaveSystem.update();\n    \n    // Check if it's time for population update\n    if (now - this.lastPopulationUpdateTime < this.populationUpdateInterval) {\n      return; // Early exit if not time yet\n    }\n    \n    this.lastPopulationUpdateTime = now;\n    \n    const { targetGemCount, spawnBurst, cullRate } = this.populationWaveSystem.getPopulationData();\n    \n    // Apply unification population boost\n    const unificationBoost = window.globalUnificationPopulationBoost || 1.0;\n    const boostedTargetCount = Math.floor(targetGemCount * unificationBoost);\n    \n    const currentGemCount = this.gems.length;\n    const gemDelta = boostedTargetCount - currentGemCount;\n    \n    // Optimized spawning\n    if (gemDelta > 0) {\n      const deltaAbs = Math.abs(gemDelta);\n      const baseSpawnAmount = Math.ceil(deltaAbs * spawnBurst);\n      \n      // Mathematical unification boost\n      const unificationFactor = unificationBoost > 1.5 ? 1 : 0;\n      const unificationSpeedBoost = 1.0 + unificationFactor;\n      const spawnAmount = Math.floor(baseSpawnAmount * unificationSpeedBoost);\n      const spawnChunks = Math.min(spawnAmount, Math.max(1, Math.floor(spawnAmount * 0.5)));\n      \n      // Create new gems in batch\n      for (let i = 0; i < spawnChunks; i++) {\n        this.gems.push(new Gem(this.p5));\n      }\n    }\n    \n    // Optimized culling\n    if (gemDelta < -3) {\n      const deltaAbs = Math.abs(gemDelta);\n      const gemsToRemove = Math.floor(deltaAbs * cullRate);\n      let removedCount = 0;\n      \n      // Ultra-fast culling using swap-and-pop instead of splice\n      let writeIndex = 0;\n      \n      for (let readIndex = 0; readIndex < this.gems.length && removedCount < gemsToRemove; readIndex++) {\n        const gem = this.gems[readIndex];\n        const isReadyForCull = gem.isReadyForCulling();\n        const isActive = gem.active;\n        \n        // Removal priority calculation\n        const removalWeight = (!isActive ? 1 : 0) + (isActive ? 0.5 : 0);\n        const shouldRemove = Math.random() < removalWeight * 0.3;\n        \n        if (shouldRemove && removedCount < gemsToRemove) {\n          if (isReadyForCull) {\n            gem.destroy();\n            removedCount++;\n          } else if (isActive) {\n            gem.collect();\n            removedCount++;\n          } else {\n            // Keep this gem\n            if (readIndex !== writeIndex) {\n              this.gems[writeIndex] = this.gems[readIndex];\n            }\n            writeIndex++;\n          }\n        } else {\n          // Keep this gem\n          if (readIndex !== writeIndex) {\n            this.gems[writeIndex] = this.gems[readIndex];\n          }\n          writeIndex++;\n        }\n      }\n      \n      // Copy remaining gems if we stopped early due to removal limit\n      for (let readIndex = writeIndex; readIndex < this.gems.length; readIndex++) {\n        if (readIndex !== writeIndex) {\n          this.gems[writeIndex] = this.gems[readIndex];\n        }\n        writeIndex++;\n      }\n      \n      // Shrink array once at the end\n      this.gems.length = writeIndex;\n    }\n    \n    // Mathematical population flow - optimized with fast noise (MODERATE DENSITY)\n    const populationDeficit = Math.max(0, 80 - this.gems.length); // Moderate baseline target\n    if (populationDeficit > 0) {\n      const flowNoise = Math.abs(fastNoise(now * 0.00001, 5000)) * 0.8 + 0.2;\n      const surgeNoise = Math.abs(fastNoise(now * 0.00003, 6000)) * 0.5;\n      \n      const mathematicalSpawn = Math.floor(populationDeficit * flowNoise * (0.8 + surgeNoise)); // Increased multiplier\n      for (let i = 0; i < mathematicalSpawn; i++) {\n        this.gems.push(new Gem(this.p5));\n      }\n    }\n  }\n\n  logSystemStatus() {\n    // Optimized status calculation\n    let visibleRabbits = 0, aliveRabbits = 0, hiddenRabbits = 0;\n    for (let i = 0; i < this.gifElements.length; i++) {\n      const r = this.gifElements[i];\n      if (r.isVisible()) visibleRabbits++;\n      if (r.isAlive()) aliveRabbits++;\n      if (r.getState() === \"hidden\") hiddenRabbits++;\n    }\n    \n    // Safety check for collectible flow system\n    if (!this.collectibleFlowSystem || typeof this.collectibleFlowSystem.getUnificationInfo !== 'function') {\n      return;\n    }\n    \n    const unificationInfo = this.collectibleFlowSystem.getUnificationInfo();\n    const currentState = this.collectibleFlowSystem.getCurrentState();\n  }\n\n  // Public interface for drawing speech bubbles (called from main loop)\n  drawSpeechBubbles() {\n    // Optimized speech bubble rendering\n    for (let i = 0; i < this.gifElements.length; i++) {\n      this.gifElements[i].drawSpeechBubble();\n    }\n  }\n\n  // Optimized public getters with caching\n  getVisibleRabbits() {\n    return this._cachedVisibleRabbits;\n  }\n\n  getAliveRabbits() {\n    // Calculate alive rabbits from cached visible rabbits\n    if (this._cachedAliveRabbits.length === 0 && this._cachedVisibleRabbits.length > 0) {\n      this._cachedAliveRabbits.length = 0; // Clear previous cache\n      for (let i = 0; i < this._cachedVisibleRabbits.length; i++) {\n        if (this._cachedVisibleRabbits[i].isAlive()) {\n          this._cachedAliveRabbits.push(this._cachedVisibleRabbits[i]);\n        }\n      }\n    }\n    return this._cachedAliveRabbits;\n  }\n\n  getAllRabbits() {\n    return this.gifElements;\n  }\n\n  getSystemInfo() {\n    const visible = this.getVisibleRabbits().length;\n    const alive = this.getAliveRabbits().length;\n    \n    return {\n      total: this.numGifs,\n      visible,\n      alive,\n      hidden: this.numGifs - visible,\n      globalWaveIntensity: this.globalWave.getIntensity()\n    };\n  }\n}\n\n// Unified Type Wave System - normally random types, occasional wave unification\nclass CollectibleFlowSystem {\n  constructor(p5) {\n    this.p5 = p5;\n    \n    // Wave system for occasional type unification - faster for shorter events\n    this.unificationWave = {\n      frequency: 0.0004, // Faster wave for shorter, more frequent events\n      amplitude: 1.0,\n      phase: p5.random(0, Math.PI * 2)\n    };\n    \n    this.breathingWave = {\n      frequency: 0.0002,\n      amplitude: 0.3,\n      phase: p5.random(0, Math.PI * 2)\n    };\n    \n    // Wave intensity calculation\n    this.waveIntensity = 0;\n    this.smoothedIntensity = 0;\n    \n    // Unification state\n    this.isUnified = false;\n    this.unificationThreshold = 0.88; // Higher threshold for shorter, punchier events\n    this.unificationStrength = 0; // 0-1, how strongly unified\n    this.currentUnifiedType = null;\n    \n    // Faster smoothing for quicker transitions\n    this.smoothingFactor = 0.985; // Less smoothing for faster response\n    \n    // Type rotation for unification events\n    this.typeRotation = [\"gem.gif\", \"fire.gif\", \"magic.gif\"];\n    this.currentTypeIndex = 0;\n    \n    // Population boost during unification\n    this.unificationPopulationMultiplier = 8.0; // 8x more collectibles during unified events for maximum screen filling\n    \n    // Initialize global state - null means random types\n    window.globalCollectibleType = null;\n    window.globalUnificationStrength = 0;\n    window.globalUnificationPopulationBoost = 1.0;\n    \n    \n  }\n\n  update() {\n    const time = this.p5.millis();\n    \n    // Calculate unification wave intensity\n    this.calculateUnificationWave(time);\n    \n    // Update unification state\n    this.updateUnificationState();\n    \n    // Apply smooth transitions\n    this.applySmoothing();\n  }\n\n  calculateUnificationWave(time) {\n    // Calculate unification wave using fast sin\n    const unificationRaw = fastSin(time * this.unificationWave.frequency + this.unificationWave.phase);\n    const breathingRaw = fastSin(time * this.breathingWave.frequency + this.breathingWave.phase);\n    \n    // Combine waves - breathing adds variation to unification timing\n    const combinedWave = unificationRaw + (breathingRaw * 0.3);\n    \n    // Normalize to 0-1 range\n    const normalizedWave = (combinedWave + 1.3) / 2.6; // Account for breathing wave addition\n    this.waveIntensity = Math.max(0, Math.min(1, normalizedWave));\n  }\n\n  updateUnificationState() {\n    // Check if wave crosses unification threshold\n    if (this.waveIntensity > this.unificationThreshold && !this.isUnified) {\n      // Start unification event\n      this.isUnified = true;\n      this.currentTypeIndex = (this.currentTypeIndex + 1) % this.typeRotation.length;\n      this.currentUnifiedType = this.typeRotation[this.currentTypeIndex];\n      \n      const typeName = this.currentUnifiedType.replace('.gif', '').toUpperCase();\n      \n      \n    } else if (this.waveIntensity < this.unificationThreshold && this.isUnified) {\n      // End unification event\n      this.isUnified = false;\n      this.currentUnifiedType = null;\n      \n    }\n    \n    // Calculate unification strength for smooth transitions\n    if (this.isUnified) {\n      // When unified, strength ramps up based on how far above threshold we are\n      const overThreshold = this.waveIntensity - this.unificationThreshold;\n      const strengthRange = 1.0 - this.unificationThreshold;\n      this.unificationStrength = Math.min(1.0, overThreshold / strengthRange);\n    } else {\n      // When not unified, strength ramps down\n      this.unificationStrength = 0;\n  }\n  }\n\n  applySmoothing() {\n    // Apply faster transitions to unification strength\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.unificationStrength * (1 - this.smoothingFactor);\n    \n    // Calculate population boost based on unification strength\n    const populationBoost = 1.0 + (this.smoothedIntensity * (this.unificationPopulationMultiplier - 1.0));\n    \n    // Update global state for gems to use - faster thresholds for quicker response\n    if (this.isUnified && this.smoothedIntensity > 0.05) {\n      // When unified and strength is significant, set global type (lower threshold for faster start)\n      window.globalCollectibleType = this.currentUnifiedType;\n    } else if (!this.isUnified && this.smoothedIntensity < 0.15) {\n      // When not unified and strength is minimal, clear global type (higher threshold for faster end)\n      window.globalCollectibleType = null;\n    }\n    \n    // Update global unification strength and population boost\n    window.globalUnificationStrength = this.smoothedIntensity;\n    window.globalUnificationPopulationBoost = populationBoost;\n}\n\n  // Public getters for monitoring\n  getUnificationInfo() {\n    return {\n      isUnified: this.isUnified,\n      unificationStrength: this.smoothedIntensity,\n      currentType: this.currentUnifiedType,\n      rawWaveIntensity: this.waveIntensity,\n      phase: this.isUnified ? \"UNIFIED\" : \"RANDOM\"\n    };\n  }\n\n  getIntensity() {\n    return this.smoothedIntensity;\n  }\n\n  getCurrentState() {\n    return this.isUnified ? `UNIFIED_${this.currentUnifiedType?.replace('.gif', '').toUpperCase()}` : \"RANDOM_TYPES\";\n  }\n}\n\n// Smooth Global Wave System with organic flow\nclass GlobalFrequencyWave {\n  constructor(p5) {\n    this.p5 = p5;\n    this.phase = p5.random(0, Math.PI * 2);\n    this.frequency = 0.000015; // Ultra slow frequency for very gradual changes\n    this.amplitude = 1.0;\n    this.intensity = 0.5;\n    this.smoothedIntensity = 0.5;\n    this.targetIntensity = 0.5;\n    \n    // Smoothing system for ultra-smooth transitions\n    this.smoothingFactor = 0.98; // High smoothing for gentle changes\n    this.lastUpdateTime = 0;\n    this.deltaAccumulator = 0;\n    \n    // Organic wave components for natural feeling\n    this.baseWave = { frequency: 0.000012, amplitude: 0.7, phase: p5.random(0, Math.PI * 2) };\n    this.breathWave = { frequency: 0.000008, amplitude: 0.3, phase: p5.random(0, Math.PI * 2) };\n    this.driftWave = { frequency: 0.000025, amplitude: 0.2, phase: p5.random(0, Math.PI * 2) };\n    \n    // Expose to global scope for rabbit coordination\n    window.globalRabbitWaveIntensity = 0.5;\n  }\n\n  update() {\n    const time = this.p5.millis();\n    const deltaTime = time - this.lastUpdateTime;\n    this.lastUpdateTime = time;\n    \n    // Calculate multiple organic wave layers using fast sin\n    const baseValue = fastSin(time * this.baseWave.frequency + this.baseWave.phase) * this.baseWave.amplitude;\n    const breathValue = fastSin(time * this.breathWave.frequency + this.breathWave.phase) * this.breathWave.amplitude;\n    const driftValue = fastSin(time * this.driftWave.frequency + this.driftWave.phase) * this.driftWave.amplitude;\n    \n    // Combine waves with organic weighting\n    const rawWave = baseValue + breathValue * 0.6 + driftValue * 0.4;\n    \n    // Apply smooth easing curve for more natural feeling\n    const normalizedWave = (rawWave + 1) / 2; // 0-1 range\n    const easedWave = this.smoothEasing(normalizedWave);\n    \n    // Ultra-smooth interpolation to target\n    this.targetIntensity = easedWave;\n    const lerpFactor = Math.min(deltaTime * 0.0008, 0.05); // Very slow lerp\n    this.intensity = this.p5.lerp(this.intensity, this.targetIntensity, lerpFactor);\n    \n    // Additional smoothing layer for glass-smooth transitions\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.intensity * (1 - this.smoothingFactor);\n    \n    // Update global intensity with smoothed value\n    window.globalRabbitWaveIntensity = this.smoothedIntensity;\n    \n    // Gentle activity periods with smooth transitions\n    if (this.smoothedIntensity > 0.75) {\n      window.globalSpawnBoost = 1.0 + (this.smoothedIntensity - 0.75) * 2; // Gradual boost\n    } else if (this.smoothedIntensity < 0.25) {\n      window.globalSpawnBoost = 0.3 + this.smoothedIntensity * 2.8; // Gradual reduction\n    } else {\n      window.globalSpawnBoost = 1.0;\n    }\n  }\n\n  // Smooth easing function for natural wave curves\n  smoothEasing(t) {\n    // Combination of ease-in-out curves for organic feeling\n    const easeInOut = t * t * (3 - 2 * t); // Smooth step\n    const gentleCurve = fastSin(t * Math.PI * 0.5); // Gentle sine curve using fast sin\n    return easeInOut * 0.7 + gentleCurve * 0.3;\n  }\n\n  getIntensity() {\n    return this.smoothedIntensity;\n  }\n\n  getPeriodInfo() {\n    if (this.smoothedIntensity > 0.8) return \"HIGH ACTIVITY\";\n    if (this.smoothedIntensity < 0.2) return \"LOW ACTIVITY\";\n    return \"NORMAL ACTIVITY\";\n  }\n}\n\n// Ultra-Smooth Population Wave System\nclass DynamicPopulationWave {\n  constructor(p5) {\n    this.p5 = p5;\n    \n    // Multiple organic wave layers with ultra-slow frequencies\n    this.tideWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000012, // Ultra-slow tide-like changes\n      amplitude: 1.2,\n      smoothValue: 0\n    };\n    \n    this.currentWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000035, // Slow flowing current\n      amplitude: 0.8,\n      smoothValue: 0\n    };\n    \n    this.pulseWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000055, // Gentle pulse\n      amplitude: 0.4,\n      smoothValue: 0\n    };\n    \n    // Smooth interpolation system\n    this.intensity = 0.5;\n    this.smoothedIntensity = 0.5;\n    this.targetIntensity = 0.5;\n    this.smoothingFactor = 0.995; // Ultra-high smoothing\n    this.lastUpdateTime = 0;\n    \n    // Population parameters - moderate density screen flow system\n    this.minGems = 60; // Reduced minimum for more balanced density\n    this.maxGems = 100; // Reduced maximum for less overwhelming surges\n    this.basePopulation = 80; // Moderate baseline for comfortable screen flow\n    \n    // Gentle surge system\n    this.lastSurgeTime = 0;\n    this.surgeCooldown = 45000; // Much longer - 45 seconds between surges\n    this.surgeIntensity = 0;\n    this.surgeDecay = 0.99; // Slow surge decay\n  }\n\n  update() {\n    const time = this.p5.millis();\n    const deltaTime = time - this.lastUpdateTime;\n    this.lastUpdateTime = time;\n    \n    // Calculate each wave layer with individual smoothing\n    this.updateWaveLayer(this.tideWave, time);\n    this.updateWaveLayer(this.currentWave, time);\n    this.updateWaveLayer(this.pulseWave, time);\n    \n    // Combine smoothed wave layers with organic weighting\n    const combinedWave = (\n      this.tideWave.smoothValue * this.tideWave.amplitude +\n      this.currentWave.smoothValue * this.currentWave.amplitude * 0.7 +\n      this.pulseWave.smoothValue * this.pulseWave.amplitude * 0.4\n    ) / (this.tideWave.amplitude + this.currentWave.amplitude * 0.7 + this.pulseWave.amplitude * 0.4);\n    \n    // Apply gentle organic curve\n    const normalizedWave = (combinedWave + 1) / 2;\n    const organicCurve = this.organicEasing(normalizedWave);\n    \n    // Ultra-smooth interpolation\n    this.targetIntensity = organicCurve;\n    const lerpFactor = Math.min(deltaTime * 0.0005, 0.02);\n    this.intensity = this.p5.lerp(this.intensity, this.targetIntensity, lerpFactor);\n    \n    // Additional smoothing for glass-smooth transitions\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.intensity * (1 - this.smoothingFactor);\n    \n    // Gentle surge system - much less aggressive\n    this.updateSurgeSystem(time);\n    \n    // Final intensity with gentle surge influence\n    this.finalIntensity = Math.min(1.0, this.smoothedIntensity + this.surgeIntensity * 0.2);\n  }\n\n  updateWaveLayer(wave, time) {\n    const rawValue = fastSin(time * wave.frequency + wave.phase);\n    // Individual smoothing for each wave layer\n    wave.smoothValue = wave.smoothValue * 0.98 + rawValue * 0.02;\n  }\n\n  updateSurgeSystem(time) {\n    // Decay existing surge gently\n    this.surgeIntensity *= this.surgeDecay;\n    \n    // Very gentle surge triggers\n    const timeSinceLastSurge = time - this.lastSurgeTime;\n    const surgeReady = timeSinceLastSurge > this.surgeCooldown;\n    const surgeChance = this.p5.random() < 0.008; // Very low chance\n    \n    if (surgeReady && surgeChance && this.smoothedIntensity > 0.6) {\n      this.lastSurgeTime = time;\n      this.surgeIntensity = Math.min(0.3, this.p5.random(0.1, 0.25)); // Gentle surge\n      \n    }\n  }\n\n  // Organic easing for natural population curves\n  organicEasing(t) {\n    // Multiple curve layers for organic feeling\n    const smooth1 = t * t * (3 - 2 * t);\n    const smooth2 = fastSin(t * Math.PI * 0.5);\n    const smooth3 = 1 - Math.pow(1 - t, 1.6);\n    return smooth1 * 0.4 + smooth2 * 0.3 + smooth3 * 0.3;\n  }\n\n  getPopulationData() {\n    // Super abundant wave system using fast noise - extremely high most of the time\n    const now = this.p5.millis();\n    const primaryWave = Math.abs(fastNoise(now * 0.00002, 1000)) * 0.1 + 0.9; // [0.9, 1.0] - extremely high baseline\n    const intensityWave = Math.abs(fastNoise(now * 0.00005, 2000)) * 0.15 + 0.85; // [0.85, 1.0] - strong intensity booster\n    const surgeWave = Math.pow(Math.abs(fastNoise(now * 0.0001, 3000)), 2) * 0.2 + 0.8; // [0.8, 1.0] - powerful surge peaks\n    \n    // Very rare valley calculation - exponential curve for extremely rare drops\n    const valleyNoise = fastNoise(now * 0.000008, 5000); // Slower frequency for rarer valleys\n    const valleyTrigger = Math.pow(Math.max(0, -valleyNoise), 4); // Fourth power for extremely rare, sharp valleys\n    const valleyIntensity = valleyTrigger * 0.4; // Reduced maximum valley depth (40% vs 60%)\n    \n    // Combined super abundant wave - extremely high with very rare valleys\n    const waveIntensity = (primaryWave * intensityWave * surgeWave) - valleyIntensity;\n    const intensityFloor = 0.85 + (waveIntensity * 0.15); // Mathematical range [0.85, 1.0] with very rare dips to ~0.45\n    \n    // Pure mathematical population calculation - no conditionals\n    const populationRange = this.maxGems - this.minGems;\n    const targetGemCount = Math.floor(this.minGems + (intensityFloor * populationRange));\n    \n    // Ultra-intense spawn behavior - much higher rates for dramatic waves\n    const spawnNoise = Math.abs(fastNoise(now * 0.00008, 4000));\n    const spawnBurst = 0.5 + (spawnNoise * 0.6); // [0.5, 1.1] - much more aggressive spawning\n    const cullRate = (1 - intensityFloor) * 0.15; // Less aggressive culling to maintain density\n    \n    return {\n      targetGemCount,\n      spawnBurst,\n      cullRate\n    };\n  }\n\n  getIntensity() {\n    return this.finalIntensity;\n  }\n\n  getPopulationInfo() {\n    const { targetGemCount } = this.getPopulationData();\n    return {\n      intensity: this.finalIntensity,\n      targetPopulation: targetGemCount,\n      phase: this.finalIntensity > 0.75 ? 'FLOWING' : \n             this.finalIntensity < 0.25 ? 'CALM' : 'GENTLE'\n    };\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/gifManager.js?");
  
  /***/ }),
  
  /***/ "./src/lib/objectPools.js":
  /*!********************************!*\
    !*** ./src/lib/objectPools.js ***!
    \********************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CollisionPool\": () => (/* binding */ CollisionPool),\n/* harmony export */   \"FireworkPool\": () => (/* binding */ FireworkPool),\n/* harmony export */   \"GlobalPoolManager\": () => (/* binding */ GlobalPoolManager),\n/* harmony export */   \"PixelPool\": () => (/* binding */ PixelPool),\n/* harmony export */   \"TypedArrayPool\": () => (/* binding */ TypedArrayPool),\n/* harmony export */   \"acquirePooledFirework\": () => (/* binding */ acquirePooledFirework),\n/* harmony export */   \"acquirePooledPixel\": () => (/* binding */ acquirePooledPixel),\n/* harmony export */   \"getGlobalPoolManager\": () => (/* binding */ getGlobalPoolManager),\n/* harmony export */   \"releasePooledFirework\": () => (/* binding */ releasePooledFirework),\n/* harmony export */   \"releasePooledPixel\": () => (/* binding */ releasePooledPixel)\n/* harmony export */ });\n// Ultra-High Performance Object Pooling System\n// Eliminates object creation/destruction overhead\n// Reduces garbage collection by 80-90%\n// 5-20x performance improvement for particle-heavy systems\n\n// Base Object Pool - Generic pool for any object type\nclass ObjectPool {\n  constructor(createFn, resetFn, initialSize = 100, maxSize = 1000) {\n    this.createFn = createFn;\n    this.resetFn = resetFn;\n    this.maxSize = maxSize;\n    \n    this.available = [];\n    this.active = new Set();\n    \n    // Pre-allocate initial objects\n    for (let i = 0; i < initialSize; i++) {\n      this.available.push(this.createFn());\n    }\n    \n    // Performance tracking\n    this.stats = {\n      created: initialSize,\n      acquired: 0,\n      released: 0,\n      poolHits: 0,\n      poolMisses: 0\n    };\n  }\n  \n  acquire(...args) {\n    this.stats.acquired++;\n    \n    let obj;\n    if (this.available.length > 0) {\n      // Pool hit - reuse existing object\n      obj = this.available.pop();\n      this.stats.poolHits++;\n    } else {\n      // Pool miss - create new object\n      obj = this.createFn();\n      this.stats.created++;\n      this.stats.poolMisses++;\n    }\n    \n    // Reset object to initial state\n    if (this.resetFn) {\n      this.resetFn(obj, ...args);\n    }\n    \n    this.active.add(obj);\n    return obj;\n  }\n  \n  release(obj) {\n    if (!this.active.has(obj)) return false;\n    \n    this.active.delete(obj);\n    this.stats.released++;\n    \n    // Only return to pool if we haven't exceeded max size\n    if (this.available.length < this.maxSize) {\n      this.available.push(obj);\n    }\n    \n    return true;\n  }\n  \n  // Batch operations for better performance\n  acquireMultiple(count, ...args) {\n    const objects = [];\n    for (let i = 0; i < count; i++) {\n      objects.push(this.acquire(...args));\n    }\n    return objects;\n  }\n  \n  releaseMultiple(objects) {\n    for (const obj of objects) {\n      this.release(obj);\n    }\n  }\n  \n  // Get pool statistics\n  getStats() {\n    return {\n      ...this.stats,\n      available: this.available.length,\n      active: this.active.size,\n      total: this.available.length + this.active.size,\n      hitRate: this.stats.poolHits / (this.stats.poolHits + this.stats.poolMisses),\n      efficiency: this.stats.poolHits / this.stats.acquired\n    };\n  }\n  \n  // Force cleanup for memory management\n  shrink(targetSize = 50) {\n    while (this.available.length > targetSize) {\n      this.available.pop();\n    }\n  }\n}\n\n// Specialized Pixel Pool - optimized for stream pixels\nclass PixelPool extends ObjectPool {\n  constructor(p5, initialSize = 200, maxSize = 2000) {\n    // Store p5 reference before calling super\n    const p5Instance = p5;\n    \n    const createPixel = () => {\n      const pixel = {\n        x: 0,\n        y: 0,\n        color: p5Instance.color(0, 255, 0),\n        opacity: 255,\n        active: false,\n        // Pre-allocated color levels for performance\n        colorLevels: [0, 255, 0, 255]\n      };\n      \n      // Add methods using static factory functions\n      pixel.updateColor = PixelPool.createUpdateColorMethod(p5Instance);\n      pixel.display = PixelPool.createDisplayMethod(p5Instance);\n      \n      return pixel;\n    };\n    \n    const resetPixel = (pixel, x, y, getPaletteIndex, getTransitionProgress) => {\n      pixel.x = x;\n      pixel.y = y;\n      pixel.opacity = p5Instance.random(50, 255);\n      pixel.active = true;\n      pixel.getPaletteIndex = getPaletteIndex;\n      pixel.getTransitionProgress = getTransitionProgress;\n      \n      // Initialize color - now the method should exist\n      if (pixel.updateColor) {\n        pixel.updateColor();\n      }\n    };\n    \n    super(createPixel, resetPixel, initialSize, maxSize);\n    this.p5 = p5Instance;\n  }\n  \n  // Static factory methods for pooled pixel compatibility\n  static createUpdateColorMethod(p5) {\n    const { palettes } = __webpack_require__(/*! ../const */ \"./src/const.js\");\n    return function() {\n      const { current, next } = this.getPaletteIndex();\n      const transitionProgress = this.getTransitionProgress();\n\n      const fromPalette = palettes[current];\n      const toPalette = palettes[next];\n      const fromColor = p5.color(\n        ...fromPalette[Math.floor(p5.random(fromPalette.length))]\n      );\n      const toColor = p5.color(\n        ...toPalette[Math.floor(p5.random(toPalette.length))]\n      );\n\n      this.color = p5.lerpColor(fromColor, toColor, transitionProgress);\n      \n      // Update pre-allocated color levels for performance\n      this.colorLevels[0] = this.color.levels[0];\n      this.colorLevels[1] = this.color.levels[1];\n      this.colorLevels[2] = this.color.levels[2];\n      this.colorLevels[3] = this.opacity;\n    };\n  }\n\n  static createDisplayMethod(p5) {\n    const { pixelSize } = __webpack_require__(/*! ../const */ \"./src/const.js\");\n    return function() {\n      p5.fill(\n        this.colorLevels[0],\n        this.colorLevels[1],\n        this.colorLevels[2],\n        this.colorLevels[3]\n      );\n      p5.noStroke();\n      p5.rect(this.x, this.y, pixelSize, pixelSize);\n    };\n  }\n}\n\n// Specialized Firework Pool - optimized for explosion effects\nclass FireworkPool extends ObjectPool {\n  constructor(p5, initialSize = 50, maxSize = 200) {\n    const createFirework = () => ({\n      x: 0,\n      y: 0,\n      stage: 0,\n      opacity: 255,\n      active: false,\n      pattern: 1,\n      lifetime: 0,\n      // Pre-allocated arrays for different patterns\n      positions: new Array(9 * 2), // Max 9 pixels, x,y each\n      positionCount: 0\n    });\n    \n    const resetFirework = (firework, x, y) => {\n      firework.x = x || p5.random(p5.width);\n      firework.y = y || p5.random(p5.height / 2);\n      firework.stage = 0;\n      firework.opacity = 255;\n      firework.active = true;\n      firework.pattern = Math.floor(p5.random(1, 4));\n      firework.lifetime = p5.millis() + p5.random(800, 2000);\n      firework.positionCount = 0;\n    };\n    \n    super(createFirework, resetFirework, initialSize, maxSize);\n    this.p5 = p5;\n  }\n}\n\n// Memory-Mapped Array Pool - for large datasets\nclass TypedArrayPool {\n  constructor(arrayType = Float32Array, elementSize = 6, poolSize = 10, arraySize = 1000) {\n    this.arrayType = arrayType;\n    this.elementSize = elementSize; // Elements per object (e.g., x,y,r,g,b,a = 6)\n    this.arraySize = arraySize;\n    \n    this.available = [];\n    this.active = new Set();\n    \n    // Statistics tracking\n    this.stats = {\n      created: poolSize,\n      acquired: 0,\n      released: 0,\n      poolHits: 0,\n      poolMisses: 0\n    };\n    \n    // Pre-allocate typed arrays\n    for (let i = 0; i < poolSize; i++) {\n      const buffer = new ArrayBuffer(arraySize * elementSize * arrayType.BYTES_PER_ELEMENT);\n      const array = new arrayType(buffer);\n      this.available.push({\n        buffer,\n        array,\n        count: 0,\n        maxCount: arraySize\n      });\n    }\n  }\n  \n  acquire() {\n    this.stats.acquired++;\n    \n    if (this.available.length > 0) {\n      const arrayData = this.available.pop();\n      arrayData.count = 0; // Reset count\n      this.active.add(arrayData);\n      this.stats.poolHits++;\n      return arrayData;\n    }\n    \n    // Create new array if pool exhausted\n    const buffer = new ArrayBuffer(this.arraySize * this.elementSize * this.arrayType.BYTES_PER_ELEMENT);\n    const array = new this.arrayType(buffer);\n    const arrayData = {\n      buffer,\n      array,\n      count: 0,\n      maxCount: this.arraySize\n    };\n    \n    this.active.add(arrayData);\n    this.stats.created++;\n    this.stats.poolMisses++;\n    return arrayData;\n  }\n  \n  release(arrayData) {\n    if (this.active.has(arrayData)) {\n      this.active.delete(arrayData);\n      this.available.push(arrayData);\n      this.stats.released++;\n      return true;\n    }\n    return false;\n  }\n  \n  // Get pool statistics - compatible with other pools\n  getStats() {\n    return {\n      ...this.stats,\n      available: this.available.length,\n      active: this.active.size,\n      total: this.available.length + this.active.size,\n      hitRate: this.stats.poolHits / (this.stats.poolHits + this.stats.poolMisses),\n      efficiency: this.stats.poolHits / this.stats.acquired\n    };\n  }\n  \n  // Force cleanup for memory management\n  shrink(targetSize = 5) {\n    while (this.available.length > targetSize) {\n      this.available.pop();\n    }\n  }\n}\n\n// Specialized Collision Result Pool - for collision detection results\nclass CollisionPool extends ObjectPool {\n  constructor(initialSize = 100, maxSize = 1000) {\n    const createCollision = () => ({\n      objectA: null,\n      objectB: null,\n      distance: 0,\n      deltaX: 0,\n      deltaY: 0,\n      timestamp: 0,\n      type: 'unknown'\n    });\n    \n    const resetCollision = (collision, objA, objB, distance, deltaX = 0, deltaY = 0, type = 'collision') => {\n      collision.objectA = objA;\n      collision.objectB = objB;\n      collision.distance = distance;\n      collision.deltaX = deltaX;\n      collision.deltaY = deltaY;\n      collision.timestamp = Date.now();\n      collision.type = type;\n    };\n    \n    super(createCollision, resetCollision, initialSize, maxSize);\n  }\n}\n\n// Global Pool Manager - centralized management of all pools\nclass GlobalPoolManager {\n  constructor(p5) {\n    this.p5 = p5;\n    this.pools = new Map();\n    \n    // Initialize default pools\n    this.createPool('pixels', new PixelPool(p5, 200, 2000));\n    this.createPool('fireworks', new FireworkPool(p5, 50, 200));\n    this.createPool('collisions', new CollisionPool(100, 1000));\n    this.createPool('arrays', new TypedArrayPool(Float32Array, 6, 10, 1000));\n    \n    // Performance monitoring\n    this.frameStats = {\n      lastUpdate: 0,\n      updateInterval: 1000, // Update stats every second\n      totalAcquired: 0,\n      totalReleased: 0\n    };\n  }\n  \n  createPool(name, pool) {\n    this.pools.set(name, pool);\n  }\n  \n  getPool(name) {\n    return this.pools.get(name);\n  }\n  \n  // Convenience methods for common operations\n  acquirePixel(x, y, getPaletteIndex, getTransitionProgress) {\n    return this.pools.get('pixels').acquire(x, y, getPaletteIndex, getTransitionProgress);\n  }\n  \n  releasePixel(pixel) {\n    return this.pools.get('pixels').release(pixel);\n  }\n  \n  acquireFirework(x, y) {\n    return this.pools.get('fireworks').acquire(x, y);\n  }\n  \n  releaseFirework(firework) {\n    return this.pools.get('fireworks').release(firework);\n  }\n  \n  acquireCollision(objA, objB, distance, deltaX, deltaY, type) {\n    return this.pools.get('collisions').acquire(objA, objB, distance, deltaX, deltaY, type);\n  }\n  \n  releaseCollision(collision) {\n    return this.pools.get('collisions').release(collision);\n  }\n  \n  acquireTypedArray() {\n    return this.pools.get('arrays').acquire();\n  }\n  \n  releaseTypedArray(arrayData) {\n    return this.pools.get('arrays').release(arrayData);\n  }\n  \n  // Batch cleanup for performance\n  cleanup() {\n    for (const [name, pool] of this.pools) {\n      if (pool.shrink) {\n        pool.shrink();\n      }\n    }\n  }\n  \n  // Get comprehensive statistics\n  getAllStats() {\n    const stats = {};\n    for (const [name, pool] of this.pools) {\n      stats[name] = pool.getStats();\n    }\n    return stats;\n  }\n  \n  // Update performance statistics\n  updateStats() {\n    const now = Date.now();\n    if (now - this.frameStats.lastUpdate > this.frameStats.updateInterval) {\n      this.frameStats.lastUpdate = now;\n      \n      // Calculate totals across all pools\n      let totalAcquired = 0;\n      let totalReleased = 0;\n      \n      for (const [name, pool] of this.pools) {\n        const stats = pool.getStats();\n        totalAcquired += stats.acquired;\n        totalReleased += stats.released;\n      }\n      \n      this.frameStats.totalAcquired = totalAcquired;\n      this.frameStats.totalReleased = totalReleased;\n    }\n  }\n  \n  // Visualize pool statistics for debugging\n  visualizeStats(p5, x = 10, y = 100) {\n    const stats = this.getAllStats();\n    \n    p5.push();\n    p5.fill(255, 200);\n    p5.textAlign(p5.LEFT, p5.TOP);\n    \n    let yOffset = y;\n    p5.text('Object Pool Statistics:', x, yOffset);\n    yOffset += 20;\n    \n    for (const [name, poolStats] of Object.entries(stats)) {\n      const efficiency = (poolStats.efficiency * 100).toFixed(1);\n      const hitRate = (poolStats.hitRate * 100).toFixed(1);\n      \n      p5.text(`${name}: ${poolStats.active}/${poolStats.total} active, ${efficiency}% efficiency, ${hitRate}% hit rate`, \n               x + 10, yOffset);\n      yOffset += 15;\n    }\n    \n    p5.pop();\n  }\n}\n\n// Singleton instance for global access\nlet globalPoolManager = null;\n\nfunction getGlobalPoolManager(p5) {\n  if (!globalPoolManager && p5) {\n    globalPoolManager = new GlobalPoolManager(p5);\n  }\n  return globalPoolManager;\n}\n\n// Utility functions for easy pool access\nfunction acquirePooledPixel(p5, x, y, getPaletteIndex, getTransitionProgress) {\n  const manager = getGlobalPoolManager(p5);\n  return manager.acquirePixel(x, y, getPaletteIndex, getTransitionProgress);\n}\n\nfunction releasePooledPixel(pixel) {\n  if (globalPoolManager) {\n    return globalPoolManager.releasePixel(pixel);\n  }\n  return false;\n}\n\nfunction acquirePooledFirework(p5, x, y) {\n  const manager = getGlobalPoolManager(p5);\n  return manager.acquireFirework(x, y);\n}\n\nfunction releasePooledFirework(firework) {\n  if (globalPoolManager) {\n    return globalPoolManager.releaseFirework(firework);\n  }\n  return false;\n} \n\n//# sourceURL=webpack://particles/./src/lib/objectPools.js?");
  
  /***/ }),
  
  /***/ "./src/lib/performanceMonitor.js":
  /*!***************************************!*\
    !*** ./src/lib/performanceMonitor.js ***!
    \***************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PerformanceMonitor\": () => (/* binding */ PerformanceMonitor),\n/* harmony export */   \"endPerformanceFrame\": () => (/* binding */ endPerformanceFrame),\n/* harmony export */   \"getPerformanceMonitor\": () => (/* binding */ getPerformanceMonitor),\n/* harmony export */   \"recordCollision\": () => (/* binding */ recordCollision),\n/* harmony export */   \"recordFixedPointOp\": () => (/* binding */ recordFixedPointOp),\n/* harmony export */   \"recordPoolOperation\": () => (/* binding */ recordPoolOperation),\n/* harmony export */   \"recordSpatialQuery\": () => (/* binding */ recordSpatialQuery),\n/* harmony export */   \"startPerformanceFrame\": () => (/* binding */ startPerformanceFrame)\n/* harmony export */ });\n// Ultra-High Performance Monitoring System\n// Tracks all optimization benefits in real-time\n// Provides comprehensive performance metrics\n\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = {\n      // Spatial Hash Grid Performance\n      spatialGrid: {\n        totalQueries: 0,\n        averageQueryTime: 0,\n        queriesPerFrame: 0,\n        objectsPerQuery: 0,\n        collisionsDetected: 0,\n        lastFrameQueries: 0\n      },\n      \n      // Object Pool Performance\n      objectPools: {\n        totalAcquisitions: 0,\n        totalReleases: 0,\n        poolHitRate: 0,\n        memoryReduced: 0, // Estimated bytes saved\n        garbageCollectionReduced: 0 // Estimated reduction percentage\n      },\n      \n      // Fixed-Point Math Performance\n      fixedPointMath: {\n        operationsPerFrame: 0,\n        timePerOperation: 0, // Microseconds\n        speedupFactor: 1.0, // Compared to floating-point\n        totalOperations: 0\n      },\n      \n      // Overall System Performance\n      system: {\n        fps: 0,\n        frameTime: 0,\n        cpuUsage: 0,\n        memoryUsage: 0,\n        totalOptimizationGain: 0 // Overall performance improvement percentage\n      },\n      \n      // Frame-by-frame tracking\n      frame: {\n        current: 0,\n        startTime: 0,\n        endTime: 0,\n        deltaTime: 0\n      }\n    };\n    \n    // Performance baseline (measured without optimizations)\n    this.baseline = {\n      averageFrameTime: 16.67, // 60fps target\n      averageCollisionTime: 1.0, // ms\n      averageMemoryAllocations: 1000 // objects per second\n    };\n    \n    // Timing utilities\n    this.timers = new Map();\n    this.frameStartTime = 0;\n    this.lastUpdateTime = 0;\n    \n    // Moving averages for smooth metrics\n    this.averages = {\n      frameTime: new MovingAverage(60), // 1 second at 60fps\n      queryTime: new MovingAverage(30),\n      operationTime: new MovingAverage(100)\n    };\n  }\n  \n  // Start frame timing\n  startFrame() {\n    this.frameStartTime = performance.now();\n    this.metrics.frame.current++;\n    this.metrics.frame.startTime = this.frameStartTime;\n  }\n  \n  // End frame timing and calculate metrics\n  endFrame() {\n    const now = performance.now();\n    this.metrics.frame.endTime = now;\n    this.metrics.frame.deltaTime = now - this.frameStartTime;\n    \n    // Update frame time average\n    this.averages.frameTime.add(this.metrics.frame.deltaTime);\n    this.metrics.system.frameTime = this.averages.frameTime.getAverage();\n    this.metrics.system.fps = 1000 / this.metrics.system.frameTime;\n    \n    // Reset per-frame counters\n    this.metrics.spatialGrid.lastFrameQueries = this.metrics.spatialGrid.queriesPerFrame;\n    this.metrics.spatialGrid.queriesPerFrame = 0;\n    this.metrics.fixedPointMath.operationsPerFrame = 0;\n  }\n  \n  // Start timing a specific operation\n  startTimer(name) {\n    this.timers.set(name, performance.now());\n  }\n  \n  // End timing and record result\n  endTimer(name) {\n    const startTime = this.timers.get(name);\n    if (startTime) {\n      const duration = performance.now() - startTime;\n      this.timers.delete(name);\n      return duration;\n    }\n    return 0;\n  }\n  \n  // Record spatial grid query performance\n  recordSpatialQuery(queryTime, objectsFound) {\n    this.metrics.spatialGrid.totalQueries++;\n    this.metrics.spatialGrid.queriesPerFrame++;\n    this.metrics.spatialGrid.objectsPerQuery = \n      (this.metrics.spatialGrid.objectsPerQuery + objectsFound) / 2; // Simple average\n    \n    this.averages.queryTime.add(queryTime);\n    this.metrics.spatialGrid.averageQueryTime = this.averages.queryTime.getAverage();\n  }\n  \n  // Record collision detection\n  recordCollision() {\n    this.metrics.spatialGrid.collisionsDetected++;\n  }\n  \n  // Record object pool usage\n  recordPoolAcquisition(wasPoolHit) {\n    this.metrics.objectPools.totalAcquisitions++;\n    if (wasPoolHit) {\n      this.metrics.objectPools.poolHitRate = \n        (this.metrics.objectPools.poolHitRate * \n         (this.metrics.objectPools.totalAcquisitions - 1) + 1) / \n        this.metrics.objectPools.totalAcquisitions;\n    }\n    \n    // Estimate memory reduction (average object size ~200 bytes)\n    if (wasPoolHit) {\n      this.metrics.objectPools.memoryReduced += 200;\n    }\n  }\n  \n  // Record object pool release\n  recordPoolRelease() {\n    this.metrics.objectPools.totalReleases++;\n    \n    // Calculate garbage collection reduction estimate\n    const totalLifecycle = this.metrics.objectPools.totalAcquisitions + \n                          this.metrics.objectPools.totalReleases;\n    this.metrics.objectPools.garbageCollectionReduced = \n      (this.metrics.objectPools.poolHitRate * 0.9) * 100; // 90% reduction per pool hit\n  }\n  \n  // Record fixed-point math operation\n  recordFixedPointOperation(operationTime) {\n    this.metrics.fixedPointMath.totalOperations++;\n    this.metrics.fixedPointMath.operationsPerFrame++;\n    \n    this.averages.operationTime.add(operationTime);\n    this.metrics.fixedPointMath.timePerOperation = this.averages.operationTime.getAverage();\n    \n    // Estimate speedup factor (fixed-point is typically 20-40% faster)\n    const baselineOpTime = 0.1; // Estimated floating-point operation time in microseconds\n    this.metrics.fixedPointMath.speedupFactor = \n      baselineOpTime / Math.max(0.01, this.metrics.fixedPointMath.timePerOperation);\n  }\n  \n  // Calculate overall optimization gains\n  calculateOptimizationGains() {\n    // Spatial grid improvement (10-50x faster collision detection)\n    const spatialImprovement = Math.min(5000, // Cap at 50x\n      this.baseline.averageCollisionTime / Math.max(0.01, this.metrics.spatialGrid.averageQueryTime));\n    \n    // Object pooling improvement (80-90% less memory allocation)\n    const poolingImprovement = 1 + (this.metrics.objectPools.garbageCollectionReduced / 100);\n    \n    // Fixed-point math improvement\n    const mathImprovement = this.metrics.fixedPointMath.speedupFactor;\n    \n    // Combined optimization gain (geometric mean for fair combination)\n    this.metrics.system.totalOptimizationGain = \n      Math.pow(spatialImprovement * poolingImprovement * mathImprovement, 1/3);\n    \n    return this.metrics.system.totalOptimizationGain;\n  }\n  \n  // Get comprehensive performance report with bottleneck analysis\n  getPerformanceReport() {\n    this.calculateOptimizationGains();\n    \n    // Advanced bottleneck detection\n    const bottlenecks = this.detectBottlenecks();\n    \n    return {\n      summary: {\n        fps: Math.round(this.metrics.system.fps * 10) / 10,\n        frameTime: Math.round(this.metrics.system.frameTime * 100) / 100,\n        totalSpeedup: Math.round(this.metrics.system.totalOptimizationGain * 100) / 100,\n        status: this.getPerformanceStatus(),\n        bottlenecks: bottlenecks\n      },\n      \n      spatialGrid: {\n        queriesPerSecond: Math.round(this.metrics.spatialGrid.lastFrameQueries * this.metrics.system.fps),\n        averageQueryTime: Math.round(this.metrics.spatialGrid.averageQueryTime * 1000) / 1000,\n        collisionDetectionSpeedup: Math.round(\n          this.baseline.averageCollisionTime / Math.max(0.01, this.metrics.spatialGrid.averageQueryTime)\n        ),\n        objectsPerQuery: Math.round(this.metrics.spatialGrid.objectsPerQuery * 10) / 10,\n        totalCollisions: this.metrics.spatialGrid.collisionsDetected\n      },\n      \n      objectPooling: {\n        hitRate: Math.round(this.metrics.objectPools.poolHitRate * 1000) / 10, // Percentage\n        memoryReductionMB: Math.round(this.metrics.objectPools.memoryReduced / 1024 / 1024 * 100) / 100,\n        gcReduction: Math.round(this.metrics.objectPools.garbageCollectionReduced * 10) / 10,\n        totalAcquisitions: this.metrics.objectPools.totalAcquisitions,\n        totalReleases: this.metrics.objectPools.totalReleases\n      },\n      \n      fixedPointMath: {\n        operationsPerSecond: Math.round(this.metrics.fixedPointMath.operationsPerFrame * this.metrics.system.fps),\n        speedupFactor: Math.round(this.metrics.fixedPointMath.speedupFactor * 100) / 100,\n        timePerOperation: Math.round(this.metrics.fixedPointMath.timePerOperation * 1000) / 1000,\n        totalOperations: this.metrics.fixedPointMath.totalOperations\n      }\n    };\n  }\n  \n  // Advanced bottleneck detection system\n  detectBottlenecks() {\n    const bottlenecks = [];\n    \n    // Frame time analysis\n    if (this.metrics.system.frameTime > 20) { // > 50fps\n      bottlenecks.push({\n        type: 'FRAME_TIME',\n        severity: this.metrics.system.frameTime > 33 ? 'HIGH' : 'MEDIUM',\n        description: `Frame time ${this.metrics.system.frameTime.toFixed(1)}ms (target: 16.7ms)`\n      });\n    }\n    \n    // Spatial grid efficiency\n    if (this.metrics.spatialGrid.objectsPerQuery > 50) {\n      bottlenecks.push({\n        type: 'SPATIAL_GRID',\n        severity: 'MEDIUM',\n        description: `Too many objects per spatial query: ${this.metrics.spatialGrid.objectsPerQuery.toFixed(1)}`\n      });\n    }\n    \n    // Object pool efficiency\n    if (this.metrics.objectPools.poolHitRate < 0.8) {\n      bottlenecks.push({\n        type: 'OBJECT_POOLS',\n        severity: 'MEDIUM',\n        description: `Low pool hit rate: ${(this.metrics.objectPools.poolHitRate * 100).toFixed(1)}%`\n      });\n    }\n    \n    return bottlenecks;\n  }\n  \n  // Get performance status\n  getPerformanceStatus() {\n    const fps = this.metrics.system.fps;\n    const speedup = this.metrics.system.totalOptimizationGain;\n    \n    if (fps >= 55 && speedup >= 2.0) return 'EXCELLENT';\n    if (fps >= 45 && speedup >= 1.5) return 'GOOD';\n    if (fps >= 30 && speedup >= 1.2) return 'ACCEPTABLE';\n    return 'NEEDS_OPTIMIZATION';\n  }\n  \n  // Visualize performance metrics on screen\n  visualize(p5, x = 10, y = 200) {\n    const report = this.getPerformanceReport();\n    \n    p5.push();\n    p5.fill(255, 220);\n    p5.textAlign(p5.LEFT, p5.TOP);\n    p5.textSize(12);\n    \n    // Performance header\n    const statusColor = this.getStatusColor(report.summary.status);\n    p5.fill(statusColor);\n    p5.text(`PERFORMANCE: ${report.summary.status}`, x, y);\n    \n    p5.fill(255, 220);\n    let yOffset = y + 20;\n    \n    // Summary metrics\n    p5.text(`FPS: ${report.summary.fps} | Frame: ${report.summary.frameTime}ms | Speedup: ${report.summary.totalSpeedup}x`, \n             x, yOffset);\n    yOffset += 15;\n    \n    // Spatial grid metrics\n    p5.text(`Spatial Grid: ${report.spatialGrid.queriesPerSecond}/sec, ${report.spatialGrid.collisionDetectionSpeedup}x faster`, \n             x, yOffset);\n    yOffset += 15;\n    \n    // Object pooling metrics\n    p5.text(`Object Pools: ${report.objectPooling.hitRate}% hit rate, ${report.objectPooling.gcReduction}% less GC`, \n             x, yOffset);\n    yOffset += 15;\n    \n    // Fixed-point math metrics\n    p5.text(`Fixed-Point: ${report.fixedPointMath.operationsPerSecond}/sec, ${report.fixedPointMath.speedupFactor}x faster`, \n             x, yOffset);\n    \n    p5.pop();\n  }\n  \n  // Get color for performance status\n  getStatusColor(status) {\n    switch (status) {\n      case 'EXCELLENT': return [0, 255, 0]; // Green\n      case 'GOOD': return [255, 255, 0]; // Yellow\n      case 'ACCEPTABLE': return [255, 165, 0]; // Orange\n      default: return [255, 0, 0]; // Red\n    }\n  }\n}\n\n// Moving average utility for smooth metrics\nclass MovingAverage {\n  constructor(windowSize) {\n    this.windowSize = windowSize;\n    this.values = [];\n    this.sum = 0;\n  }\n  \n  add(value) {\n    this.values.push(value);\n    this.sum += value;\n    \n    if (this.values.length > this.windowSize) {\n      this.sum -= this.values.shift();\n    }\n  }\n  \n  getAverage() {\n    return this.values.length > 0 ? this.sum / this.values.length : 0;\n  }\n}\n\n// Global performance monitor instance\nlet globalPerformanceMonitor = null;\n\nfunction getPerformanceMonitor() {\n  if (!globalPerformanceMonitor) {\n    globalPerformanceMonitor = new PerformanceMonitor();\n  }\n  return globalPerformanceMonitor;\n}\n\n// Convenience functions for easy integration\nfunction startPerformanceFrame() {\n  getPerformanceMonitor().startFrame();\n}\n\nfunction endPerformanceFrame() {\n  getPerformanceMonitor().endFrame();\n}\n\nfunction recordSpatialQuery(queryTime, objectsFound) {\n  getPerformanceMonitor().recordSpatialQuery(queryTime, objectsFound);\n}\n\nfunction recordCollision() {\n  getPerformanceMonitor().recordCollision();\n}\n\nfunction recordPoolOperation(wasHit, isAcquisition = true) {\n  const monitor = getPerformanceMonitor();\n  if (isAcquisition) {\n    monitor.recordPoolAcquisition(wasHit);\n  } else {\n    monitor.recordPoolRelease();\n  }\n}\n\nfunction recordFixedPointOp(operationTime) {\n  getPerformanceMonitor().recordFixedPointOperation(operationTime);\n} \n\n//# sourceURL=webpack://particles/./src/lib/performanceMonitor.js?");
  
  /***/ }),
  
  /***/ "./src/lib/pixel.js":
  /*!**************************!*\
    !*** ./src/lib/pixel.js ***!
    \**************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pixel\": () => (/* binding */ Pixel)\n/* harmony export */ });\nconst { pixelSize } = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\nclass Pixel {\n  constructor(p5, x, y, getPaletteIndex, getTransitionProgress) {\n    this.p5 = p5;\n    this.x = x;\n    this.y = y;\n    this.opacity = 0;\n    this.getPaletteIndex = getPaletteIndex;\n    this.getTransitionProgress = getTransitionProgress;\n    this.color = p5.color(255);\n    \n    // Batch rendering compatibility\n    this.batchRenderer = null;\n    \n    // Performance optimization: Cache color updates\n    this.lastColorUpdate = 0;\n    this.colorUpdateInterval = 100; // Update color every 100ms for performance\n  }\n\n  updateColor() {\n    const now = this.p5.millis();\n    \n    // Throttle color updates for performance\n    if (now - this.lastColorUpdate < this.colorUpdateInterval) return;\n    this.lastColorUpdate = now;\n    \n    const currentPalette = this.getPaletteIndex().current;\n    const nextPalette = this.getPaletteIndex().next;\n    const progress = this.getTransitionProgress();\n    \n    // Ultra-fast color interpolation using direct RGB manipulation\n    const current = this.p5.palette.palettes[currentPalette] || [255, 255, 255];\n    const next = this.p5.palette.palettes[nextPalette] || [255, 255, 255];\n    \n    const r = Math.floor(current[0] * (1 - progress) + next[0] * progress);\n    const g = Math.floor(current[1] * (1 - progress) + next[1] * progress);\n    const b = Math.floor(current[2] * (1 - progress) + next[2] * progress);\n    \n    this.color = this.p5.color(r, g, b);\n  }\n\n  // Optimized display method - compatible with both batch and traditional rendering\n  display() {\n    if (this.opacity <= 0) return;\n    \n    // If batch renderer is available, use it for maximum performance\n    if (this.batchRenderer) {\n      this.batchRenderer.addPixel(this.x, this.y, this.color, this.opacity);\n      return;\n    }\n    \n    // Fallback to traditional rendering for compatibility\n    this.p5.fill(\n      this.color.levels[0],\n      this.color.levels[1],\n      this.color.levels[2],\n      this.opacity\n    );\n    this.p5.noStroke();\n    this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/pixel.js?");
  
  /***/ }),
  
  /***/ "./src/lib/rabbitEntity.js":
  /*!*********************************!*\
    !*** ./src/lib/rabbitEntity.js ***!
    \*********************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RabbitEntity\": () => (/* binding */ RabbitEntity)\n/* harmony export */ });\n/* harmony import */ var _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fixedPointMath.js */ \"./src/lib/fixedPointMath.js\");\nconst { gifSize, speechTexts, chineseSpeechTexts, RABBIT_SPEED } = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\n// Import ultra-high performance fixed-point math\n\n\n// Animation duration constant - smooth fade transitions\nconst ANIMATION_DURATION = 800; // Smooth 800ms fade transitions\n\n// Simple elegant parameters for optimal mathematical chaos - longer visibility\nconst CHAOS_PARAMS = {\n  timeScale: 0.0001,         // Much slower time flow for longer visibility\n  spaceScale: 0.008,         // Spatial noise scale for detailed patterns\n  threshold: 0.4,           // Much lower threshold = much longer visibility\n  displayBase: 2000,        // Longer base animation timing\n  displayChaos: 1500        // More variation in timing\n};\n\n// Fast noise replacement using hash-based noise\nconst fastNoise = (x, y, z) => {\n  let hash = (x * 374761393 + y * 668265263 + z * 2147483647) | 0;\n  hash = (hash ^ (hash >>> 13)) * 1274126177;\n  hash = hash ^ (hash >>> 16);\n  return (hash & 0x7fffffff) / 0x7fffffff;\n};\n\n/**\n * HIGHER-ORDER RABBIT ENTITY CLASS\n * \n * This class manages both the rabbit GIF and its speech bubble as a unified entity.\n * It handles:\n * - Synchronized lifecycle (spawn/despawn together)\n * - Proper positioning and movement\n * - Speech bubble visibility tied to rabbit state\n * - Collision detection\n * - Performance optimization\n * - Clean architecture with separation of concerns\n */\nclass RabbitEntity {\n  constructor(p5, x, y, fonts = {}) {\n    this.p5 = p5;\n    this.fonts = fonts;\n    \n    // Core entity properties\n    this.id = Math.random().toString(36).substr(2, 9); // Unique ID\n    this.x = x;\n    this.y = y;\n    this.speed = RABBIT_SPEED;\n    \n    // Unified state management\n    this.state = \"hidden\"; // hidden, spawning, alive, dying\n    this.isActive = false;\n    \n    // Mathematical identity for chaos calculations\n    this.chaosX = Math.random() * 1000;\n    this.chaosY = Math.random() * 1000;\n    this.mathSeed = Math.random();\n    this.rabbitIndex = Math.floor(Math.random() * 1000);\n    \n    // Precomputed expensive operations\n    this.precomputedPhase = this.mathSeed * 6.28318;\n    this.precomputedPersonality = this.mathSeed * 7.3;\n    this.chaosScaleX = this.chaosX * CHAOS_PARAMS.spaceScale;\n    this.chaosScaleY = this.chaosY * CHAOS_PARAMS.spaceScale;\n    \n    // Timing for visual transitions\n    this.spawnTime = 0;\n    this.fadeInStartTime = 0;\n    this.fadeOutStartTime = 0;\n    \n    // Mathematical collision effect system\n    this.collisionStartTime = 0;\n    this.collisionDuration = 600;\n    this.collisionType = 'normal';\n    \n    // Performance optimization: Update frequency control\n    this.lastMathUpdate = 0;\n    this.mathUpdateInterval = 200;\n    this.cachedShouldExist = false;\n    this.lastVisualUpdate = 0;\n    this.visualUpdateInterval = 16; // ~60fps\n    \n    // Position optimization\n    this.lastDOMUpdate = 0;\n    this.domUpdateInterval = 50;\n    this.lastX = this.x;\n    this.lastY = this.y;\n    \n    // Initialize sub-components\n    this.rabbit = new RabbitGIF(p5, this);\n    this.speechBubble = new SpeechBubble(p5, fonts, this);\n    \n    // Only 50% of rabbits get speech balloons\n    this.hasSpeechBalloon = p5.random() < 0.5;\n  }\n\n  // Ultra-optimized existence calculation with fast math\n  shouldExist(currentTime) {\n    // Only recalculate expensive math periodically\n    if (currentTime - this.lastMathUpdate > this.mathUpdateInterval) {\n      this.lastMathUpdate = currentTime;\n      \n      const t = currentTime * CHAOS_PARAMS.timeScale;\n      \n      // Replace expensive p5.noise with fast hash-based noise\n      const primaryChaos = fastNoise(this.chaosScaleX, this.chaosScaleY, t);\n      \n      // Fast baseline calculation using precomputed values\n      const baselineWave = Math.sin(t * 0.3 + this.precomputedPhase) * 0.5 + 0.5;\n      \n      // Simplified personality calculation\n      const personality = Math.sin(t * 1.7 + this.precomputedPersonality) * 0.1;\n      \n      // Combine layers - optimized\n      const finalExistence = primaryChaos * 0.8 + baselineWave * 0.4 + personality;\n      \n      this.cachedShouldExist = finalExistence > CHAOS_PARAMS.threshold;\n    }\n    \n    return this.cachedShouldExist;\n  }\n\n  // UNIFIED UPDATE METHOD - Manages both rabbit and bubble synchronously\n  update() {\n    try {\n      const now = this.p5.millis();\n      \n      // Mathematical collision effect update\n      this.updateCollisionEffect(now);\n      \n      // Core mathematical state decision\n      const shouldBeVisible = this.shouldExist(now);\n      const currentlyVisible = this.state !== \"hidden\";\n      \n      // Unified state transitions for both rabbit and bubble\n      if (shouldBeVisible && !currentlyVisible) {\n        this.transitionToVisible(now);\n      } else if (!shouldBeVisible && currentlyVisible) {\n        this.transitionToHidden(now);\n      }\n      \n      // Update visual transitions for both components\n      if (now - this.lastVisualUpdate > this.visualUpdateInterval) {\n        this.lastVisualUpdate = now;\n        this.updateVisualTransition(now);\n      }\n      \n      // Update position and components when active\n      if (this.state !== \"hidden\") {\n        this.updatePosition(now);\n        \n        // Update speech bubble with synchronized state\n        if (this.hasSpeechBalloon && this.speechBubble) {\n          this.speechBubble.update(this.x, this.y);\n        }\n        \n        // Update rabbit GIF\n        this.rabbit.update();\n      }\n      \n    } catch (error) {\n      console.error('Error in rabbit entity update:', error);\n      this.resetToHidden(now);\n    }\n  }\n\n  // SYNCHRONIZED TRANSITION TO VISIBLE\n  transitionToVisible(now) {\n    if (this.state === \"hidden\") {\n      this.state = \"spawning\";\n      this.spawnTime = now;\n      this.fadeInStartTime = now;\n      this.isActive = true;\n      \n      // Reset position\n      this.resetPosition();\n      \n      // Initialize both components synchronously\n      this.rabbit.show();\n      \n      if (this.hasSpeechBalloon && this.speechBubble) {\n        this.speechBubble.activate();\n        this.speechBubble.opacity = 0; // Start invisible, will fade in\n      }\n    }\n  }\n\n  // SYNCHRONIZED TRANSITION TO HIDDEN\n  transitionToHidden(now) {\n    if (this.state === \"alive\") {\n      this.state = \"dying\";\n      this.fadeOutStartTime = now;\n      \n      // Both components will fade out together\n    }\n  }\n\n  // SYNCHRONIZED VISUAL TRANSITIONS\n  updateVisualTransition(now) {\n    if (this.state === \"spawning\") {\n      // Calculate fade-in progress\n      const fixedProgress = _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FixedPointAnimation.calculateProgress(\n        now, \n        this.fadeInStartTime, \n        ANIMATION_DURATION\n      );\n    \n      if (fixedProgress >= _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_COMMON.ONE) {\n        // Fade in complete\n        this.state = \"alive\";\n        this.rabbit.setOpacity(1.0);\n        if (this.hasSpeechBalloon && this.speechBubble) {\n          this.speechBubble.opacity = 255;\n        }\n      } else {\n        // Continue fade in\n        const easeProgress = _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FixedPointMath.smoothStep(fixedProgress);\n        const opacity = _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FixedPointAnimation.calculateOpacity(easeProgress);\n        \n        this.rabbit.setOpacity(opacity / 255);\n        if (this.hasSpeechBalloon && this.speechBubble) {\n          this.speechBubble.opacity = opacity;\n        }\n      }\n    } else if (this.state === \"dying\") {\n      // Calculate fade-out progress\n      const fixedProgress = _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FixedPointAnimation.calculateProgress(\n        now, \n        this.fadeOutStartTime, \n        ANIMATION_DURATION\n      );\n      \n      if (fixedProgress >= _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_COMMON.ONE) {\n        // Fade out complete\n        this.resetToHidden(now);\n      } else {\n        // Continue fade out\n        const easeProgress = _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_COMMON.ONE - _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FixedPointMath.smoothStep(fixedProgress);\n        const opacity = _fixedPointMath_js__WEBPACK_IMPORTED_MODULE_0__.FixedPointAnimation.calculateOpacity(easeProgress);\n        \n        this.rabbit.setOpacity(opacity / 255);\n        if (this.hasSpeechBalloon && this.speechBubble) {\n          this.speechBubble.opacity = opacity;\n        }\n      }\n    }\n  }\n\n  // CLEAN RESET TO HIDDEN STATE\n  resetToHidden(now) {\n    this.state = \"hidden\";\n    this.isActive = false;\n    \n    // Clean both components\n    this.rabbit.hide();\n    if (this.speechBubble) {\n      this.speechBubble.deactivate();\n    }\n    \n    // Reset collision effects\n    this.collisionStartTime = 0;\n    this.collisionType = 'normal';\n  }\n\n  // Mathematical collision handling\n  handleCollision(itemType) {\n    if (this.state !== \"alive\") return;\n\n    try {\n      const gifTypes = ['normal', 'damage', 'glitch', 'spell'];\n      const typeIndex = itemType === 'fire' ? 1 : itemType === 'gem' ? 2 : itemType === 'magic' ? 3 : 0;\n      const newGif = gifTypes[typeIndex];\n      \n      this.collisionStartTime = this.p5.millis();\n      this.collisionType = newGif;\n      this.rabbit.switchToGif(newGif);\n      \n    } catch (error) {\n      console.error('Error handling collision:', error);\n    }\n  }\n\n  updateCollisionEffect(now) {\n    if (this.collisionStartTime > 0) {\n      const elapsed = now - this.collisionStartTime;\n      \n      if (elapsed >= this.collisionDuration) {\n        this.collisionStartTime = 0;\n        this.collisionType = 'normal';\n        if (this.state === \"alive\") {\n          this.rabbit.switchToGif('normal');\n        }\n      }\n    }\n  }\n\n  // Position management\n  resetPosition() {\n    try {\n      // Spawn anywhere across extended screen width (including off-screen padding)\n      const paddingArea = gifSize * 3; // Padding area on both sides\n      const extendedWidth = this.p5.width + (paddingArea * 2); // Total spawn area\n      \n      // Random horizontal position across the entire extended area\n      this.x = this.p5.random(-paddingArea, this.p5.width + paddingArea);\n      \n      // Vertical positioning - avoid top and bottom edges\n      const rows = Math.max(1, Math.floor(this.p5.height / gifSize));\n      const minRow = Math.max(0, Math.floor(rows * 0.05));\n      const maxRow = Math.min(rows - 1, Math.floor(rows * 0.95));\n      const row = Math.floor(this.p5.random(minRow, maxRow + 1));\n      \n      this.y = row * gifSize + gifSize / 2;\n      \n      // Y bounds checking only (X can be anywhere in extended area)\n      this.y = Math.max(gifSize / 2, Math.min(this.p5.height - gifSize / 2, this.y));\n    } catch (error) {\n      console.error('Error in resetPosition:', error);\n      // Fallback: random position across screen width\n      this.x = this.p5.random(-gifSize * 2, this.p5.width + gifSize * 2);\n      this.y = this.p5.height / 2;\n    }\n  }\n\n  updatePosition(now) {\n    try {\n      // Simple horizontal movement\n      this.x += this.speed;\n      \n      // REMOVED: No more wrap-around! Let rabbit move off-screen naturally\n      // The rabbit will disappear via the mathematical existence check\n      \n      // Update rabbit position\n      const xDelta = Math.abs(this.x - this.lastX);\n      const yDelta = Math.abs(this.y - this.lastY);\n      const timeDelta = now - this.lastDOMUpdate;\n      \n      if (timeDelta > this.domUpdateInterval || xDelta > 2 || yDelta > 2) {\n        this.lastDOMUpdate = now;\n        this.lastX = this.x;\n        this.lastY = this.y;\n        \n        this.rabbit.updatePosition(this.x, this.y);\n      }\n    } catch (error) {\n      console.error('Error updating position:', error);\n    }\n  }\n\n  // Public interface\n  getState() { return this.state; }\n  isAlive() { return this.state === \"alive\"; }\n  isVisible() { return this.state !== \"hidden\" && this.state !== \"error\"; }\n  getPosition() { return { x: this.x, y: this.y }; }\n  getId() { return this.id; }\n\n  // Render speech bubble (called from main draw loop)\n  drawSpeechBubble() {\n    if (this.hasSpeechBalloon && this.speechBubble && this.speechBubble.isActive()) {\n      this.speechBubble.draw(this.x, this.y);\n    }\n  }\n\n  // Cleanup\n  cleanup() {\n    try {\n      this.rabbit.cleanup();\n      if (this.speechBubble) {\n        this.speechBubble.cleanup();\n      }\n    } catch (error) {\n      console.error('Error during cleanup:', error);\n    }\n  }\n}\n\n/**\n * RABBIT GIF COMPONENT\n * Manages the visual GIF display for the rabbit\n */\nclass RabbitGIF {\n  constructor(p5, parentEntity) {\n    this.p5 = p5;\n    this.parent = parentEntity;\n    this.currentGif = 'normal';\n    this.container = null;\n    this.gifs = {};\n    \n    this.createGifLayers();\n  }\n\n  createGifLayers() {\n    try {\n      // Create container div for all GIF layers\n      this.container = this.p5.createDiv('');\n      this.container.position(this.parent.x - gifSize / 2, this.parent.y - gifSize / 2);\n      this.container.size(gifSize, gifSize);\n      this.container.style('position', 'absolute');\n      this.container.style('z-index', '1000');\n      this.container.style('will-change', 'transform, opacity');\n      this.container.style('backface-visibility', 'hidden');\n      \n      // Create all GIF layers\n      const originalSrc = this.p5.random() < 0.5 ? \"rabbit-white.gif\" : \"rabbit-orange.gif\";\n      \n      this.gifs = {\n        normal: this.p5.createImg(originalSrc, \"rabbit\"),\n        damage: this.p5.createImg(\"rabbit-damage.gif\", \"rabbit-damage\"),\n        glitch: this.p5.createImg(\"rabbit-glitch.gif\", \"rabbit-glitch\"),\n        spell: this.p5.createImg(\"rabbit-spell.gif\", \"rabbit-spell\"),\n        error: this.p5.createImg(\"err.gif\", \"rabbit-error\")\n      };\n      \n      // Style each GIF layer\n      Object.values(this.gifs).forEach(gif => {\n        gif.parent(this.container);\n        gif.size(gifSize, gifSize);\n        gif.style('position', 'absolute');\n        gif.style('top', '0');\n        gif.style('left', '0');\n        gif.style('transition', 'none');\n        gif.style('will-change', 'opacity');\n        gif.style('backface-visibility', 'hidden');\n        gif.style('opacity', '0');\n      });\n      \n      this.gifs.normal.style('opacity', '1');\n      this.container.hide();\n      \n    } catch (error) {\n      console.error('Error creating GIF layers:', error);\n    }\n  }\n\n  show() {\n    if (this.container) {\n      this.container.show();\n    }\n  }\n\n  hide() {\n    if (this.container) {\n      this.container.hide();\n    }\n  }\n\n  setOpacity(opacity) {\n    if (this.container) {\n      this.container.style('opacity', opacity.toString());\n    }\n  }\n\n  updatePosition(x, y) {\n    if (this.container) {\n      const newX = Math.round(x - gifSize / 2);\n      const newY = Math.round(y - gifSize / 2);\n      \n      const element = this.container.elt;\n      element.style.left = newX + 'px';\n      element.style.top = newY + 'px';\n    }\n  }\n\n  switchToGif(gifType) {\n    try {\n      if (this.currentGif !== gifType && this.gifs && this.gifs[gifType]) {\n        // Pre-allocated arrays for performance\n        if (!this._gifKeys) {\n          this._gifKeys = ['normal', 'damage', 'glitch', 'spell', 'error'];\n          this._gifElements = this._gifKeys.map(key => this.gifs[key]);\n        }\n        \n        for (let i = 0; i < this._gifKeys.length; i++) {\n          const gif = this._gifElements[i];\n          if (gif && gif.style) {\n            gif.style('opacity', this._gifKeys[i] === gifType ? '1' : '0');\n          }\n        }\n        \n        this.currentGif = gifType;\n      }\n    } catch (error) {\n      console.error('Error switching GIF:', error);\n    }\n  }\n\n  update() {\n    // Any per-frame updates for the GIF component\n  }\n\n  cleanup() {\n    try {\n      if (this.gifs) {\n        Object.values(this.gifs).forEach(gif => {\n          if (gif && gif.remove) {\n            gif.remove();\n          }\n        });\n      }\n      \n      if (this.container && this.container.remove) {\n        this.container.remove();\n      }\n    } catch (error) {\n      console.error('Error during GIF cleanup:', error);\n    }\n  }\n}\n\n/**\n * SPEECH BUBBLE COMPONENT\n * Manages the speech bubble display synchronized with the rabbit\n */\nclass SpeechBubble {\n  constructor(p5, fonts, parentEntity) {\n    this.p5 = p5;\n    this.fonts = fonts;\n    this.parent = parentEntity;\n    \n    // State\n    this.isActiveState = false;\n    this.opacity = 0;\n    this.speechText = \"\";\n    this.useChineseText = false;\n    \n    // Text change parameters\n    this.textChangeMathSeed = Math.random();\n    this.textChangeFrequency = p5.random(0.00005, 0.0002);\n    this.lastTextMathValue = 0;\n    this.spawnTime = 0;\n  }\n\n  activate() {\n    this.isActiveState = true;\n    this.opacity = 0;\n    this.spawnTime = this.p5.millis();\n    this.generateNewText();\n  }\n\n  deactivate() {\n    this.isActiveState = false;\n    this.opacity = 0;\n  }\n\n  isActive() {\n    return this.isActiveState;\n  }\n\n  generateNewText() {\n    try {\n      const globalLanguageIntensity = window.languageModeChineseIntensity || 0;\n      const mathLanguageBoost = Math.sin(this.p5.millis() * 0.0003 + this.textChangeMathSeed * 6.28) * 0.3;\n      const totalChineseChance = Math.min(0.8, 0.2 + globalLanguageIntensity * 0.4 + mathLanguageBoost);\n      \n      this.useChineseText = this.p5.random() < totalChineseChance;\n      this.speechText = this.useChineseText\n        ? chineseSpeechTexts[Math.floor(this.p5.random(chineseSpeechTexts.length))]\n        : speechTexts[Math.floor(this.p5.random(speechTexts.length))];\n        \n    } catch (error) {\n      console.error('Error generating speech text:', error);\n      this.speechText = \"...\";\n      this.useChineseText = false;\n    }\n  }\n\n  update(x, y) {\n    if (!this.isActiveState) return;\n    \n    try {\n      const now = this.p5.millis();\n      const timeSinceSpawn = now - this.spawnTime;\n      \n      // Mathematical text change trigger\n      const textChangeMath = Math.sin(timeSinceSpawn * this.textChangeFrequency + this.textChangeMathSeed * 6.28);\n      const textChangeThreshold = 0.95;\n      \n      if (textChangeMath > textChangeThreshold && this.lastTextMathValue <= textChangeThreshold) {\n        this.generateNewText();\n      }\n      \n      this.lastTextMathValue = textChangeMath;\n    } catch (error) {\n      console.error('Error updating speech system:', error);\n    }\n  }\n\n  // PROFESSIONAL COMIC-STYLE SPEECH BALLOON\n  draw(x, y) {\n    if (this.opacity <= 0 || !this.isActiveState) return;\n    \n    try {\n      // CRITICAL FIX: Check off-screen FIRST before any positioning calculations\n      const rabbitBuffer = gifSize * 0.5; // Buffer zone for smooth disappearance\n      if (x < -rabbitBuffer || x > this.p5.width + rabbitBuffer) {\n        return; // Don't draw bubble when rabbit is off-screen (with buffer)\n      }\n      \n      const drawOpacity = Math.max(0, Math.min(255, this.opacity));\n      \n      // Set font and size\n      if (this.useChineseText && this.fonts.chinese) {\n        this.p5.textFont(this.fonts.chinese);\n        this.p5.textSize(17);\n      } else if (this.fonts.arcade) {\n        this.p5.textFont(this.fonts.arcade);\n        this.p5.textSize(15);\n      }\n      \n      // Professional balloon dimensions\n      const textWidth = this.p5.textWidth(this.speechText);\n      const paddingH = 14;\n      const paddingV = 8;\n      const bubbleWidth = textWidth + paddingH * 2;\n      const bubbleHeight = 28;\n      const cornerRadius = 8;\n      \n      // Calculate bubble position - ALWAYS follow the rabbit position exactly\n      let bubbleX = Math.round(x - bubbleWidth * 0.2);\n      const bubbleY = Math.round(y - bubbleHeight - 25);\n      \n      // FINAL FIX: No constraints! Let bubble move naturally with rabbit\n      // Bubble will move off-screen with rabbit and disappear via the buffer check above\n      \n      // High-quality balloon body with shadow\n      this.p5.fill(0, 0, 0, Math.min(drawOpacity * 0.15, 30));\n      this.p5.noStroke();\n      this.p5.rect(bubbleX + 2, bubbleY + 2, bubbleWidth, bubbleHeight, cornerRadius);\n      \n      // Main balloon body\n      this.p5.fill(255, 255, 255, Math.min(drawOpacity, 250));\n      this.p5.stroke(40, 40, 40, Math.min(drawOpacity, 230));\n      this.p5.strokeWeight(1.8);\n      this.p5.rect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, cornerRadius);\n      \n      // Professional tail\n      const tailBaseX = bubbleX + bubbleWidth * 0.2;\n      const tailBaseY = bubbleY + bubbleHeight;\n      const tailHeight = 8;\n      const tailBaseWidth = 10;\n      \n      // Tail shadow\n      this.p5.fill(0, 0, 0, Math.min(drawOpacity * 0.15, 30));\n      this.p5.noStroke();\n      this.p5.beginShape();\n      this.p5.vertex(tailBaseX - tailBaseWidth/2 + 2, tailBaseY + 2);\n      this.p5.vertex(tailBaseX + tailBaseWidth/2 + 2, tailBaseY + 2);\n      this.p5.vertex(tailBaseX + 2, tailBaseY + tailHeight + 2);\n      this.p5.endShape(this.p5.CLOSE);\n      \n      // Main tail\n      this.p5.fill(255, 255, 255, Math.min(drawOpacity, 250));\n      this.p5.stroke(40, 40, 40, Math.min(drawOpacity, 230));\n      this.p5.strokeWeight(1.8);\n      this.p5.beginShape();\n      this.p5.vertex(tailBaseX - tailBaseWidth/2, tailBaseY);\n      this.p5.vertex(tailBaseX + tailBaseWidth/2, tailBaseY);\n      this.p5.vertex(tailBaseX, tailBaseY + tailHeight);\n      this.p5.endShape(this.p5.CLOSE);\n      \n      // Seamless connection\n      this.p5.noStroke();\n      this.p5.fill(255, 255, 255, Math.min(drawOpacity, 250));\n      this.p5.rect(tailBaseX - tailBaseWidth/2, tailBaseY - 1.5, tailBaseWidth, 3);\n      \n      // Ultra-crisp text\n      this.p5.fill(25, 25, 25, drawOpacity);\n      this.p5.noStroke();\n      this.p5.textAlign(this.p5.CENTER, this.p5.CENTER);\n      \n      const textX = Math.round(bubbleX + bubbleWidth / 2);\n      const textY = Math.round(bubbleY + bubbleHeight / 2);\n      \n      this.p5.text(this.speechText, textX, textY);\n      \n    } catch (error) {\n      console.error('Error drawing speech bubble:', error);\n    }\n  }\n\n  cleanup() {\n    this.deactivate();\n  }\n} \n\n//# sourceURL=webpack://particles/./src/lib/rabbitEntity.js?");
  
  /***/ }),
  
  /***/ "./src/lib/spatialHashGrid.js":
  /*!************************************!*\
    !*** ./src/lib/spatialHashGrid.js ***!
    \************************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpatialHashGrid\": () => (/* binding */ SpatialHashGrid),\n/* harmony export */   \"createOptimalSpatialGrid\": () => (/* binding */ createOptimalSpatialGrid)\n/* harmony export */ });\n// Ultra-High Performance Spatial Hash Grid for Collision Detection\n// Reduces collision detection from O(n²) to O(1) average case\n// 10-50x performance improvement in dense collision scenarios\n\nclass SpatialHashGrid {\n  constructor(cellSize = 64, worldWidth = 1920, worldHeight = 1080) {\n    this.cellSize = cellSize;\n    this.worldWidth = worldWidth;\n    this.worldHeight = worldHeight;\n    \n    // Pre-calculated grid dimensions\n    this.gridWidth = Math.ceil(worldWidth / cellSize);\n    this.gridHeight = Math.ceil(worldHeight / cellSize);\n    this.totalCells = this.gridWidth * this.gridHeight;\n    \n    // Use typed arrays for maximum performance\n    this.grid = new Array(this.totalCells);\n    this.objectCells = new Map(); // Track which cells each object is in\n    \n    // Pre-allocated arrays for neighbor queries (avoid garbage collection)\n    this.neighborCells = new Array(9); // Max 9 cells to check (3x3 grid)\n    this.queryResults = new Array(100); // Pre-allocated result array\n    \n    // Performance statistics\n    this.stats = {\n      insertions: 0,\n      queries: 0,\n      averageObjectsPerCell: 0,\n      maxObjectsPerCell: 0\n    };\n    \n    this.clear();\n  }\n\n  // Ultra-fast cell index calculation using bit operations where possible\n  getCellIndex(x, y) {\n    // Clamp to world bounds for safety\n    const cellX = Math.max(0, Math.min(this.gridWidth - 1, Math.floor(x / this.cellSize)));\n    const cellY = Math.max(0, Math.min(this.gridHeight - 1, Math.floor(y / this.cellSize)));\n    \n    // Single multiplication is faster than array access\n    return cellY * this.gridWidth + cellX;\n  }\n\n  // Get cell coordinates from index (for debugging/visualization)\n  getCellCoords(index) {\n    const cellY = Math.floor(index / this.gridWidth);\n    const cellX = index % this.gridWidth;\n    return { x: cellX, y: cellY };\n  }\n\n  // Clear all cells - ultra-fast reset\n  clear() {\n    // Reset arrays without reallocation\n    for (let i = 0; i < this.totalCells; i++) {\n      if (this.grid[i]) {\n        this.grid[i].length = 0; // Clear existing arrays\n      } else {\n        this.grid[i] = []; // Create new arrays only if needed\n      }\n    }\n    this.objectCells.clear();\n  }\n\n  // Insert object into grid - O(1) operation\n  insert(object) {\n    const cellIndex = this.getCellIndex(object.x, object.y);\n    \n    // Add to cell\n    this.grid[cellIndex].push(object);\n    \n    // Track which cell this object is in for fast removal\n    this.objectCells.set(object, cellIndex);\n    \n    this.stats.insertions++;\n    \n    // Update statistics\n    const cellSize = this.grid[cellIndex].length;\n    if (cellSize > this.stats.maxObjectsPerCell) {\n      this.stats.maxObjectsPerCell = cellSize;\n    }\n  }\n\n  // Remove object from grid - O(1) average case\n  remove(object) {\n    const cellIndex = this.objectCells.get(object);\n    if (cellIndex === undefined) return false;\n    \n    const cell = this.grid[cellIndex];\n    const objectIndex = cell.indexOf(object);\n    \n    if (objectIndex !== -1) {\n      // Swap with last element and pop (faster than splice)\n      cell[objectIndex] = cell[cell.length - 1];\n      cell.pop();\n      this.objectCells.delete(object);\n      return true;\n    }\n    \n    return false;\n  }\n\n  // Update object position - combines remove and insert\n  update(object, newX, newY) {\n    const oldCellIndex = this.objectCells.get(object);\n    const newCellIndex = this.getCellIndex(newX, newY);\n    \n    // Only move if cell changed\n    if (oldCellIndex !== newCellIndex) {\n      this.remove(object);\n      object.x = newX;\n      object.y = newY;\n      this.insert(object);\n    } else {\n      // Just update position if staying in same cell\n      object.x = newX;\n      object.y = newY;\n    }\n  }\n\n  // Get all objects in cells near the given position - O(1) average\n  // This is the main performance optimization for collision detection\n  queryNearby(x, y, radius = 0) {\n    this.stats.queries++;\n    \n    // Calculate search area\n    const minCellX = Math.max(0, Math.floor((x - radius) / this.cellSize));\n    const maxCellX = Math.min(this.gridWidth - 1, Math.floor((x + radius) / this.cellSize));\n    const minCellY = Math.max(0, Math.floor((y - radius) / this.cellSize));\n    const maxCellY = Math.min(this.gridHeight - 1, Math.floor((y + radius) / this.cellSize));\n    \n    // Clear previous results\n    this.queryResults.length = 0;\n    \n    // Check all cells in search area\n    for (let cellY = minCellY; cellY <= maxCellY; cellY++) {\n      for (let cellX = minCellX; cellX <= maxCellX; cellX++) {\n        const cellIndex = cellY * this.gridWidth + cellX;\n        const cell = this.grid[cellIndex];\n        \n        // Add all objects from this cell\n        for (let i = 0; i < cell.length; i++) {\n          this.queryResults.push(cell[i]);\n        }\n      }\n    }\n    \n    return this.queryResults;\n  }\n\n  // Optimized collision detection between two object types\n  // Returns pairs of colliding objects\n  detectCollisions(typeA, typeB, collisionDistance) {\n    const collisions = [];\n    const distanceSquared = collisionDistance * collisionDistance;\n    \n    // For each object of typeA, check nearby objects of typeB\n    for (const objA of typeA) {\n      const nearby = this.queryNearby(objA.x, objA.y, collisionDistance);\n      \n      for (const objB of nearby) {\n        // Skip if not correct type or same object\n        if (typeB.indexOf(objB) === -1 || objA === objB) continue;\n        \n        // Fast squared distance check\n        const dx = objA.x - objB.x;\n        const dy = objA.y - objB.y;\n        const distSq = dx * dx + dy * dy;\n        \n        if (distSq <= distanceSquared) {\n          collisions.push({ a: objA, b: objB, distance: Math.sqrt(distSq) });\n        }\n      }\n    }\n    \n    return collisions;\n  }\n\n  // Get performance statistics\n  getStats() {\n    // Calculate average objects per cell\n    let totalObjects = 0;\n    let activeCells = 0;\n    \n    for (let i = 0; i < this.totalCells; i++) {\n      const cellSize = this.grid[i].length;\n      if (cellSize > 0) {\n        totalObjects += cellSize;\n        activeCells++;\n      }\n    }\n    \n    this.stats.averageObjectsPerCell = activeCells > 0 ? totalObjects / activeCells : 0;\n    \n    return {\n      ...this.stats,\n      totalCells: this.totalCells,\n      activeCells,\n      totalObjects,\n      gridSize: `${this.gridWidth}x${this.gridHeight}`,\n      cellSize: this.cellSize\n    };\n  }\n\n  // Visualize grid for debugging (optional)\n  visualize(p5, showEmpty = false, showStats = true) {\n    p5.push();\n    p5.stroke(100, 100);\n    p5.noFill();\n    \n    // Draw grid lines\n    for (let x = 0; x <= this.worldWidth; x += this.cellSize) {\n      p5.line(x, 0, x, this.worldHeight);\n    }\n    for (let y = 0; y <= this.worldHeight; y += this.cellSize) {\n      p5.line(0, y, this.worldWidth, y);\n    }\n    \n    // Show cell occupancy\n    for (let i = 0; i < this.totalCells; i++) {\n      const cellSize = this.grid[i].length;\n      if (cellSize > 0 || showEmpty) {\n        const coords = this.getCellCoords(i);\n        const x = coords.x * this.cellSize;\n        const y = coords.y * this.cellSize;\n        \n        if (cellSize > 0) {\n          // Color based on occupancy\n          const intensity = Math.min(255, cellSize * 50);\n          p5.fill(255, 0, 0, intensity);\n          p5.rect(x, y, this.cellSize, this.cellSize);\n          \n          // Show count\n          p5.fill(255);\n          p5.textAlign(p5.CENTER, p5.CENTER);\n          p5.text(cellSize, x + this.cellSize/2, y + this.cellSize/2);\n        }\n      }\n    }\n    \n    // Show statistics\n    if (showStats) {\n      const stats = this.getStats();\n      p5.fill(255);\n      p5.textAlign(p5.LEFT, p5.TOP);\n      p5.text(`Grid Stats:\nActive Cells: ${stats.activeCells}/${stats.totalCells}\nTotal Objects: ${stats.totalObjects}\nAvg Objects/Cell: ${stats.averageObjectsPerCell.toFixed(1)}\nMax Objects/Cell: ${stats.maxObjectsPerCell}\nQueries: ${stats.queries}\nInsertions: ${stats.insertions}`, 10, 10);\n    }\n    \n    p5.pop();\n  }\n}\n\n// Factory function for creating optimally-sized grids\nfunction createOptimalSpatialGrid(worldWidth, worldHeight, averageObjectSize) {\n  // Rule of thumb: cell size should be 2-4x the average object size\n  const optimalCellSize = Math.max(32, averageObjectSize * 3);\n  return new SpatialHashGrid(optimalCellSize, worldWidth, worldHeight);\n} \n\n//# sourceURL=webpack://particles/./src/lib/spatialHashGrid.js?");
  
  /***/ }),
  
  /***/ "./src/lib/stream.js":
  /*!***************************!*\
    !*** ./src/lib/stream.js ***!
    \***************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stream\": () => (/* binding */ Stream)\n/* harmony export */ });\n/* harmony import */ var _objectPools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectPools.js */ \"./src/lib/objectPools.js\");\nconst {\n  MIN_STREAM_SIZE,\n  MAX_STREAM_SIZE,\n  pixelSize,\n  blinkChance,\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\nconst { Pixel } = __webpack_require__(/*! ./pixel */ \"./src/lib/pixel.js\");\n\n// Import ultra-high performance object pooling\n\n\n// Revolutionary Batch Rendering System - Replace thousands of p5.rect() with efficient buffers\nclass StreamBatchRenderer {\n  constructor(p5) {\n    this.p5 = p5;\n    this.pixelBuffer = p5.createGraphics(p5.width, p5.height);\n    this.pixelBuffer.pixelDensity(1); // Force 1x density for performance\n    \n    // Pre-allocated arrays for batch operations\n    this.batchPixels = [];\n    this.colorBatches = new Map(); // Group by color for efficient rendering\n    \n    // Performance tracking\n    this.lastClearTime = 0;\n    this.clearInterval = 33; // Clear buffer every 33ms (~30fps) for trails effect\n    \n    // Ultra-optimized color pools - pre-compute common colors\n    this.colorCache = new Map();\n    this.setupColorCache();\n  }\n  \n  setupColorCache() {\n    // Pre-compute common color combinations for instant lookup\n    const commonColors = [\n      [255, 255, 255], [255, 0, 0], [0, 255, 0], [0, 0, 255],\n      [255, 255, 0], [255, 0, 255], [0, 255, 255], [128, 128, 128]\n    ];\n    \n    for (let i = 0; i < commonColors.length; i++) {\n      const [r, g, b] = commonColors[i];\n      for (let opacity = 0; opacity <= 255; opacity += 32) {\n        const key = `${r},${g},${b},${opacity}`;\n        this.colorCache.set(key, this.p5.color(r, g, b, opacity));\n      }\n    }\n  }\n  \n  // Ultra-fast color lookup with caching\n  getColor(r, g, b, opacity) {\n    const key = `${r},${g},${b},${Math.floor(opacity / 32) * 32}`;\n    let color = this.colorCache.get(key);\n    if (!color) {\n      color = this.p5.color(r, g, b, opacity);\n      this.colorCache.set(key, color);\n    }\n    return color;\n  }\n  \n  // Add pixel to batch render queue\n  addPixel(x, y, color, opacity) {\n    const colorKey = `${color.levels[0]},${color.levels[1]},${color.levels[2]},${Math.floor(opacity)}`;\n    \n    if (!this.colorBatches.has(colorKey)) {\n      this.colorBatches.set(colorKey, []);\n    }\n    \n    this.colorBatches.get(colorKey).push({ x, y });\n  }\n  \n  // Revolutionary batch rendering - render all pixels of same color together\n  render() {\n    const now = this.p5.millis();\n    \n    // Clear buffer occasionally for trailing effect\n    if (now - this.lastClearTime > this.clearInterval) {\n      this.pixelBuffer.clear();\n      this.lastClearTime = now;\n    }\n    \n    // Batch render by color - MASSIVE performance improvement\n    this.pixelBuffer.noStroke();\n    \n    for (const [colorKey, pixels] of this.colorBatches) {\n      if (pixels.length === 0) continue;\n      \n      const [r, g, b, opacity] = colorKey.split(',').map(Number);\n      this.pixelBuffer.fill(r, g, b, opacity);\n      \n      // Draw all pixels of this color in one operation\n      for (let i = 0; i < pixels.length; i++) {\n        const pixel = pixels[i];\n        this.pixelBuffer.rect(pixel.x, pixel.y, pixelSize, pixelSize);\n      }\n    }\n    \n    // Render the entire buffer to main canvas in ONE operation\n    this.p5.image(this.pixelBuffer, 0, 0);\n    \n    // Clear batches for next frame\n    this.colorBatches.clear();\n  }\n  \n  // Resize buffer when canvas changes\n  resize(width, height) {\n    this.pixelBuffer.resizeCanvas(width, height);\n  }\n}\n\n// Global batch renderer instance\nlet globalBatchRenderer = null;\n\nconst getBatchRenderer = (p5) => {\n  if (!globalBatchRenderer) {\n    globalBatchRenderer = new StreamBatchRenderer(p5);\n  }\n  return globalBatchRenderer;\n};\n\n// Optimized Firework class with reduced draw calls\nclass Firework {\n  constructor(p5) {\n    this.p5 = p5;\n    this.batchRenderer = getBatchRenderer(p5);\n    this.reset();\n  }\n\n  reset() {\n    this.x = this.p5.random(this.p5.width);\n    this.y = this.p5.random(this.p5.height / 2);\n    this.stage = 0;\n    this.opacity = 255;\n    this.active = true;\n    this.pattern = Math.floor(this.p5.random(1, 4));\n    this.lifetime = this.p5.millis() + this.p5.random(800, 2000);\n    \n    // Pre-compute pattern coordinates for batch rendering\n    this.precomputedPixels = this.generatePatternPixels();\n  }\n  \n  // Pre-compute all pixel positions for this firework pattern\n  generatePatternPixels() {\n    const patterns = {\n      1: [ // Cross pattern\n        [0, 0], [-1, 0], [1, 0], [0, -1], [0, 1],\n        [-2, 0], [2, 0], [0, -2], [0, 2]\n      ],\n      2: [ // Square pattern  \n        [-1, -1], [-1, 0], [-1, 1],\n        [0, -1], [0, 0], [0, 1],\n        [1, -1], [1, 0], [1, 1]\n      ],\n      3: [ // Diagonal pattern\n        [0, 0], [-1, -1], [1, 1], [-1, 1], [1, -1],\n        [-2, -2], [2, 2]\n      ]\n    };\n    \n    return patterns[this.pattern] || patterns[1];\n  }\n\n  update() {\n    if (!this.active) return;\n\n    const now = this.p5.millis();\n    if (now > this.lifetime) {\n      this.active = false;\n      if (this.p5.random() < 0.005) {\n        this.reset();\n      }\n      return;\n    }\n\n    this.stage += 1;\n    this.opacity -= 10;\n  }\n\n  // Ultra-optimized display using batch renderer\n  display() {\n    if (!this.active || this.opacity <= 0) return;\n\n    const color = this.p5.color(255, 255, 255);\n    const stageMultiplier = Math.min(3, Math.floor(this.stage / 3));\n    \n    // Add pixels to batch renderer instead of drawing individually\n    for (let i = 0; i < this.precomputedPixels.length; i++) {\n      const [dx, dy] = this.precomputedPixels[i];\n      const x = this.x + dx * pixelSize * stageMultiplier;\n      const y = this.y + dy * pixelSize * stageMultiplier;\n      \n      if (x >= 0 && x < this.p5.width && y >= 0 && y < this.p5.height) {\n        this.batchRenderer.addPixel(x, y, color, this.opacity);\n      }\n    }\n  }\n}\n\nclass Stream {\n  constructor(p5, x, speed, getPaletteIndex, getTransitionProgress) {\n    this.p5 = p5;\n    this.pixels = [];\n    this.fireworks = [];\n    this.totalPixels = Math.floor(p5.random(MIN_STREAM_SIZE, MAX_STREAM_SIZE));\n    this.speed = speed;\n    this.headIndex = Math.floor(p5.random(this.totalPixels));\n    this.lastUpdate = p5.millis();\n    this.getPaletteIndex = getPaletteIndex;\n    this.getTransitionProgress = getTransitionProgress;\n    \n    // Revolutionary batch rendering system\n    this.batchRenderer = getBatchRenderer(p5);\n    \n    // Horizontal movement for parallax effect\n    this.x = x;\n    this.horizontalSpeed = -0.5;\n\n    this.generatePixels(x);\n    \n    // Performance optimization: Reduce update frequency\n    this.lastRenderUpdate = 0;\n    this.renderUpdateInterval = 16; // ~60fps for smooth rendering\n  }\n\n  generatePixels(x) {\n    // Check if object pooling is available\n    const poolManager = (0,_objectPools_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalPoolManager)(this.p5);\n    \n    if (poolManager) {\n      // Use object pooling for 80-90% less garbage collection\n      for (let i = 0; i < this.totalPixels; i++) {\n        const pooledPixel = (0,_objectPools_js__WEBPACK_IMPORTED_MODULE_0__.acquirePooledPixel)(\n          this.p5,\n          x,\n          i * pixelSize,\n          this.getPaletteIndex,\n          this.getTransitionProgress\n        );\n        \n        // Add batch rendering capability\n        pooledPixel.batchRenderer = this.batchRenderer;\n        this.pixels.push(pooledPixel);\n      }\n    } else {\n      // Fallback to traditional pixel creation\n      for (let i = 0; i < this.totalPixels; i++) {\n        const pixel = new Pixel(\n          this.p5,\n          x,\n          i * pixelSize,\n          this.getPaletteIndex,\n          this.getTransitionProgress,\n        );\n        pixel.batchRenderer = this.batchRenderer;\n        this.pixels.push(pixel);\n      }\n    }\n  }\n\n  updateHorizontalPosition() {\n    // Move the entire stream horizontally for parallax effect\n    this.x += this.horizontalSpeed;\n    \n    // Wrap around screen when stream moves off the left edge\n    if (this.x < -pixelSize) {\n      this.x = this.p5.width + pixelSize;\n    }\n    \n    // Update all pixel positions in this stream - optimized\n    const pixelCount = this.pixels.length;\n    for (let i = 0; i < pixelCount; i++) {\n      this.pixels[i].x = this.x;\n    }\n    \n    // Update firework positions too - optimized\n    const fireworkCount = this.fireworks.length;\n    for (let i = 0; i < fireworkCount; i++) {\n      if (this.fireworks[i].active) {\n        this.fireworks[i].x += this.horizontalSpeed;\n        // Wrap fireworks too\n        if (this.fireworks[i].x < -pixelSize) {\n          this.fireworks[i].x = this.p5.width + pixelSize;\n        }\n      }\n    }\n  }\n\n  generateFireworks() {\n    const fireworkCount = 50;\n    for (let i = 0; i < fireworkCount; i++) {\n      this.fireworks.push(new Firework(this.p5));\n    }\n  }\n\n  update() {\n    // **🌊 Step 0: Update horizontal position for parallax effect**\n    this.updateHorizontalPosition();\n    \n    // **🟢 Step 1: Update stream pixels with proper head tracking**\n    const now = this.p5.millis();\n    if (now - this.lastUpdate >= this.speed) {\n      this.headIndex = (this.headIndex + 1) % this.totalPixels;\n      this.lastUpdate = now;\n\n      // Update pixel opacity based on distance from head\n      const pixelCount = this.pixels.length;\n      for (let i = 0; i < pixelCount; i++) {\n        const distance = (this.headIndex - i + this.totalPixels) % this.totalPixels;\n\n        this.pixels[i].opacity = distance === 0\n          ? 255\n          : this.p5.map(distance, 1, this.totalPixels / 2, 255, 0);\n\n        if (this.p5.random() < blinkChance) {\n          this.pixels[i].opacity = this.p5.random(50, 255);\n        }\n\n        // Update pixel color\n        if (this.pixels[i].updateColor) {\n          this.pixels[i].updateColor();\n        }\n      }\n    }\n    \n    // **🎆 Step 2: Update fireworks efficiently with cached length**\n    const fireworkCount = this.fireworks.length;\n    for (let i = 0; i < fireworkCount; i++) {\n      this.fireworks[i].update();\n    }\n  }\n\n  // Revolutionary batch rendering - eliminates thousands of individual draw calls\n  render() {\n    const now = this.p5.millis();\n    \n    // Throttle render updates for performance\n    if (now - this.lastRenderUpdate < this.renderUpdateInterval) return;\n    this.lastRenderUpdate = now;\n    \n    // Update all pixels and fireworks efficiently\n    this.update();\n    \n    // Add all pixels to batch renderer instead of drawing individually\n    const pixelCount = this.pixels.length;\n    for (let i = 0; i < pixelCount; i++) {\n      const pixel = this.pixels[i];\n      if (pixel.opacity > 0) {\n        this.batchRenderer.addPixel(pixel.x, pixel.y, pixel.color, pixel.opacity);\n      }\n    }\n    \n    // Add fireworks to batch renderer\n    const fireworkCount = this.fireworks.length;\n    for (let i = 0; i < fireworkCount; i++) {\n      this.fireworks[i].display();\n    }\n  }\n  \n  // Static method to render all streams at once - MASSIVE performance gain\n  static renderAllStreams(streams) {\n    if (streams.length === 0) return;\n    \n    const p5 = streams[0].p5;\n    const batchRenderer = getBatchRenderer(p5);\n    \n    // Update all streams and add pixels to batch\n    for (let i = 0; i < streams.length; i++) {\n      streams[i].render();\n    }\n    \n    // Render everything in ONE operation\n    batchRenderer.render();\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/stream.js?");
  
  /***/ })
  
  /******/ 	});
  /************************************************************************/
  /******/ 	// The module cache
  /******/ 	var __webpack_module_cache__ = {};
  /******/ 	
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/ 		// Check if module is in cache
  /******/ 		var cachedModule = __webpack_module_cache__[moduleId];
  /******/ 		if (cachedModule !== undefined) {
  /******/ 			return cachedModule.exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = __webpack_module_cache__[moduleId] = {
  /******/ 			// no module.id needed
  /******/ 			// no module.loaded needed
  /******/ 			exports: {}
  /******/ 		};
  /******/ 	
  /******/ 		// Execute the module function
  /******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
  /******/ 	
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/ 	
  /************************************************************************/
  /******/ 	/* webpack/runtime/define property getters */
  /******/ 	(() => {
  /******/ 		// define getter functions for harmony exports
  /******/ 		__webpack_require__.d = (exports, definition) => {
  /******/ 			for(var key in definition) {
  /******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
  /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
  /******/ 				}
  /******/ 			}
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/hasOwnProperty shorthand */
  /******/ 	(() => {
  /******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/make namespace object */
  /******/ 	(() => {
  /******/ 		// define __esModule on exports
  /******/ 		__webpack_require__.r = (exports) => {
  /******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 			}
  /******/ 			Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /************************************************************************/
  /******/ 	
  /******/ 	// startup
  /******/ 	// Load entry module and return exports
  /******/ 	// This entry module can't be inlined because the eval devtool is used.
  /******/ 	var __webpack_exports__ = __webpack_require__("./src/karma.js");
  /******/ 	
  /******/ })()
  ;