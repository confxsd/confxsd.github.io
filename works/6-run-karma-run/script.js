/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/const.js":
/*!**********************!*\
  !*** ./src/const.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MAX_PIXEL_SPEED\": () => (/* binding */ MAX_PIXEL_SPEED),\n/* harmony export */   \"MAX_STREAM_SIZE\": () => (/* binding */ MAX_STREAM_SIZE),\n/* harmony export */   \"MIN_PIXEL_SPEED\": () => (/* binding */ MIN_PIXEL_SPEED),\n/* harmony export */   \"MIN_STREAM_SIZE\": () => (/* binding */ MIN_STREAM_SIZE),\n/* harmony export */   \"RABBIT_SPEED\": () => (/* binding */ RABBIT_SPEED),\n/* harmony export */   \"SPEECH_CHANCE\": () => (/* binding */ SPEECH_CHANCE),\n/* harmony export */   \"TRANSITION_SPEED\": () => (/* binding */ TRANSITION_SPEED),\n/* harmony export */   \"VISIBILITY_TOGGLE_CHANCE\": () => (/* binding */ VISIBILITY_TOGGLE_CHANCE),\n/* harmony export */   \"blinkChance\": () => (/* binding */ blinkChance),\n/* harmony export */   \"chineseSpeechTexts\": () => (/* binding */ chineseSpeechTexts),\n/* harmony export */   \"gifSize\": () => (/* binding */ gifSize),\n/* harmony export */   \"palettes\": () => (/* binding */ palettes),\n/* harmony export */   \"pixelSize\": () => (/* binding */ pixelSize),\n/* harmony export */   \"speechTexts\": () => (/* binding */ speechTexts)\n/* harmony export */ });\nconst pixelSize = 5;\nconst blinkChance = 0.1;\nconst gifSize = 64;\nconst MIN_PIXEL_SPEED = 200;\nconst MAX_PIXEL_SPEED = 300;\nconst TRANSITION_SPEED = 0.002;\nconst RABBIT_SPEED = 5;\nconst MIN_STREAM_SIZE = 130;\nconst MAX_STREAM_SIZE = 250;\nconst VISIBILITY_TOGGLE_CHANCE = 0.02;\nconst SPEECH_CHANCE = 0.6;\n\nconst speechTexts = [\n  \"It's life\",\n  \"Hey!\",\n  \"Well...\",\n  \"Wait...\",\n  \"Ouch!\",\n  \"Wow!\",\n  \"Where am I?\",\n  \"Hold on\",\n  \"You there?\",\n  \"Are we lost?\",\n  \"Sorry...\",\n  \"You're crazy!\",\n  \"Who am I?\",\n  \"Hmmm\",\n  \"I'm late\",\n  \"Have fun\",\n  \"Are we real?\",\n  \"Oops...\",\n  \"Just tired\",\n  \"It's OK\",\n  \"See ya\",\n  \"Awesome!\",\n  \"Good luck!\",\n  \"Are u OK?\",\n  \"So excited\",\n  \"Haha\",\n  \"Let's go!\",\n  \"It's crazy\",\n  \"So confused\",\n  \"I see...\",\n  \"C'mon!\",\n  \"I'm here\",\n  \"Am I dreaming?\",\n  \"Remember?\",\n  \"What?\",\n  \"Wait!\",\n  \"Whatever\",\n  \"Really?\",\n  \"IDK\",\n  \"No worries!\",\n];\n\nconst chineseSpeechTexts = [\n  \"这就是生活\",\n  \"嘿！\",\n  \"嗯...\",\n  \"好的！\",\n  \"等等...\",\n  \"那是什么？\",\n  \"哎呀！\",\n  \"哇！\",\n  \"我在哪里？\",\n  \"好吧\",\n  \"你在吗？\",\n  \"我迷路了吗？\",\n  \"对不起\",\n  \"你太疯狂了！\",\n  \"我是谁？\",\n  \"嗯...\",\n  \"我迟到了\",\n  \"玩得开心\",\n  \"我是真的吗？\",\n  \"哎呀...\",\n  \"我累了\",\n  \"怎么了？\",\n  \"太棒了！\",\n  \"祝好运！\",\n  \"你还好吗？\",\n  \"好兴奋\",\n  \"哈哈\",\n  \"我们走吧！\",\n  \"太疯狂了\",\n  \"好困惑\",\n  \"想你\",\n  \"我明白了...\",\n  \"加油！\",\n  \"我在这里\",\n  \"我在做梦吗？\",\n  \"记得吗？\",\n  \"什么？\",\n  \"等等！\",\n  \"我很好\",\n  \"留在我身边\",\n  \"真的吗？\",\n  \"我不知道\",\n  \"别担心！\",\n];\n\n// Palettes\nconst palettes = [\n  [\n    [0, 255, 0],\n    [0, 200, 0],\n    [20, 60, 20],\n  ],\n  [\n    [255, 0, 0],\n    [255, 20, 147],\n    [255, 105, 180],\n    [255, 192, 203],\n  ],\n\n  [\n    [135, 206, 250],\n    [25, 25, 112],\n    [0, 0, 139],\n  ],\n  [\n    [255, 0, 0],\n    [255, 165, 0],\n    [255, 255, 0],\n    [0, 255, 0],\n    [0, 127, 255],\n    [0, 0, 255],\n    [139, 0, 255],\n  ],\n];\n\n\n//# sourceURL=webpack://particles/./src/const.js?");

  /***/ }),
  
  /***/ "./src/karma.js":
  /*!**********************!*\
    !*** ./src/karma.js ***!
    \**********************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"globalAssets\": () => (/* binding */ globalAssets)\n/* harmony export */ });\nconst { palettes, chineseSpeechTexts } = __webpack_require__(/*! ./const */ \"./src/const.js\");\nconst { Stream } = __webpack_require__(/*! ./lib/stream */ \"./src/lib/stream.js\");\nconst { GifManager } = __webpack_require__(/*! ./lib/gifManager */ \"./src/lib/gifManager.js\");\n\nlet gifManager;\nconst {\n  pixelSize,\n  MIN_PIXEL_SPEED,\n  MAX_PIXEL_SPEED,\n  TRANSITION_SPEED,\n} = __webpack_require__(/*! ./const */ \"./src/const.js\");\n\n// Create a global object to store fonts that can be accessed by other components\nconst globalAssets = {\n  arcadeFont: null,\n  chineseFont: null\n};\n\nconst sketch = (p5) => {\n  // Responsive canvas dimensions\n  let isMobile = p5.windowWidth <= 768; // Mobile breakpoint\n  \n  let canvasWidth, canvasHeight;\n  let canvasContainer = null;\n  \n  if (isMobile) {\n    // Mobile: full width and height\n    canvasWidth = p5.windowWidth;\n    canvasHeight = p5.windowHeight;\n  } else {\n    // Desktop: mobile device dimensions (e.g., iPhone 14 Pro Max)\n    const mobileAspectRatio = 19.5 / 9; // Common modern mobile aspect ratio\n    canvasHeight = p5.windowHeight;\n    canvasWidth = Math.floor(canvasHeight / mobileAspectRatio);\n    \n    // Ensure minimum width for usability\n    canvasWidth = Math.max(canvasWidth, 375); // iPhone SE width as minimum\n  }\n\n  const streams = [];\n\n  let currentPaletteIndex = 0;\n  let nextPaletteIndex = 1;\n  let transitionProgress = 0;\n  let bgColor = p5.color(0);\n  \n  // Variables for the dialogue language system\n  let languageCycleTime = 0;\n  let languageModeChineseIntensity = 0; // 0 = normal, 1 = Chinese mode fully active\n\n  // Helper functions to provide dynamic values\n  const getPaletteIndex = () => ({\n    current: currentPaletteIndex,\n    next: nextPaletteIndex,\n  });\n  const getTransitionProgress = () => transitionProgress;\n\n\n  const updateTransitionProgress = () => {\n    transitionProgress += TRANSITION_SPEED;\n    if (transitionProgress >= 1) {\n      transitionProgress = 0;\n      currentPaletteIndex = nextPaletteIndex;\n      nextPaletteIndex = (nextPaletteIndex + 1) % palettes.length;\n    }\n\n    // Gradually change background to white when using certain palettes\n    if (currentPaletteIndex === 2 || currentPaletteIndex === 3) {\n      bgColor = p5.lerpColor(bgColor, p5.color(255), 0.035);\n    } else {\n      bgColor = p5.lerpColor(bgColor, p5.color(0), 0.035);\n    }\n    \n    // Update language cycle for dialogue system\n    languageCycleTime += 0.001;\n    // Create a sine wave oscillation to control language mode intensity\n    // This makes Chinese text appear more frequently during certain periods\n    languageModeChineseIntensity = (Math.sin(languageCycleTime) + 1) / 2; // Map to 0-1 range\n    \n    // Expose globally for rabbit speech bubble system\n    window.languageModeChineseIntensity = languageModeChineseIntensity;\n    \n    // Performance optimization: Reduce Chinese text effects frequency for better performance\n    // Only render every 10th frame when intensity is high\n    if (languageModeChineseIntensity > 0.85 && p5.frameCount % 10 === 0 && p5.random() < 0.02) {\n      // Performance optimization: Group all text rendering state changes\n      p5.push();\n      p5.fill(255, 20); // More subtle for performance\n      p5.textSize(p5.random(20, 35)); // Smaller range for consistency\n      p5.textFont(chineseFont); // Use proper Chinese font\n      \n      const randomIndex = Math.floor(p5.random(chineseSpeechTexts.length));\n      const char = chineseSpeechTexts[randomIndex].charAt(0); // Just use first character\n      p5.text(char, p5.random(canvasWidth), p5.random(canvasHeight));\n      p5.pop();\n    }\n  };\n\n  let arcadeFont;\n  let chineseFont; // Font for Chinese characters\n\n  p5.preload = () => {\n    arcadeFont = p5.loadFont(\"arcade.ttf\");\n    chineseFont = p5.loadFont(\"zpix.ttf\"); // Load the Chinese font\n    \n    // Store fonts in the global object for access by other components\n    globalAssets.arcadeFont = arcadeFont;\n    globalAssets.chineseFont = chineseFont;\n  };\n\n  p5.setup = () => {\n    // Performance optimization: Set optimal frame rate and rendering settings\n    p5.frameRate(60); // Increased from 30 to 60fps for smooth HQ rendering\n    p5.pixelDensity(1); // Force pixel density to 1 for better performance\n    \n    // Create canvas with responsive dimensions\n    const canvas = p5.createCanvas(canvasWidth, canvasHeight, p5.P2D); // Use P2D renderer for better performance\n    \n    // Performance optimization: Disable right-click context menu\n    canvas.elt.oncontextmenu = () => false;\n    \n    // Center canvas on desktop\n    if (!isMobile) {\n      canvas.parent(document.body);\n      canvas.style('display', 'block');\n      canvas.style('margin', '0 auto');\n      canvas.style('position', 'relative');\n      \n      // Add some styling to the body for better presentation on desktop\n      document.body.style.margin = '0';\n      document.body.style.padding = '0';\n      document.body.style.backgroundColor = '#000';\n      document.body.style.display = 'flex';\n      document.body.style.justifyContent = 'center';\n      document.body.style.alignItems = 'center';\n      document.body.style.minHeight = '100vh';\n    }\n    \n    // Performance optimization: Set default draw settings once\n    p5.background(0);\n    p5.textFont(arcadeFont);\n    p5.noStroke(); // Default to no stroke for better performance\n    p5.textAlign(p5.LEFT, p5.BASELINE); // Set default text alignment\n    \n    // Initialize systems\n    initializeSystems();\n  };\n  \n  // Separate function to initialize systems (for reuse on resize)\n  const initializeSystems = () => {\n    const numGifs = Math.floor(canvasWidth / 6); // Optimized rabbit count for performance\n    gifManager = new GifManager(p5, numGifs, {\n      arcade: arcadeFont,\n      chinese: chineseFont\n    });\n    window.gifManager = gifManager;\n\n    // Clear existing streams\n    streams.length = 0;\n    \n    // Optimized stream creation\n    for (let x = 0; x <= canvasWidth; x += pixelSize) {\n      const speed = p5.floor(p5.random(MIN_PIXEL_SPEED, MAX_PIXEL_SPEED));\n      streams.push(\n        new Stream(p5, x, speed, getPaletteIndex, getTransitionProgress),\n      );\n    }\n  };\n\n  p5.draw = () => {\n    // Performance optimization: Cache background color\n    p5.background(bgColor);\n\n    // Fix: Always render background streams to prevent black flashing\n    for (let i = 0; i < streams.length; i++) {\n      streams[i].render();\n    }\n\n    // Update the autonomous rabbit system (minimal canvas operations)\n    gifManager.update();\n    \n    // Fix: Always render speech bubbles to prevent flashing\n    p5.push(); // Isolate speech bubble drawing state\n    p5.textFont(arcadeFont); // Ensure font is set for speech bubbles\n    gifManager.drawSpeechBubbles();\n    p5.pop();\n    \n    // Update transitions - optimized frequency\n    updateTransitionProgress();\n  };\n  \n  // Handle window resize\n  p5.windowResized = () => {\n    // Recalculate responsive dimensions\n    const wasMobile = isMobile;\n    isMobile = p5.windowWidth <= 768;\n    \n    // Update canvas dimensions\n    if (isMobile) {\n      // Mobile: full width and height\n      canvasWidth = p5.windowWidth;\n      canvasHeight = p5.windowHeight;\n    } else {\n      // Desktop: mobile device dimensions\n      const mobileAspectRatio = 19.5 / 9;\n      canvasHeight = p5.windowHeight;\n      canvasWidth = Math.floor(canvasHeight / mobileAspectRatio);\n      canvasWidth = Math.max(canvasWidth, 375);\n    }\n    \n    // Resize canvas\n    p5.resizeCanvas(canvasWidth, canvasHeight);\n    \n    // If switching between mobile/desktop modes, reinitialize systems\n    if (wasMobile !== isMobile) {\n      // Update body styling for mode switch\n      if (isMobile) {\n        document.body.style.display = 'block';\n        document.body.style.justifyContent = 'initial';\n        document.body.style.alignItems = 'initial';\n        document.body.style.minHeight = 'initial';\n      } else {\n        document.body.style.display = 'flex';\n        document.body.style.justifyContent = 'center';\n        document.body.style.alignItems = 'center';\n        document.body.style.minHeight = '100vh';\n      }\n      \n      // Reinitialize systems for new dimensions\n      if (gifManager) {\n        // Clean up existing systems\n        gifManager.cleanup?.();\n      }\n      initializeSystems();\n    }\n  };\n};\n\n// Initialize p5\nnew p5(sketch);\n\n// Export the globalAssets object\n\n\n\n//# sourceURL=webpack://particles/./src/karma.js?");
  
  /***/ }),
  
  /***/ "./src/lib/gem.js":
  /*!************************!*\
    !*** ./src/lib/gem.js ***!
    \************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gem\": () => (/* binding */ Gem)\n/* harmony export */ });\nconst {\n  gifSize,\n  RABBIT_SPEED,\n  SPEECH_CHANCE,\n  speechTexts,\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\nclass Gem {\n  constructor(p5, initialX = null, initialY = null) {\n    this.p5 = p5;\n    this.active = false;\n    \n    // Enhanced initial positioning for screen filling\n    if (initialX !== null && initialY !== null) {\n      // Use provided coordinates for initial distribution\n      this.x = initialX;\n      this.y = initialY;\n      this.nextAppearance = p5.millis() + p5.random(100, 500); // Quick initial spawn\n    } else {\n      // Random positioning for dynamic spawns - ensure immediate availability\n      this.nextAppearance = p5.millis() + p5.random(50, 300); // Faster spawning for new gems\n    }\n\n    // Movement system - same speed as rabbits for cohesive illusion\n    this.speed = RABBIT_SPEED;\n\n    this.baseY = 0;\n    this.floatOffset = 13;\n    this.floatStep = 1;\n    this.floatDirection = 1;\n    this.floatDelay = 150 + this.p5.random(50);\n    this.lastFloatTime = 0;\n    this.allSame = null;\n    this.unificationEndTime = null; // Mathematical unification end time - no setTimeout\n    this.origSrc;\n    \n    // Pure mathematical identity for each gem\n    this.mathSeed = Math.random();\n    this.chaosX = Math.random() * 1000;\n    this.chaosY = Math.random() * 1000;\n    this.gemIndex = Math.floor(Math.random() * 1000);\n    \n    // Optimized mathematical wave parameters - simplified for performance\n    this.timeScale = p5.random(0.0001, 0.0002); // Reduced frequency range\n    this.spaceScale = p5.random(0.005, 0.01); // Reduced range\n    this.phaseOffset = p5.random(0, 6.28318); // Pre-computed 2π\n    this.frequencyModulator = p5.random(0.9, 1.1); // Reduced range\n    \n    // Extreme mathematical parameters - simplified\n    this.extremeFreq = p5.random(0.00002, 0.00004);\n    this.extremePhase = p5.random(0, 6.28318);\n    this.extremeAmplitude = p5.random(0.7, 1.3);\n    \n    // Flash mathematical identity - optimized\n    this.flashSeed = Math.random();\n    this.flashFreq = p5.random(0.0015, 0.0025); // Increased for more visible flashing\n    this.flashPhase = p5.random(0, 6.28318);\n    \n    // Performance optimization: Update frequency control\n    this.lastMathUpdate = 0;\n    this.mathUpdateInterval = 120; // Update expensive calculations every 120ms\n    this.lastDOMUpdate = 0;\n    this.domUpdateInterval = 60; // DOM updates max ~16fps\n    this.lastTypeUpdate = 0;\n    this.typeUpdateInterval = 200; // Type changes max 5fps\n    \n    // Cached calculations\n    this.cachedFlashOpacity = 0.7;\n    this.cachedType = null;\n    this.lastX = this.x;\n    this.lastY = this.y;\n    \n    this.currentType = null;\n  }\n\n  setAllSame(type) {\n    this.allSame = type;\n    \n    // Mathematical duration calculation - no setTimeout\n    const currentTime = this.p5.millis();\n    const extremeIntensity = Math.max(0, Math.sin(currentTime * this.extremeFreq + this.extremePhase));\n    const duration = 400 + (extremeIntensity * 1100); // 400-1500ms based on math\n    \n    // Store when unification should end mathematically\n    this.unificationEndTime = currentTime + duration;\n  }\n\n  // Get global wave-based type\n  getWaveType() {\n    return window.globalCollectibleType || null;\n  }\n\n  spawn(existingGems, rabbitRows, rabbits = []) {\n    // Optimized spawn with reduced attempt count for performance\n    let attempts = 0;\n    const maxAttempts = 15; // Reduced from 30 for faster spawning\n    const minDistance = gifSize * 0.7; // Slightly reduced for more spawning success\n    const rabbitAvoidanceDistance = gifSize * 1.2; // Reduced for performance\n    const speechBalloonAvoidanceDistance = gifSize * 1.5; // Reduced\n\n    do {\n      // Enhanced positioning with grid-based distribution for better screen filling\n      if (this.x === undefined || this.y === undefined) {\n        // Grid-based initial positioning for better distribution\n        const gridCols = Math.floor(this.p5.width / (gifSize * 1.5));\n        const gridRows = Math.floor(this.p5.height / (gifSize * 1.5));\n        \n        const gridX = (existingGems.length % gridCols) + this.p5.random(-0.3, 0.3);\n        const gridY = Math.floor(existingGems.length / gridCols) % gridRows + this.p5.random(-0.3, 0.3);\n        \n        this.x = (gridX * gifSize * 1.5) + gifSize + this.p5.random(-gifSize * 0.3, gifSize * 0.3);\n        this.y = (gridY * gifSize * 1.5) + gifSize + this.p5.random(-gifSize * 0.3, gifSize * 0.3);\n        \n        // Ensure within screen bounds\n        this.x = Math.max(gifSize, Math.min(this.p5.width - gifSize, this.x));\n        this.y = Math.max(gifSize, Math.min(this.p5.height - gifSize * 2, this.y));\n      } else {\n        // Extended positioning for dynamic spawns - heavily favor right edge and beyond\n        const extendedWidth = this.p5.width + (gifSize * 8); // Much larger extension\n        const rightBias = this.p5.random() < 0.7; // 70% chance to spawn on right side/beyond\n        \n        if (rightBias) {\n          // Spawn from right 30% of screen to well beyond right edge\n          this.x = this.p5.random(this.p5.width * 0.7, extendedWidth);\n        } else {\n          // Occasionally spawn elsewhere for variety\n          this.x = this.p5.random(gifSize, this.p5.width - gifSize);\n        }\n        \n        this.y = this.p5.random(gifSize, this.p5.height - gifSize * 2);\n      }\n      \n      // Optimized overlap checking - reduced complexity\n      let hasOverlap = false;\n      \n      // Check for overlap with existing gems - optimized loop\n      for (let i = 0; i < existingGems.length && !hasOverlap; i++) {\n        const gem = existingGems[i];\n        if (gem.active) {\n          const dx = gem.x - this.x;\n          const dy = gem.y - this.y;\n          const distanceSquared = dx * dx + dy * dy;\n          if (distanceSquared < minDistance * minDistance) {\n            hasOverlap = true;\n          }\n        }\n      }\n      \n      // Check for overlap with active rabbits - optimized\n      if (!hasOverlap) {\n        for (let i = 0; i < rabbits.length && !hasOverlap; i++) {\n          const rabbit = rabbits[i];\n          if (rabbit.isVisible()) {\n            const rabbitPos = rabbit.getPosition();\n            const dx = rabbitPos.x - this.x;\n            const dy = rabbitPos.y - this.y;\n            const distanceSquared = dx * dx + dy * dy;\n            \n            if (distanceSquared < rabbitAvoidanceDistance * rabbitAvoidanceDistance) {\n              hasOverlap = true;\n            }\n          }\n        }\n      }\n      \n      if (!hasOverlap) break;\n      attempts++;\n    } while (attempts < maxAttempts);\n\n    if (attempts >= maxAttempts) {\n      // If we can't find a non-overlapping spot, place it in a less crowded area\n      this.x = this.p5.random(gifSize, this.p5.width - gifSize);\n      this.y = this.p5.random(gifSize, this.p5.height - gifSize * 2);\n    }\n\n    this.active = true;\n    this.baseY = this.y; // Store base Y position\n\n    // Optimized random type selection\n    const r = this.p5.random();\n    let randImg = r < 0.3 ? \"gem.gif\" : r < 0.6 ? \"magic.gif\" : \"fire.gif\";\n\n    this.origSrc = randImg;\n\n    // Check for global wave type first, then local override\n    const globalWaveType = this.getWaveType();\n    if (globalWaveType) {\n      randImg = globalWaveType;\n    } else if (this.allSame) {\n      randImg = this.allSame;\n    } else {\n      randImg = this.origSrc;\n    }\n\n    // Optimized GIF creation with performance hints\n    this.gif = this.p5.createImg(randImg, \"gem-or-fire\");\n    const scaleFactor = (randImg === \"magic.gif\" || randImg === \"fire.gif\") ? 0.6 : 0.4;\n    this.gif.size(gifSize * scaleFactor, gifSize * scaleFactor);\n    \n    // Dynamic positioning - center the gif on the calculated coordinates\n    const actualSize = gifSize * scaleFactor;\n    this.gif.position(this.x - actualSize / 2, this.y - actualSize / 2);\n    this.gif.style(\"z-index\", \"999\");\n    this.gif.style(\"will-change\", \"transform, opacity\"); // GPU acceleration hint\n    \n    // Set initial type for wave system\n    this.currentType = randImg;\n    this.cachedType = randImg;\n  }\n\n  collect() {\n    this.active = false;\n    if (this.gif) {\n      this.gif.remove();\n      this.gif = null; // Clear reference\n    }\n    // Set next appearance with simple random delay\n    this.nextAppearance = this.p5.millis() + this.p5.random(600, 1500);\n    \n    // Reset current type to ensure fresh spawning\n    this.currentType = null;\n    this.cachedType = null;\n  }\n\n  destroy() {\n    // Complete cleanup for gem removal\n    this.active = false;\n    if (this.gif) {\n      this.gif.remove();\n      this.gif = null;\n    }\n    this.currentType = null;\n    this.cachedType = null;\n  }\n\n  isReadyForCulling() {\n    // Gem is ready for culling if it's been inactive for a while\n    return !this.active && (!this.gif || this.gif === null);\n  }\n\n  // Optimized collision detection with early exits\n  checkCollision(rabbits) {\n    if (!this.active) return;\n    \n    // Cache gem properties for mathematical collision\n    const gemHalf = gifSize * 0.2; // Simplified constant size\n    \n    // Optimized collision loop with early exit\n    for (let i = 0; i < rabbits.length; i++) {\n      const rabbit = rabbits[i];\n      if (rabbit.state !== \"alive\") continue;\n      \n      // Fast distance check first\n      const dx = Math.abs(rabbit.x - this.x);\n      const dy = Math.abs(rabbit.y - this.y);\n      \n      // Early exit if too far\n      if (dx > gifSize || dy > gifSize) continue;\n      \n      // Precise collision check\n      const rabbitHalf = gifSize * 0.5;\n      if (dx <= (rabbitHalf + gemHalf) && dy <= (rabbitHalf + gemHalf)) {\n        // Collision detected - determine type efficiently\n        if (this.gif) {\n          const src = this.gif.elt.src;\n          const gemType = src.includes(\"fire\") ? \"fire\" : \n                         src.includes(\"gem\") ? \"gem\" : \"magic\";\n          \n          rabbit.handleCollision(gemType);\n          this.collect();\n          return; // Early exit after collision\n        }\n      }\n    }\n  }\n\n  // Optimized type determination with caching\n  getTypeFromValue(typeValue) {\n    // Check for global unification type first - this takes priority during wave events\n    const globalUnifiedType = this.getWaveType();\n    if (globalUnifiedType) {\n      return globalUnifiedType;\n    }\n    \n    // Simplified type calculation for performance\n    if (typeValue < 0.33) return \"gem.gif\";\n    if (typeValue < 0.66) return \"magic.gif\";\n    return \"fire.gif\";\n  }\n\n  // Optimized type switching with reduced DOM operations\n  switchToType(newType) {\n    if (this.currentType === newType || !this.gif) return;\n    \n    // Remove current gif\n    this.gif.remove();\n    \n    // Create new gif with new type\n    this.gif = this.p5.createImg(newType, \"gem-or-fire\");\n    \n    // Optimized scale factor calculation\n    const scaleFactor = (newType.includes(\"magic\") || newType.includes(\"fire\")) ? 0.6 : 0.4;\n    this.gif.size(gifSize * scaleFactor, gifSize * scaleFactor);\n    \n    // Dynamic positioning - center the gif on coordinates\n    const actualSize = gifSize * scaleFactor;\n    this.gif.position(this.x - actualSize / 2, this.y - actualSize / 2);\n    this.gif.style(\"z-index\", \"999\");\n    this.gif.style(\"will-change\", \"transform, opacity\"); // GPU acceleration\n    \n    this.currentType = newType;\n    this.cachedType = newType;\n  }\n\n  update(rabbits, existingGems, rabbitRows) {\n    const now = this.p5.millis();\n\n    // Mathematical unification end check - no setTimeout\n    if (this.unificationEndTime && now >= this.unificationEndTime) {\n      this.allSame = null;\n      this.unificationEndTime = null;\n    }\n\n    // Performance optimization: Early exit for inactive gems\n    const shouldBeActive = now > this.nextAppearance;\n    if (!this.active && !shouldBeActive) return;\n\n    // Mathematical spawning - no conditionals  \n    if (shouldBeActive && !this.active) {\n      this.spawn(existingGems, rabbitRows, rabbits);\n      return; // Early exit after spawning\n    }\n\n    // Performance optimization: Only calculate for active gems\n    if (this.active && this.gif) {\n      // Update expensive math calculations less frequently\n      if (now - this.lastMathUpdate > this.mathUpdateInterval) {\n        this.lastMathUpdate = now;\n        \n        // Simplified flash calculation\n        const timeCache = now * 0.001;\n        this.cachedFlashOpacity = 0.7 + Math.sin(timeCache * this.flashFreq + this.flashPhase) * 0.3;\n      }\n      \n      // Update type less frequently\n      if (now - this.lastTypeUpdate > this.typeUpdateInterval) {\n        this.lastTypeUpdate = now;\n        \n        // Simplified type calculation\n        const typeValue = Math.sin(now * this.timeScale + this.mathSeed * 6.28) * 0.5 + 0.5;\n        const newType = this.allSame || this.getTypeFromValue(typeValue);\n        \n        if (newType !== this.cachedType) {\n          this.switchToType(newType);\n        }\n      }\n      \n      // Always update position (cheap operation)\n      this.x -= this.speed * 0.125;\n      \n      // Optimized wrap-around check\n      if (this.x < -gifSize) {\n        this.x = this.p5.width + gifSize;\n      }\n      \n      // Simplified floating Y position\n      const timeCache = now * 0.001;\n      this.y = this.baseY + Math.sin(timeCache * 2 + this.mathSeed * 6.28) * this.floatOffset * 0.6;\n      \n      // Throttle DOM updates for performance\n      if (now - this.lastDOMUpdate > this.domUpdateInterval || \n          Math.abs(this.x - this.lastX) > 3 || Math.abs(this.y - this.lastY) > 1) {\n        \n        this.lastDOMUpdate = now;\n        this.lastX = this.x;\n        this.lastY = this.y;\n        \n        // Batch DOM operations\n        const scaleFactor = this.currentType && (this.currentType.includes(\"magic\") || this.currentType.includes(\"fire\")) ? 0.6 : 0.4;\n        const halfSize = (gifSize * scaleFactor) * 0.5;\n        \n        this.gif.style(\"opacity\", this.cachedFlashOpacity.toFixed(2));\n        this.gif.position(\n          Math.round(this.x - halfSize), \n          Math.round(this.y - halfSize)\n        );\n      }\n\n      // Optimized collision detection (only for active gems)\n      this.checkCollision(rabbits);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/gem.js?");
  
  /***/ }),
  
  /***/ "./src/lib/gifElement.js":
  /*!*******************************!*\
    !*** ./src/lib/gifElement.js ***!
    \*******************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GifElement\": () => (/* binding */ GifElement)\n/* harmony export */ });\nconst { gifSize, speechTexts, chineseSpeechTexts, RABBIT_SPEED } = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\n// Animation duration constant - optimized for 60fps\nconst ANIMATION_DURATION = 600; // Reduced from 800ms for snappier feel\n\n// Simple elegant parameters for optimal mathematical chaos\nconst CHAOS_PARAMS = {\n  timeScale: 0.0003,         // How fast time flows through the chaos\n  spaceScale: 0.008,         // Spatial noise scale for detailed patterns\n  threshold: 0.7,           // Balanced threshold for good visibility distribution\n  displayBase: 800,         // Base animation timing (visual only)\n  displayChaos: 1000         // Animation variation (visual only)\n};\n\n// Expose for real-time tuning\nwindow.RABBIT_CHAOS_PARAMS = CHAOS_PARAMS;\n\nclass GifElement {\n  constructor(p5, x, y, fonts = {}) {\n    this.p5 = p5;\n    this.originalSrc = p5.random() < 0.5 ? \"rabbit-white.gif\" : \"rabbit-orange.gif\";\n    this.x = x;\n    this.y = y;\n    this.speed = RABBIT_SPEED;\n    \n    this.state = \"hidden\";\n    this.isActive = false;\n    \n    // Pure mathematical identity - each rabbit is a unique point in mathematical space\n    this.chaosX = Math.random() * 1000;\n    this.chaosY = Math.random() * 1000;\n    this.mathSeed = Math.random(); // Individual mathematical seed [0,1]\n    this.rabbitIndex = Math.floor(Math.random() * 1000); // Unique index for spacing\n    \n    // Timing for visual transitions only\n    this.spawnTime = 0;\n    this.fadeInStartTime = 0;\n    this.fadeOutStartTime = 0;\n    this.displayDuration = 0; // No longer used for logic decisions\n    \n    // Mathematical collision effect system - no timeouts\n    this.collisionStartTime = 0;\n    this.collisionDuration = 600; // Optimized duration\n    this.collisionType = 'normal';\n    \n    // Performance optimization: Update frequency control\n    this.lastMathUpdate = 0;\n    this.mathUpdateInterval = 100; // Update expensive math every 100ms only\n    this.cachedShouldExist = false;\n    this.lastVisualUpdate = 0;\n    this.visualUpdateInterval = 33; // ~30fps for visual updates\n    \n    // Position optimization\n    this.lastDOMUpdate = 0;\n    this.domUpdateInterval = 50; // DOM updates max 20fps\n    this.lastX = this.x;\n    this.lastY = this.y;\n    \n    // Only 50% of rabbits get speech balloons\n    this.hasSpeechBalloon = p5.random() < 0.5;\n    this.speechSystem = this.hasSpeechBalloon ? new SpeechBubbleSystem(p5, fonts) : null;\n    this.createGifLayers();\n  }\n\n  // Optimized existence calculation - cached result\n  shouldExist(currentTime) {\n    // Only recalculate expensive math periodically\n    if (currentTime - this.lastMathUpdate > this.mathUpdateInterval) {\n      this.lastMathUpdate = currentTime;\n      \n      const t = currentTime * CHAOS_PARAMS.timeScale;\n      \n      // Optimized noise calculation - fewer layers\n      const primaryChaos = this.p5.noise(\n        this.chaosX * CHAOS_PARAMS.spaceScale,\n        this.chaosY * CHAOS_PARAMS.spaceScale,\n        t\n      );\n      \n      // Mathematical baseline using individual rabbit identity - simplified\n      const individualPhase = this.mathSeed * 6.28318; // Pre-computed 2π\n      const baselineWave = Math.sin(t * 0.3 + individualPhase) * 0.5 + 0.5;\n      \n      // Simplified personality calculation\n      const personality = Math.sin(t * 1.7 + this.mathSeed * 7.3) * 0.1;\n      \n      // Combine layers - optimized\n      const finalExistence = primaryChaos * 0.8 + baselineWave * 0.4 + personality;\n      \n      this.cachedShouldExist = finalExistence > CHAOS_PARAMS.threshold;\n    }\n    \n    return this.cachedShouldExist;\n  }\n\n  // Remove the time-based duration calculation - use pure mathematical modulation instead\n  calculateChaosDisplayDuration(currentTime) {\n    // This is no longer used for time-based logic, but kept for visual effects\n    return CHAOS_PARAMS.displayBase + Math.random() * CHAOS_PARAMS.displayChaos;\n  }\n\n  createGifLayers() {\n    try {\n    // Create container div for all GIF layers\n    this.container = this.p5.createDiv('');\n    this.container.position(this.x - gifSize / 2, this.y - gifSize / 2);\n    this.container.size(gifSize, gifSize);\n    this.container.style('position', 'absolute');\n      this.container.style('z-index', '1000'); // Higher than collectibles\n      this.container.style('will-change', 'transform, opacity'); // GPU acceleration hint\n    \n    // Create all GIF layers stacked on top of each other\n    this.gifs = {\n      normal: this.p5.createImg(this.originalSrc, \"rabbit\"),\n      damage: this.p5.createImg(\"rabbit-damage.gif\", \"rabbit-damage\"),\n      glitch: this.p5.createImg(\"rabbit-glitch.gif\", \"rabbit-glitch\"),\n      spell: this.p5.createImg(\"rabbit-spell.gif\", \"rabbit-spell\"),\n      error: this.p5.createImg(\"err.gif\", \"rabbit-error\")\n    };\n    \n    // Style each GIF layer with performance optimizations\n    Object.values(this.gifs).forEach(gif => {\n      gif.parent(this.container);\n      gif.size(gifSize, gifSize);\n      gif.style('position', 'absolute');\n      gif.style('top', '0');\n      gif.style('left', '0');\n        gif.style('transition', 'none');\n        gif.style('will-change', 'opacity'); // GPU acceleration\n      gif.style('opacity', '0');\n    });\n    \n    this.gifs.normal.style('opacity', '1');\n    this.currentGif = 'normal';\n    this.container.hide();\n    } catch (error) {\n      console.error('Error creating GIF layers:', error);\n      this.state = \"error\";\n    }\n  }\n\n  // Cleanup method - no timeout management needed\n  cleanup() {\n    try {\n      // Remove all GIF elements\n      if (this.gifs) {\n        Object.values(this.gifs).forEach(gif => {\n          if (gif && gif.remove) {\n            gif.remove();\n          }\n        });\n      }\n      \n      // Remove container\n      if (this.container && this.container.remove) {\n        this.container.remove();\n      }\n      \n      // Reset speech system\n      if (this.speechSystem) {\n        this.speechSystem.cleanup();\n      }\n      \n    } catch (error) {\n      console.error('Error during cleanup:', error);\n    }\n  }\n\n  // Mathematical collision handling - no timeouts\n  handleCollision(itemType) {\n    if (this.state !== \"alive\") return;\n\n    try {\n      // Mathematical collision effect mapping\n      const gifMap = {\n        fire: 'damage',\n        gem: 'glitch', \n        magic: 'spell'\n      };\n      \n      const newGif = gifMap[itemType] || 'normal';\n      \n      // Start mathematical collision effect\n      this.collisionStartTime = this.p5.millis();\n      this.collisionType = newGif;\n      this.switchToGif(newGif);\n      \n    } catch (error) {\n      console.error('Error handling collision:', error);\n    }\n  }\n\n  update() {\n    try {\n    const now = this.p5.millis();\n    \n      // Mathematical collision effect update - no timeouts\n      this.updateCollisionEffect(now);\n      \n      // Core mathematical state decision - cached and less frequent\n      const shouldBeVisible = this.shouldExist(now);\n      const currentlyVisible = this.state !== \"hidden\";\n      \n      // Simple state machine based on mathematical existence\n      if (shouldBeVisible && !currentlyVisible) {\n        // Math says exist, but we're hidden -> start appearing\n        this.transitionToVisible(now);\n      } else if (!shouldBeVisible && currentlyVisible) {\n        // Math says don't exist, but we're visible -> start disappearing  \n        this.transitionToHidden(now);\n      }\n      \n      // Optimized visual transitions - less frequent updates\n      if (now - this.lastVisualUpdate > this.visualUpdateInterval) {\n        this.lastVisualUpdate = now;\n        this.updateVisualTransition(now);\n      }\n      \n      // Always update position and speech when not hidden - but optimized\n    if (this.state !== \"hidden\") {\n      if (this.speechSystem) {\n      this.speechSystem.update(this.x, this.y);\n      }\n      this.updatePosition(now);\n    }\n    } catch (error) {\n      console.error('Error in rabbit update:', error);\n      this.resetToHidden(now);\n    }\n  }\n\n  // Mathematical collision effect system - replaces setTimeout\n  updateCollisionEffect(now) {\n    if (this.collisionStartTime > 0) {\n      const elapsed = now - this.collisionStartTime;\n      \n      // Mathematical effect completion check\n      if (elapsed >= this.collisionDuration) {\n        // Effect complete - return to normal\n        this.collisionStartTime = 0;\n        this.collisionType = 'normal';\n        if (this.state === \"alive\") {\n          this.switchToGif('normal');\n        }\n      }\n      // Effect continues automatically via mathematical duration\n    }\n  }\n\n  setState(newState) {\n    if (this.state !== newState) {\n      this.state = newState;\n    }\n  }\n\n  // Robust transition to visible state\n  transitionToVisible(now) {\n    if (this.state === \"hidden\") {\n      this.setState(\"spawning\");\n      this.spawnTime = now;\n      this.fadeInStartTime = now;\n      this.displayDuration = this.calculateChaosDisplayDuration(now);\n      \n      // Reset position and prepare visual elements\n      this.resetPosition();\n      if (this.speechSystem) {\n        this.speechSystem.reset();\n        this.speechSystem.isActive = true;\n        this.speechSystem.generateNewText();\n        this.speechSystem.opacity = 0;\n      }\n      \n      this.container.show();\n      this.switchToGif('normal');\n      this.container.style(\"opacity\", \"0\");\n    }\n  }\n\n  // Robust transition to hidden state\n  transitionToHidden(now) {\n    if (this.state === \"alive\") {\n      this.setState(\"dying\");\n      this.fadeOutStartTime = now;\n      this.switchToGif('normal');\n    }\n  }\n\n  // Optimized visual transition handler with reduced DOM operations\n  updateVisualTransition(now) {\n    if (this.state === \"spawning\") {\n      const elapsed = now - this.fadeInStartTime;\n      const progress = Math.min(elapsed / ANIMATION_DURATION, 1.0);\n    \n    if (progress >= 1.0) {\n        // Fade in complete\n        this.setState(\"alive\");\n        this.isActive = true;\n        this.container.style(\"opacity\", \"1\");\n        if (this.speechSystem) {\n          this.speechSystem.opacity = 255;\n        }\n    } else {\n        // Continue fade in - optimized easing\n        const easeProgress = progress * progress * (3 - 2 * progress); // Smooth step\n        this.container.style(\"opacity\", easeProgress.toFixed(2));\n        if (this.speechSystem) {\n          this.speechSystem.opacity = easeProgress * 255;\n        }\n      }\n    } else if (this.state === \"dying\") {\n      const elapsed = now - this.fadeOutStartTime;\n      const progress = Math.min(elapsed / ANIMATION_DURATION, 1.0);\n      \n      if (progress >= 1.0) {\n        // Fade out complete\n        this.resetToHidden(now);\n    } else {\n        // Continue fade out - optimized easing\n        const easeProgress = 1 - (progress * progress * (3 - 2 * progress));\n      this.container.style(\"opacity\", easeProgress.toFixed(2));\n        if (this.speechSystem) {\n      this.speechSystem.opacity = easeProgress * 255;\n        }\n      }\n    }\n  }\n\n  // Optimized reset to hidden state - no timeout clearing needed\n  resetToHidden(now) {\n    this.setState(\"hidden\");\n    this.isActive = false;\n    \n    // Clean visual state\n    if (this.container) {\n    this.container.style(\"opacity\", \"0\");\n        this.container.hide();\n      }\n    \n    // Reset speech system\n    if (this.speechSystem) {\n    this.speechSystem.reset();\n    }\n    \n    // Reset collision effects\n    this.collisionStartTime = 0;\n    this.collisionType = 'normal';\n  }\n\n  resetPosition() {\n    try {\n      // Generate new random position with bounds checking\n      const cols = Math.max(1, Math.floor(this.p5.width / gifSize));\n      const rows = Math.max(1, Math.floor(this.p5.height / gifSize));\n    \n    const col = Math.floor(this.p5.random(cols));\n      const minRow = Math.max(0, Math.floor(rows * 0.05));\n      const maxRow = Math.min(rows - 1, Math.floor(rows * 0.95));\n      const row = Math.floor(this.p5.random(minRow, maxRow + 1));\n      \n      this.x = col * gifSize + gifSize / 2;\n      this.y = row * gifSize + gifSize / 2;\n      \n      // Bounds checking\n      this.x = Math.max(gifSize / 2, Math.min(this.p5.width - gifSize / 2, this.x));\n      this.y = Math.max(gifSize / 2, Math.min(this.p5.height - gifSize / 2, this.y));\n    } catch (error) {\n      console.error('Error in resetPosition:', error);\n      // Fallback to center\n      this.x = this.p5.width / 2;\n      this.y = this.p5.height / 2;\n    }\n  }\n\n  // Optimized position updates with reduced DOM operations\n  updatePosition(now) {\n    try {\n      // Simple horizontal movement\n      this.x += this.speed;\n      \n      // Wrap around screen\n      if (this.x > this.p5.width + gifSize / 2) {\n        this.x = -gifSize / 2;\n      }\n      \n      // Throttle DOM updates for performance\n      if (now - this.lastDOMUpdate > this.domUpdateInterval || \n          Math.abs(this.x - this.lastX) > 2 || Math.abs(this.y - this.lastY) > 2) {\n        \n        this.lastDOMUpdate = now;\n        this.lastX = this.x;\n        this.lastY = this.y;\n        \n        // Update container position with bounds checking\n        const newX = Math.max(-gifSize, Math.min(this.p5.width, this.x - gifSize / 2));\n        const newY = Math.max(-gifSize, Math.min(this.p5.height, this.y - gifSize / 2));\n        \n        this.container.position(newX, newY);\n      }\n    } catch (error) {\n      console.error('Error updating position:', error);\n    }\n  }\n\n  // Optimized GIF switching with reduced DOM churn\n  switchToGif(gifType) {\n    try {\n      if (this.currentGif !== gifType && this.gifs && this.gifs[gifType]) {\n        // Batch DOM operations\n        const updates = [];\n        Object.keys(this.gifs).forEach(key => {\n          if (this.gifs[key] && this.gifs[key].style) {\n            updates.push({ gif: this.gifs[key], opacity: key === gifType ? '1' : '0' });\n          }\n        });\n        \n        // Apply all updates at once\n        updates.forEach(({ gif, opacity }) => {\n          gif.style('opacity', opacity);\n        });\n        \n      this.currentGif = gifType;\n      }\n    } catch (error) {\n      console.error('Error switching GIF:', error);\n    }\n  }\n\n  // Public getters\n  getState() { return this.state; }\n  isAlive() { return this.state === \"alive\"; }\n  isVisible() { return this.state !== \"hidden\" && this.state !== \"error\"; }\n  getPosition() { return { x: this.x, y: this.y }; }\n  \n  // Public method for speech bubble rendering\n  drawSpeechBubble() {\n    try {\n      if (this.speechSystem && this.speechSystem.opacity > 0) {\n      this.speechSystem.draw(this.x, this.y);\n      }\n    } catch (error) {\n      console.error('Error drawing speech bubble:', error);\n    }\n  }\n}\n\n// High-Performance Speech Bubble System - optimized rendering\nclass SpeechBubbleSystem {\n  constructor(p5, fonts) {\n    this.p5 = p5;\n    this.fonts = fonts;\n    \n    // Mathematical text change parameters - no intervals\n    this.textChangeMathSeed = Math.random();\n    this.textChangeFrequency = p5.random(0.0001, 0.0003); // Slower frequency for less CPU\n    this.lastTextMathValue = 0;\n    this.textIndex = 0;\n    \n    // Performance optimization: Cache expensive calculations\n    this.lastRenderUpdate = 0;\n    this.renderUpdateInterval = 100; // Update visual calculations every 100ms\n    this.cachedBubbleData = null;\n    \n    this.reset();\n  }\n\n  reset() {\n    this.isActive = false;\n    this.opacity = 0;\n    this.speechText = \"\";\n    this.useChineseText = this.p5.random() < 0.3;\n    this.spawnTime = this.p5.millis(); // Track when this system was activated\n    this.cachedBubbleData = null; // Clear cache on reset\n  }\n\n  cleanup() {\n    // Clean up any resources if needed\n    this.reset();\n  }\n\n  generateNewText() {\n    try {\n      // Mathematical language selection using global intensity\n      const globalLanguageIntensity = window.languageModeChineseIntensity || 0;\n      const mathLanguageBoost = Math.sin(this.p5.millis() * 0.0003 + this.textChangeMathSeed * 6.28) * 0.3;\n      const totalChineseChance = Math.min(0.8, 0.2 + globalLanguageIntensity * 0.4 + mathLanguageBoost);\n      \n      this.useChineseText = this.p5.random() < totalChineseChance;\n      this.speechText = this.useChineseText\n        ? chineseSpeechTexts[Math.floor(this.p5.random(chineseSpeechTexts.length))]\n        : speechTexts[Math.floor(this.p5.random(speechTexts.length))];\n      \n      // Clear cached data when text changes\n      this.cachedBubbleData = null;\n    } catch (error) {\n      console.error('Error generating speech text:', error);\n      this.speechText = \"...\";\n      this.useChineseText = false;\n    }\n  }\n\n  update(x, y) {\n    if (!this.isActive) return;\n    \n    try {\n      const now = this.p5.millis();\n      const timeSinceSpawn = now - this.spawnTime;\n      \n      // Mathematical text change trigger - no intervals\n      const textChangeMath = Math.sin(timeSinceSpawn * this.textChangeFrequency + this.textChangeMathSeed * 6.28);\n      const textChangeThreshold = 0.95; // High threshold for infrequent changes\n      \n      // Mathematical text change detection - crossing threshold triggers change\n      if (textChangeMath > textChangeThreshold && this.lastTextMathValue <= textChangeThreshold) {\n        this.generateNewText();\n      }\n      \n      this.lastTextMathValue = textChangeMath;\n    } catch (error) {\n      console.error('Error updating speech system:', error);\n    }\n  }\n\n  draw(x, y) {\n    if (this.opacity <= 0) return;\n    \n    try {\n      // P5.js optimization: Cache frequently used values\n    const drawOpacity = Math.max(0, Math.min(255, this.opacity));\n    const textPadding = 10;\n    \n      // P5.js optimization: Minimize font switches and calculations\n    if (this.useChineseText && this.fonts.chinese) {\n      this.p5.textFont(this.fonts.chinese);\n    } else if (this.fonts.arcade) {\n      this.p5.textFont(this.fonts.arcade);\n      }\n      this.p5.textSize(14);\n      \n      // P5.js optimization: Cache expensive textWidth calculation\n      if (!this._cachedTextWidth || this._lastText !== this.speechText) {\n        this._cachedTextWidth = this.p5.textWidth(this.speechText) + textPadding * 2;\n        this._lastText = this.speechText;\n      }\n      const textWidth = this._cachedTextWidth;\n      \n      // P5.js optimization: Use constants for static values\n    const textHeight = 30;\n    const tailSize = 8;\n    const radius = 8;\n    const bubbleX = x + 2;\n    const bubbleY = y - (this.useChineseText ? 10 : 20);\n\n      // P5.js optimization: Cache colors and minimize shadow operations\n      if (!this._cachedColors) {\n        this._cachedColors = {\n          bubble: this.p5.color(255),\n          text: this.p5.color(0)\n        };\n      }\n      \n      // P5.js optimization: Only set shadow if needed, minimize context changes\n      this.p5.drawingContext.shadowBlur = 3;\n      this.p5.drawingContext.shadowColor = 'rgba(0, 0, 0, 0.2)';\n      // P5.js optimization: Use cached colors and minimize fill/stroke calls\n      this.p5.fill(255, 255, 255, drawOpacity);\n    this.p5.stroke(0, drawOpacity);\n      this.p5.strokeWeight(2);\n    this.p5.beginShape();\n    this.p5.vertex(bubbleX + radius, bubbleY - textHeight);\n    this.p5.quadraticVertex(bubbleX, bubbleY - textHeight, bubbleX, bubbleY - textHeight + radius);\n    this.p5.vertex(bubbleX, bubbleY - radius);\n    this.p5.quadraticVertex(bubbleX, bubbleY, bubbleX + radius, bubbleY);\n    this.p5.vertex(bubbleX + 10, bubbleY);\n    this.p5.vertex(bubbleX + 7, bubbleY + tailSize);\n    this.p5.vertex(bubbleX + 20, bubbleY);\n    this.p5.vertex(bubbleX + textWidth - radius, bubbleY);\n    this.p5.quadraticVertex(bubbleX + textWidth, bubbleY, bubbleX + textWidth, bubbleY - radius);\n    this.p5.vertex(bubbleX + textWidth, bubbleY - textHeight + radius);\n    this.p5.quadraticVertex(bubbleX + textWidth, bubbleY - textHeight, bubbleX + textWidth - radius, bubbleY - textHeight);\n    this.p5.endShape(this.p5.CLOSE);\n\n      // P5.js optimization: Clear shadow efficiently and batch text operations\n    this.p5.drawingContext.shadowBlur = 0;\n\n      // P5.js optimization: Batch text drawing state changes\n      this.p5.fill(0, 0, 0, drawOpacity);\n    this.p5.noStroke();\n    this.p5.textAlign(this.p5.CENTER, this.p5.CENTER);\n      \n      // P5.js optimization: Reduce conditional calculations\n      const textY = bubbleY - (textHeight * 0.5) + (this.useChineseText ? -2 : 0);\n      this.p5.text(this.speechText, bubbleX + (textWidth * 0.5), textY);\n    } catch (error) {\n      console.error('Error drawing speech bubble:', error);\n    }\n  }\n} \n\n//# sourceURL=webpack://particles/./src/lib/gifElement.js?");
  
  /***/ }),
  
  /***/ "./src/lib/gifManager.js":
  /*!*******************************!*\
    !*** ./src/lib/gifManager.js ***!
    \*******************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GifManager\": () => (/* binding */ GifManager)\n/* harmony export */ });\nconst {\n  gifSize,\n  speechTexts,\n  chineseSpeechTexts\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\nconst { GifElement } = __webpack_require__(/*! ./gifElement */ \"./src/lib/gifElement.js\");\nconst { Gem } = __webpack_require__(/*! ./gem */ \"./src/lib/gem.js\");\n\nclass GifManager {\n  constructor(p5, numGifs, fonts = { arcade: null, chinese: null }) {\n    this.p5 = p5;\n    this.numGifs = numGifs;\n    this.gifElements = [];\n    this.fonts = fonts;\n    \n    // Create individual autonomous rabbit instances\n    this.createGifs();\n    \n    // Global frequency wave for system-wide effects\n    this.globalWave = new GlobalFrequencyWave(p5);\n    \n    // Initialize gems array with dynamic wave system\n    this.gems = [];\n    this.populationWaveSystem = new DynamicPopulationWave(p5);\n    \n    // Initialize collectible flow system\n    this.collectibleFlowSystem = new CollectibleFlowSystem(p5);\n    \n    // Create initial gems with distributed positioning for screen filling\n    this.createInitialGems();\n    \n    this.lastPopulationUpdateTime = p5.millis();\n    this.populationUpdateInterval = 1000;\n    \n    // Performance optimization: Cached calculations and reduced update frequencies\n    this._cachedVisibleRabbits = null;\n    this._cachedAliveRabbits = null;\n    this._cachedRabbitRows = null;\n    this.lastRabbitCacheUpdate = 0;\n    this.rabbitCacheInterval = 100; // Update rabbit cache every 100ms\n    \n    this.lastCleanupTime = 0;\n    this.cleanupInterval = 5000; // Cleanup every 5 seconds\n    \n    this.lastStatusLogTime = 0;\n    this.statusLogInterval = 30000; // Log status every 30 seconds\n  }\n\n  createGifs() {\n    const canvasWidth = this.p5.width;\n    const canvasHeight = this.p5.height;\n    \n    // Create autonomous rabbit instances distributed across the screen\n    for (let i = 0; i < this.numGifs; i++) {\n      // Distribute rabbits across the width\n      const x = (i * (canvasWidth / this.numGifs)) + this.p5.random(-10, 10);\n      \n      // Better Y distribution - avoid top and bottom areas (middle 60% of screen)\n      const minY = canvasHeight * 0.05;\n      const maxY = canvasHeight * 0.95;\n      const y = this.p5.random(minY, maxY);\n      \n      const rabbit = new GifElement(this.p5, x, y, this.fonts);\n      this.gifElements.push(rabbit);\n    }\n  }\n\n  createInitialGems() {\n    const canvasWidth = this.p5.width;\n    const canvasHeight = this.p5.height;\n    \n    // Calculate optimal grid for screen filling with much larger right-edge extension\n    const gemSpacing = gifSize * 1.8; // Spacing between gems\n    const extendedWidth = canvasWidth + (gemSpacing * 10); // Much larger extension beyond right edge\n    const gridCols = Math.floor(extendedWidth / gemSpacing);\n    const gridRows = Math.floor((canvasHeight - gifSize * 2) / gemSpacing); // Account for top/bottom margins\n    \n    // Create gems in a distributed grid pattern extending beyond screen\n    const totalGridSlots = gridCols * gridRows;\n    const initialGemCount = Math.min(Math.floor(this.p5.random(105, 120)), Math.floor(totalGridSlots * 0.85)); // Start with very dense screen flow\n    \n    // Create array of all possible grid positions\n    const gridPositions = [];\n    for (let row = 0; row < gridRows; row++) {\n      for (let col = 0; col < gridCols; col++) {\n        gridPositions.push({ col, row });\n      }\n    }\n    \n    // Shuffle positions for random but distributed placement\n    for (let i = gridPositions.length - 1; i > 0; i--) {\n      const j = Math.floor(this.p5.random() * (i + 1));\n      [gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]];\n    }\n    \n    // Create gems at selected grid positions, favoring right side for natural flow\n    for (let i = 0; i < initialGemCount; i++) {\n      const { col, row } = gridPositions[i];\n      \n      // Calculate position with slight randomization, starting from right edge\n      const baseX = col * gemSpacing + gemSpacing / 2;\n      const baseY = row * gemSpacing + gemSpacing / 2 + gifSize; // Add top margin\n      \n      const x = baseX + this.p5.random(-gemSpacing * 0.2, gemSpacing * 0.2);\n      const y = baseY + this.p5.random(-gemSpacing * 0.2, gemSpacing * 0.2);\n      \n      // Allow gems to spawn well beyond right edge of screen for natural flow\n      const clampedX = Math.max(-gifSize * 2, Math.min(extendedWidth, x)); // Allow more off-screen spawning on both sides\n      const clampedY = Math.max(gifSize, Math.min(canvasHeight - gifSize * 2, y));\n      \n      this.gems.push(new Gem(this.p5, clampedX, clampedY));\n    }\n  }\n\n  update() {\n    const now = this.p5.millis();\n    \n    // Update global frequency wave\n    this.globalWave.update();\n    \n    // Update collectible flow system\n    this.collectibleFlowSystem.update();\n    \n    // Optimized rabbit updates - no array operations\n    for (let i = 0; i < this.gifElements.length; i++) {\n      this.gifElements[i].update();\n    }\n    \n    // Update gems with optimized caching\n    this.updateGems(now);\n    \n    // Conditional operations based on time intervals\n    if (now - this.lastStatusLogTime > this.statusLogInterval) {\n      this.lastStatusLogTime = now;\n      this.logSystemStatus();\n    }\n  }\n\n  updateGems(now) {\n    // Update cached rabbit data less frequently\n    if (now - this.lastRabbitCacheUpdate > this.rabbitCacheInterval) {\n      this.lastRabbitCacheUpdate = now;\n      this.updateRabbitCache();\n    }\n    \n    // Update gem population based on wave (less frequently for performance)\n    if (this.p5.frameCount % 3 === 0) { // Every 3rd frame instead of every other\n      this.updateGemPopulation(now);\n    }\n    \n    // Optimized gem updates - no array operations\n    for (let i = 0; i < this.gems.length; i++) {\n      this.gems[i].update(this._cachedVisibleRabbits, this.gems, this._cachedRabbitRows);\n    }\n    \n    // Periodic cleanup to prevent leftovers\n    if (now - this.lastCleanupTime > this.cleanupInterval) {\n      this.lastCleanupTime = now;\n      this.performMaintenanceCleanup(now);\n    }\n  }\n\n  // Optimized rabbit data caching\n  updateRabbitCache() {\n    this._cachedVisibleRabbits = [];\n    this._cachedRabbitRows = new Set();\n    \n    // Single pass to build both caches\n    for (let i = 0; i < this.gifElements.length; i++) {\n      const rabbit = this.gifElements[i];\n      if (rabbit.isVisible()) {\n        this._cachedVisibleRabbits.push(rabbit);\n        \n        const pos = rabbit.getPosition();\n        const rowIndex = Math.floor(pos.y / gifSize) * gifSize;\n        this._cachedRabbitRows.add(rowIndex);\n      }\n    }\n    \n    this._cachedRabbitRows = Array.from(this._cachedRabbitRows);\n  }\n\n  performMaintenanceCleanup(now) {\n    let removedCount = 0;\n    let activeCount = 0;\n    \n    // Single pass cleanup with manual loop for performance\n    let i = 0;\n    while (i < this.gems.length) {\n      const gem = this.gems[i];\n      const isActive = gem.active;\n      const hasGif = gem.gif && gem.gif !== null;\n      const timeDelta = gem.nextAppearance ? (now - gem.nextAppearance) : 0;\n      const isStale = timeDelta > 60000;\n      \n      // Cleanup decision\n      if (!isActive && (!hasGif || isStale)) {\n        gem.destroy();\n        this.gems.splice(i, 1); // Remove element\n        removedCount++;\n        // Don't increment i since we removed an element\n      } else {\n        if (isActive) activeCount++;\n        i++; // Move to next element\n      }\n    }\n  }\n\n  updateGemPopulation(now) {\n    // Update wave system every frame for smooth dynamics\n    this.populationWaveSystem.update();\n    \n    // Check if it's time for population update\n    if (now - this.lastPopulationUpdateTime < this.populationUpdateInterval) {\n      return; // Early exit if not time yet\n    }\n    \n    this.lastPopulationUpdateTime = now;\n    \n    const { targetGemCount, spawnBurst, cullRate } = this.populationWaveSystem.getPopulationData();\n    \n    // Apply unification population boost\n    const unificationBoost = window.globalUnificationPopulationBoost || 1.0;\n    const boostedTargetCount = Math.floor(targetGemCount * unificationBoost);\n    \n    const currentGemCount = this.gems.length;\n    const gemDelta = boostedTargetCount - currentGemCount;\n    \n    // Optimized spawning\n    if (gemDelta > 0) {\n      const deltaAbs = Math.abs(gemDelta);\n      const baseSpawnAmount = Math.ceil(deltaAbs * spawnBurst);\n      \n      // Mathematical unification boost\n      const unificationFactor = unificationBoost > 1.5 ? 1 : 0;\n      const unificationSpeedBoost = 1.0 + unificationFactor;\n      const spawnAmount = Math.floor(baseSpawnAmount * unificationSpeedBoost);\n      const spawnChunks = Math.min(spawnAmount, Math.max(1, Math.floor(spawnAmount * 0.5)));\n      \n      // Create new gems in batch\n      for (let i = 0; i < spawnChunks; i++) {\n        this.gems.push(new Gem(this.p5));\n      }\n    }\n    \n    // Optimized culling\n    if (gemDelta < -3) {\n      const deltaAbs = Math.abs(gemDelta);\n      const gemsToRemove = Math.floor(deltaAbs * cullRate);\n      let removedCount = 0;\n      \n      // Manual loop for performance\n      let i = 0;\n      while (i < this.gems.length && removedCount < gemsToRemove) {\n        const gem = this.gems[i];\n        const isReadyForCull = gem.isReadyForCulling();\n        const isActive = gem.active;\n        \n        // Removal priority calculation\n        const removalWeight = (!isActive ? 1 : 0) + (isActive ? 0.5 : 0);\n        const shouldRemove = Math.random() < removalWeight * 0.3;\n        \n        if (shouldRemove) {\n          if (isReadyForCull) {\n            gem.destroy();\n            this.gems.splice(i, 1);\n            removedCount++;\n            // Don't increment i\n          } else if (isActive) {\n            gem.collect();\n            this.gems.splice(i, 1);\n            removedCount++;\n            // Don't increment i\n          } else {\n            i++;\n          }\n        } else {\n          i++;\n        }\n      }\n    }\n    \n    // Mathematical population flow - optimized\n    const populationDeficit = Math.max(0, 75 - this.gems.length);\n    if (populationDeficit > 0) {\n      const flowNoise = Math.abs(this.p5.noise(now * 0.00001 + 5000)) * 0.8 + 0.2;\n      const surgeNoise = Math.abs(this.p5.noise(now * 0.00003 + 6000)) * 0.5;\n      \n      const mathematicalSpawn = Math.floor(populationDeficit * flowNoise * (0.6 + surgeNoise));\n      for (let i = 0; i < mathematicalSpawn; i++) {\n        this.gems.push(new Gem(this.p5));\n      }\n    }\n  }\n\n  logSystemStatus() {\n    // Optimized status calculation\n    let visibleRabbits = 0, aliveRabbits = 0, hiddenRabbits = 0;\n    for (let i = 0; i < this.gifElements.length; i++) {\n      const r = this.gifElements[i];\n      if (r.isVisible()) visibleRabbits++;\n      if (r.isAlive()) aliveRabbits++;\n      if (r.getState() === \"hidden\") hiddenRabbits++;\n    }\n    \n    // Safety check for collectible flow system\n    if (!this.collectibleFlowSystem || typeof this.collectibleFlowSystem.getUnificationInfo !== 'function') {\n      return;\n    }\n    \n    const unificationInfo = this.collectibleFlowSystem.getUnificationInfo();\n    const currentState = this.collectibleFlowSystem.getCurrentState();\n  }\n\n  // Public interface for drawing speech bubbles (called from main loop)\n  drawSpeechBubbles() {\n    // Optimized speech bubble rendering\n    for (let i = 0; i < this.gifElements.length; i++) {\n      this.gifElements[i].drawSpeechBubble();\n    }\n  }\n\n  // Optimized public getters with caching\n  getVisibleRabbits() {\n    return this._cachedVisibleRabbits || [];\n  }\n\n  getAliveRabbits() {\n    // Calculate alive rabbits from cached visible rabbits\n    if (!this._cachedAliveRabbits && this._cachedVisibleRabbits) {\n      this._cachedAliveRabbits = [];\n      for (let i = 0; i < this._cachedVisibleRabbits.length; i++) {\n        if (this._cachedVisibleRabbits[i].isAlive()) {\n          this._cachedAliveRabbits.push(this._cachedVisibleRabbits[i]);\n        }\n      }\n    }\n    return this._cachedAliveRabbits || [];\n  }\n\n  getAllRabbits() {\n    return this.gifElements;\n  }\n\n  getSystemInfo() {\n    const visible = this.getVisibleRabbits().length;\n    const alive = this.getAliveRabbits().length;\n    \n    return {\n      total: this.numGifs,\n      visible,\n      alive,\n      hidden: this.numGifs - visible,\n      globalWaveIntensity: this.globalWave.getIntensity()\n    };\n  }\n}\n\n// Unified Type Wave System - normally random types, occasional wave unification\nclass CollectibleFlowSystem {\n  constructor(p5) {\n    this.p5 = p5;\n    \n    // Wave system for occasional type unification - faster for shorter events\n    this.unificationWave = {\n      frequency: 0.0004, // Faster wave for shorter, more frequent events\n      amplitude: 1.0,\n      phase: p5.random(0, Math.PI * 2)\n    };\n    \n    this.breathingWave = {\n      frequency: 0.0002,\n      amplitude: 0.3,\n      phase: p5.random(0, Math.PI * 2)\n    };\n    \n    // Wave intensity calculation\n    this.waveIntensity = 0;\n    this.smoothedIntensity = 0;\n    \n    // Unification state\n    this.isUnified = false;\n    this.unificationThreshold = 0.88; // Higher threshold for shorter, punchier events\n    this.unificationStrength = 0; // 0-1, how strongly unified\n    this.currentUnifiedType = null;\n    \n    // Faster smoothing for quicker transitions\n    this.smoothingFactor = 0.985; // Less smoothing for faster response\n    \n    // Type rotation for unification events\n    this.typeRotation = [\"gem.gif\", \"fire.gif\", \"magic.gif\"];\n    this.currentTypeIndex = 0;\n    \n    // Population boost during unification\n    this.unificationPopulationMultiplier = 6.0; // 6x more collectibles during unified events for maximum screen filling\n    \n    // Initialize global state - null means random types\n    window.globalCollectibleType = null;\n    window.globalUnificationStrength = 0;\n    window.globalUnificationPopulationBoost = 1.0;\n    \n    \n  }\n\n  update() {\n    const time = this.p5.millis();\n    \n    // Calculate unification wave intensity\n    this.calculateUnificationWave(time);\n    \n    // Update unification state\n    this.updateUnificationState();\n    \n    // Apply smooth transitions\n    this.applySmoothing();\n  }\n\n  calculateUnificationWave(time) {\n    // Calculate unification wave\n    const unificationRaw = Math.sin(time * this.unificationWave.frequency + this.unificationWave.phase);\n    const breathingRaw = Math.sin(time * this.breathingWave.frequency + this.breathingWave.phase);\n    \n    // Combine waves - breathing adds variation to unification timing\n    const combinedWave = unificationRaw + (breathingRaw * 0.3);\n    \n    // Normalize to 0-1 range\n    const normalizedWave = (combinedWave + 1.3) / 2.6; // Account for breathing wave addition\n    this.waveIntensity = Math.max(0, Math.min(1, normalizedWave));\n  }\n\n  updateUnificationState() {\n    // Check if wave crosses unification threshold\n    if (this.waveIntensity > this.unificationThreshold && !this.isUnified) {\n      // Start unification event\n      this.isUnified = true;\n      this.currentTypeIndex = (this.currentTypeIndex + 1) % this.typeRotation.length;\n      this.currentUnifiedType = this.typeRotation[this.currentTypeIndex];\n      \n      const typeName = this.currentUnifiedType.replace('.gif', '').toUpperCase();\n      \n      \n    } else if (this.waveIntensity < this.unificationThreshold && this.isUnified) {\n      // End unification event\n      this.isUnified = false;\n      this.currentUnifiedType = null;\n      \n    }\n    \n    // Calculate unification strength for smooth transitions\n    if (this.isUnified) {\n      // When unified, strength ramps up based on how far above threshold we are\n      const overThreshold = this.waveIntensity - this.unificationThreshold;\n      const strengthRange = 1.0 - this.unificationThreshold;\n      this.unificationStrength = Math.min(1.0, overThreshold / strengthRange);\n    } else {\n      // When not unified, strength ramps down\n      this.unificationStrength = 0;\n  }\n  }\n\n  applySmoothing() {\n    // Apply faster transitions to unification strength\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.unificationStrength * (1 - this.smoothingFactor);\n    \n    // Calculate population boost based on unification strength\n    const populationBoost = 1.0 + (this.smoothedIntensity * (this.unificationPopulationMultiplier - 1.0));\n    \n    // Update global state for gems to use - faster thresholds for quicker response\n    if (this.isUnified && this.smoothedIntensity > 0.05) {\n      // When unified and strength is significant, set global type (lower threshold for faster start)\n      window.globalCollectibleType = this.currentUnifiedType;\n    } else if (!this.isUnified && this.smoothedIntensity < 0.15) {\n      // When not unified and strength is minimal, clear global type (higher threshold for faster end)\n      window.globalCollectibleType = null;\n    }\n    \n    // Update global unification strength and population boost\n    window.globalUnificationStrength = this.smoothedIntensity;\n    window.globalUnificationPopulationBoost = populationBoost;\n}\n\n  // Public getters for monitoring\n  getUnificationInfo() {\n    return {\n      isUnified: this.isUnified,\n      unificationStrength: this.smoothedIntensity,\n      currentType: this.currentUnifiedType,\n      rawWaveIntensity: this.waveIntensity,\n      phase: this.isUnified ? \"UNIFIED\" : \"RANDOM\"\n    };\n  }\n\n  getIntensity() {\n    return this.smoothedIntensity;\n  }\n\n  getCurrentState() {\n    return this.isUnified ? `UNIFIED_${this.currentUnifiedType?.replace('.gif', '').toUpperCase()}` : \"RANDOM_TYPES\";\n  }\n}\n\n// Smooth Global Wave System with organic flow\nclass GlobalFrequencyWave {\n  constructor(p5) {\n    this.p5 = p5;\n    this.phase = p5.random(0, Math.PI * 2);\n    this.frequency = 0.000015; // Ultra slow frequency for very gradual changes\n    this.amplitude = 1.0;\n    this.intensity = 0.5;\n    this.smoothedIntensity = 0.5;\n    this.targetIntensity = 0.5;\n    \n    // Smoothing system for ultra-smooth transitions\n    this.smoothingFactor = 0.98; // High smoothing for gentle changes\n    this.lastUpdateTime = 0;\n    this.deltaAccumulator = 0;\n    \n    // Organic wave components for natural feeling\n    this.baseWave = { frequency: 0.000012, amplitude: 0.7, phase: p5.random(0, Math.PI * 2) };\n    this.breathWave = { frequency: 0.000008, amplitude: 0.3, phase: p5.random(0, Math.PI * 2) };\n    this.driftWave = { frequency: 0.000025, amplitude: 0.2, phase: p5.random(0, Math.PI * 2) };\n    \n    // Expose to global scope for rabbit coordination\n    window.globalRabbitWaveIntensity = 0.5;\n  }\n\n  update() {\n    const time = this.p5.millis();\n    const deltaTime = time - this.lastUpdateTime;\n    this.lastUpdateTime = time;\n    \n    // Calculate multiple organic wave layers\n    const baseValue = Math.sin(time * this.baseWave.frequency + this.baseWave.phase) * this.baseWave.amplitude;\n    const breathValue = Math.sin(time * this.breathWave.frequency + this.breathWave.phase) * this.breathWave.amplitude;\n    const driftValue = Math.sin(time * this.driftWave.frequency + this.driftWave.phase) * this.driftWave.amplitude;\n    \n    // Combine waves with organic weighting\n    const rawWave = baseValue + breathValue * 0.6 + driftValue * 0.4;\n    \n    // Apply smooth easing curve for more natural feeling\n    const normalizedWave = (rawWave + 1) / 2; // 0-1 range\n    const easedWave = this.smoothEasing(normalizedWave);\n    \n    // Ultra-smooth interpolation to target\n    this.targetIntensity = easedWave;\n    const lerpFactor = Math.min(deltaTime * 0.0008, 0.05); // Very slow lerp\n    this.intensity = this.p5.lerp(this.intensity, this.targetIntensity, lerpFactor);\n    \n    // Additional smoothing layer for glass-smooth transitions\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.intensity * (1 - this.smoothingFactor);\n    \n    // Update global intensity with smoothed value\n    window.globalRabbitWaveIntensity = this.smoothedIntensity;\n    \n    // Gentle activity periods with smooth transitions\n    if (this.smoothedIntensity > 0.75) {\n      window.globalSpawnBoost = 1.0 + (this.smoothedIntensity - 0.75) * 2; // Gradual boost\n    } else if (this.smoothedIntensity < 0.25) {\n      window.globalSpawnBoost = 0.3 + this.smoothedIntensity * 2.8; // Gradual reduction\n    } else {\n      window.globalSpawnBoost = 1.0;\n    }\n  }\n\n  // Smooth easing function for natural wave curves\n  smoothEasing(t) {\n    // Combination of ease-in-out curves for organic feeling\n    const easeInOut = t * t * (3 - 2 * t); // Smooth step\n    const gentleCurve = Math.sin(t * Math.PI * 0.5); // Gentle sine curve\n    return easeInOut * 0.7 + gentleCurve * 0.3;\n  }\n\n  getIntensity() {\n    return this.smoothedIntensity;\n  }\n\n  getPeriodInfo() {\n    if (this.smoothedIntensity > 0.8) return \"HIGH ACTIVITY\";\n    if (this.smoothedIntensity < 0.2) return \"LOW ACTIVITY\";\n    return \"NORMAL ACTIVITY\";\n  }\n}\n\n// Ultra-Smooth Population Wave System\nclass DynamicPopulationWave {\n  constructor(p5) {\n    this.p5 = p5;\n    \n    // Multiple organic wave layers with ultra-slow frequencies\n    this.tideWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000012, // Ultra-slow tide-like changes\n      amplitude: 1.2,\n      smoothValue: 0\n    };\n    \n    this.currentWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000035, // Slow flowing current\n      amplitude: 0.8,\n      smoothValue: 0\n    };\n    \n    this.pulseWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000055, // Gentle pulse\n      amplitude: 0.4,\n      smoothValue: 0\n    };\n    \n    // Smooth interpolation system\n    this.intensity = 0.5;\n    this.smoothedIntensity = 0.5;\n    this.targetIntensity = 0.5;\n    this.smoothingFactor = 0.995; // Ultra-high smoothing\n    this.lastUpdateTime = 0;\n    \n    // Population parameters - super dense screen flow system\n    this.minGems = 80; // Very high minimum for rich screen density\n    this.maxGems = 130; // Higher maximum for dramatic abundance surges\n    this.basePopulation = 105; // Dense baseline for consistently full screen flow\n    \n    // Gentle surge system\n    this.lastSurgeTime = 0;\n    this.surgeCooldown = 45000; // Much longer - 45 seconds between surges\n    this.surgeIntensity = 0;\n    this.surgeDecay = 0.99; // Slow surge decay\n  }\n\n  update() {\n    const time = this.p5.millis();\n    const deltaTime = time - this.lastUpdateTime;\n    this.lastUpdateTime = time;\n    \n    // Calculate each wave layer with individual smoothing\n    this.updateWaveLayer(this.tideWave, time);\n    this.updateWaveLayer(this.currentWave, time);\n    this.updateWaveLayer(this.pulseWave, time);\n    \n    // Combine smoothed wave layers with organic weighting\n    const combinedWave = (\n      this.tideWave.smoothValue * this.tideWave.amplitude +\n      this.currentWave.smoothValue * this.currentWave.amplitude * 0.7 +\n      this.pulseWave.smoothValue * this.pulseWave.amplitude * 0.4\n    ) / (this.tideWave.amplitude + this.currentWave.amplitude * 0.7 + this.pulseWave.amplitude * 0.4);\n    \n    // Apply gentle organic curve\n    const normalizedWave = (combinedWave + 1) / 2;\n    const organicCurve = this.organicEasing(normalizedWave);\n    \n    // Ultra-smooth interpolation\n    this.targetIntensity = organicCurve;\n    const lerpFactor = Math.min(deltaTime * 0.0005, 0.02);\n    this.intensity = this.p5.lerp(this.intensity, this.targetIntensity, lerpFactor);\n    \n    // Additional smoothing for glass-smooth transitions\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.intensity * (1 - this.smoothingFactor);\n    \n    // Gentle surge system - much less aggressive\n    this.updateSurgeSystem(time);\n    \n    // Final intensity with gentle surge influence\n    this.finalIntensity = Math.min(1.0, this.smoothedIntensity + this.surgeIntensity * 0.2);\n  }\n\n  updateWaveLayer(wave, time) {\n    const rawValue = Math.sin(time * wave.frequency + wave.phase);\n    // Individual smoothing for each wave layer\n    wave.smoothValue = wave.smoothValue * 0.98 + rawValue * 0.02;\n  }\n\n  updateSurgeSystem(time) {\n    // Decay existing surge gently\n    this.surgeIntensity *= this.surgeDecay;\n    \n    // Very gentle surge triggers\n    const timeSinceLastSurge = time - this.lastSurgeTime;\n    const surgeReady = timeSinceLastSurge > this.surgeCooldown;\n    const surgeChance = this.p5.random() < 0.008; // Very low chance\n    \n    if (surgeReady && surgeChance && this.smoothedIntensity > 0.6) {\n      this.lastSurgeTime = time;\n      this.surgeIntensity = Math.min(0.3, this.p5.random(0.1, 0.25)); // Gentle surge\n      \n    }\n  }\n\n  // Organic easing for natural population curves\n  organicEasing(t) {\n    // Multiple curve layers for organic feeling\n    const smooth1 = t * t * (3 - 2 * t);\n    const smooth2 = Math.sin(t * Math.PI * 0.5);\n    const smooth3 = 1 - Math.pow(1 - t, 1.6);\n    return smooth1 * 0.4 + smooth2 * 0.3 + smooth3 * 0.3;\n  }\n\n  getPopulationData() {\n    // Super abundant wave system - extremely high most of the time\n    const primaryWave = Math.abs(this.p5.noise(this.p5.millis() * 0.00002 + 1000)) * 0.1 + 0.9; // [0.9, 1.0] - extremely high baseline\n    const intensityWave = Math.abs(this.p5.noise(this.p5.millis() * 0.00005 + 2000)) * 0.15 + 0.85; // [0.85, 1.0] - strong intensity booster\n    const surgeWave = Math.pow(Math.abs(this.p5.noise(this.p5.millis() * 0.0001 + 3000)), 2) * 0.2 + 0.8; // [0.8, 1.0] - powerful surge peaks\n    \n    // Very rare valley calculation - exponential curve for extremely rare drops\n    const valleyNoise = this.p5.noise(this.p5.millis() * 0.000008 + 5000); // Slower frequency for rarer valleys\n    const valleyTrigger = Math.pow(Math.max(0, -valleyNoise), 4); // Fourth power for extremely rare, sharp valleys\n    const valleyIntensity = valleyTrigger * 0.4; // Reduced maximum valley depth (40% vs 60%)\n    \n    // Combined super abundant wave - extremely high with very rare valleys\n    const waveIntensity = (primaryWave * intensityWave * surgeWave) - valleyIntensity;\n    const intensityFloor = 0.85 + (waveIntensity * 0.15); // Mathematical range [0.85, 1.0] with very rare dips to ~0.45\n    \n    // Pure mathematical population calculation - no conditionals\n    const populationRange = this.maxGems - this.minGems;\n    const targetGemCount = Math.floor(this.minGems + (intensityFloor * populationRange));\n    \n    // Intense spawn behavior - higher rates for dramatic waves\n    const spawnNoise = Math.abs(this.p5.noise(this.p5.millis() * 0.00008 + 4000));\n    const spawnBurst = 0.3 + (spawnNoise * 0.5); // [0.3, 0.8] - more aggressive spawning\n    const cullRate = (1 - intensityFloor) * 0.2; // More aggressive culling during valleys\n    \n    return {\n      targetGemCount,\n      spawnBurst,\n      cullRate\n    };\n  }\n\n  getIntensity() {\n    return this.finalIntensity;\n  }\n\n  getPopulationInfo() {\n    const { targetGemCount } = this.getPopulationData();\n    return {\n      intensity: this.finalIntensity,\n      targetPopulation: targetGemCount,\n      phase: this.finalIntensity > 0.75 ? 'FLOWING' : \n             this.finalIntensity < 0.25 ? 'CALM' : 'GENTLE'\n    };\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/gifManager.js?");
  
  /***/ }),
  
  /***/ "./src/lib/pixel.js":
  /*!**************************!*\
    !*** ./src/lib/pixel.js ***!
    \**************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pixel\": () => (/* binding */ Pixel)\n/* harmony export */ });\nconst { palettes, pixelSize } = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\nclass Pixel {\n  constructor(p5, x, y, getPaletteIndex, getTransitionProgress) {\n    this.p5 = p5;\n    this.x = x;\n    this.y = y;\n    this.color = p5.color(0, 255, 0);\n    this.opacity = p5.random(50, 255);\n\n    // Functions to retrieve global values dynamically\n    this.getPaletteIndex = getPaletteIndex;\n    this.getTransitionProgress = getTransitionProgress;\n  }\n\n  updateColor() {\n    const { current, next } = this.getPaletteIndex(); // Get dynamic palette index\n    const transitionProgress = this.getTransitionProgress(); // Get dynamic transition progress\n\n    const fromPalette = palettes[current];\n    const toPalette = palettes[next];\n    const fromColor = this.p5.color(\n      ...fromPalette[Math.floor(this.p5.random(fromPalette.length))]\n    );\n    const toColor = this.p5.color(\n      ...toPalette[Math.floor(this.p5.random(toPalette.length))]\n    );\n\n    // Smoothly transition between colors\n    this.color = this.p5.lerpColor(fromColor, toColor, transitionProgress);\n  }\n\n  display() {\n    this.p5.fill(\n      this.color.levels[0],\n      this.color.levels[1],\n      this.color.levels[2],\n      this.opacity\n    );\n    this.p5.noStroke();\n    this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/pixel.js?");
  
  /***/ }),
  
  /***/ "./src/lib/stream.js":
  /*!***************************!*\
    !*** ./src/lib/stream.js ***!
    \***************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stream\": () => (/* binding */ Stream)\n/* harmony export */ });\nconst {\n  MIN_STREAM_SIZE,\n  MAX_STREAM_SIZE,\n  pixelSize,\n  blinkChance,\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\nconst { Pixel } = __webpack_require__(/*! ./pixel */ \"./src/lib/pixel.js\");\n\nclass Firework {\n  constructor(p5) {\n    this.p5 = p5;\n    this.reset(); // Initialize firework properties\n  }\n\n  reset() {\n    this.x = this.p5.random(this.p5.width);\n    this.y = this.p5.random(this.p5.height / 2); // Appear randomly in the sky\n    this.stage = 0; // Controls expansion stages\n    this.opacity = 255; // Fully visible at start\n    this.active = true; // If it's currently visible\n    this.pattern = Math.floor(this.p5.random(1, 4)); // Different expansion patterns\n    this.lifetime = this.p5.millis() + this.p5.random(800, 2000); // Short lifespan\n  }\n\n  update() {\n    if (!this.active) return;\n\n    const now = this.p5.millis();\n    if (now > this.lifetime) {\n      this.active = false; // Disappear after time\n      if (this.p5.random() < 0.005) {\n        this.reset(); // Small chance to reappear randomly\n      }\n      return;\n    }\n\n    this.stage += 1; // Expand every update\n    this.opacity -= 10; // Gradually fade out\n  }\n\n  display() {\n    if (!this.active) return;\n\n    this.p5.fill(255, this.opacity);\n    this.p5.noStroke();\n\n    // **Stage 1: Single Pixel (Initial Flash)**\n    if (this.stage < 3) {\n      this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n    }\n\n    // **Stage 2: Small Expansion (4 surrounding pixels)**\n    else if (this.stage < 6) {\n      this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n      this.p5.rect(this.x - pixelSize, this.y, pixelSize, pixelSize);\n      this.p5.rect(this.x + pixelSize, this.y, pixelSize, pixelSize);\n      this.p5.rect(this.x, this.y - pixelSize, pixelSize, pixelSize);\n      this.p5.rect(this.x, this.y + pixelSize, pixelSize, pixelSize);\n    }\n\n    // **Stage 3: Full Expansion Based on Pattern**\n    else if (this.stage < 9) {\n      if (this.pattern === 1) {\n        // **Cross Pattern**\n        this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x, this.y - pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x, this.y + pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize * 2, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize * 2, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x, this.y - pixelSize * 2, pixelSize, pixelSize);\n        this.p5.rect(this.x, this.y + pixelSize * 2, pixelSize, pixelSize);\n      } else if (this.pattern === 2) {\n        // **Square Expansion**\n        for (let dx = -pixelSize; dx <= pixelSize; dx += pixelSize) {\n          for (let dy = -pixelSize; dy <= pixelSize; dy += pixelSize) {\n            this.p5.rect(this.x + dx, this.y + dy, pixelSize, pixelSize);\n          }\n        }\n      } else {\n        // **Diagonal Burst**\n        this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize, this.y - pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize, this.y + pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize, this.y + pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize, this.y - pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize * 2, this.y - pixelSize * 2, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize * 2, this.y + pixelSize * 2, pixelSize, pixelSize);\n      }\n    }\n  }\n}\n\nclass Stream {\n  constructor(p5, x, speed, getPaletteIndex, getTransitionProgress) {\n    this.p5 = p5;\n    this.pixels = [];\n    this.fireworks = []; // Array for occasional pixel fireworks\n    this.totalPixels = Math.floor(p5.random(MIN_STREAM_SIZE, MAX_STREAM_SIZE));\n    this.speed = speed;\n    this.headIndex = Math.floor(p5.random(this.totalPixels));\n    this.lastUpdate = p5.millis();\n    this.getPaletteIndex = getPaletteIndex;\n    this.getTransitionProgress = getTransitionProgress;\n    \n    // Horizontal movement for parallax effect\n    this.x = x;\n    this.horizontalSpeed = -0.5; // Slow leftward drift for background parallax\n\n    this.generatePixels(x);\n    //this.generateFireworks(); // Create firework effects\n  }\n\n  generatePixels(x) {\n    for (let i = 0; i < this.totalPixels; i++) {\n      this.pixels.push(\n        new Pixel(\n          this.p5,\n          x,\n          i * pixelSize,\n          this.getPaletteIndex,\n          this.getTransitionProgress,\n        ),\n      );\n    }\n  }\n\n  updateHorizontalPosition() {\n    // Move the entire stream horizontally for parallax effect\n    this.x += this.horizontalSpeed;\n    \n    // Wrap around screen when stream moves off the left edge\n    if (this.x < -pixelSize) {\n      this.x = this.p5.width + pixelSize;\n    }\n    \n    // Update all pixel positions in this stream\n    this.pixels.forEach(pixel => {\n      pixel.x = this.x;\n    });\n    \n    // Update firework positions too\n    this.fireworks.forEach(firework => {\n      if (firework.active) {\n        firework.x += this.horizontalSpeed;\n        // Wrap fireworks too\n        if (firework.x < -pixelSize) {\n          firework.x = this.p5.width + pixelSize;\n        }\n      }\n    });\n  }\n\n  generateFireworks() {\n    const fireworkCount = 50; // Very rare appearance\n    for (let i = 0; i < fireworkCount; i++) {\n      this.fireworks.push(new Firework(this.p5));\n    }\n  }\n\n  update() {\n    const now = this.p5.millis();\n    if (now - this.lastUpdate >= this.speed) {\n      this.headIndex = (this.headIndex + 1) % this.totalPixels;\n      this.lastUpdate = now;\n\n      for (let i = 0; i < this.pixels.length; i++) {\n        const distance =\n          (this.headIndex - i + this.totalPixels) % this.totalPixels;\n\n        this.pixels[i].opacity =\n          distance === 0\n            ? 255\n            : this.p5.map(distance, 1, this.totalPixels / 2, 255, 0);\n\n        if (this.p5.random() < blinkChance) {\n          this.pixels[i].opacity = this.p5.random(50, 255);\n        }\n\n        this.pixels[i].updateColor();\n      }\n    }\n\n    // Update fireworks\n    this.fireworks.forEach((firework) => firework.update());\n  }\n\n  render() {\n    // **🌊 Step 0: Update horizontal position for parallax effect**\n    this.updateHorizontalPosition();\n    \n    // **🟡 Step 1: Draw Fireworks Behind Stream**\n    this.fireworks.forEach((firework) => firework.display());\n\n    // **🟢 Step 2: Draw Stream Pixels on Top**\n    this.update();\n    this.pixels.forEach((pixel) => pixel.display());\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/stream.js?");
  
  /***/ })
  
  /******/ 	});
  /************************************************************************/
  /******/ 	// The module cache
  /******/ 	var __webpack_module_cache__ = {};
  /******/ 	
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/ 		// Check if module is in cache
  /******/ 		var cachedModule = __webpack_module_cache__[moduleId];
  /******/ 		if (cachedModule !== undefined) {
  /******/ 			return cachedModule.exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = __webpack_module_cache__[moduleId] = {
  /******/ 			// no module.id needed
  /******/ 			// no module.loaded needed
  /******/ 			exports: {}
  /******/ 		};
  /******/ 	
  /******/ 		// Execute the module function
  /******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
  /******/ 	
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/ 	
  /************************************************************************/
  /******/ 	/* webpack/runtime/define property getters */
  /******/ 	(() => {
  /******/ 		// define getter functions for harmony exports
  /******/ 		__webpack_require__.d = (exports, definition) => {
  /******/ 			for(var key in definition) {
  /******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
  /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
  /******/ 				}
  /******/ 			}
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/hasOwnProperty shorthand */
  /******/ 	(() => {
  /******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/make namespace object */
  /******/ 	(() => {
  /******/ 		// define __esModule on exports
  /******/ 		__webpack_require__.r = (exports) => {
  /******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 			}
  /******/ 			Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /************************************************************************/
  /******/ 	
  /******/ 	// startup
  /******/ 	// Load entry module and return exports
  /******/ 	// This entry module can't be inlined because the eval devtool is used.
  /******/ 	var __webpack_exports__ = __webpack_require__("./src/karma.js");
  /******/ 	
  /******/ })()
  ;