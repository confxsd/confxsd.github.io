/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/const.js":
/*!**********************!*\
  !*** ./src/const.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MAX_PIXEL_SPEED\": () => (/* binding */ MAX_PIXEL_SPEED),\n/* harmony export */   \"MAX_STREAM_SIZE\": () => (/* binding */ MAX_STREAM_SIZE),\n/* harmony export */   \"MIN_PIXEL_SPEED\": () => (/* binding */ MIN_PIXEL_SPEED),\n/* harmony export */   \"MIN_STREAM_SIZE\": () => (/* binding */ MIN_STREAM_SIZE),\n/* harmony export */   \"RABBIT_SPEED\": () => (/* binding */ RABBIT_SPEED),\n/* harmony export */   \"SPEECH_CHANCE\": () => (/* binding */ SPEECH_CHANCE),\n/* harmony export */   \"TRANSITION_SPEED\": () => (/* binding */ TRANSITION_SPEED),\n/* harmony export */   \"VISIBILITY_TOGGLE_CHANCE\": () => (/* binding */ VISIBILITY_TOGGLE_CHANCE),\n/* harmony export */   \"blinkChance\": () => (/* binding */ blinkChance),\n/* harmony export */   \"chineseSpeechTexts\": () => (/* binding */ chineseSpeechTexts),\n/* harmony export */   \"gifSize\": () => (/* binding */ gifSize),\n/* harmony export */   \"palettes\": () => (/* binding */ palettes),\n/* harmony export */   \"pixelSize\": () => (/* binding */ pixelSize),\n/* harmony export */   \"speechTexts\": () => (/* binding */ speechTexts)\n/* harmony export */ });\nconst pixelSize = 5;\nconst blinkChance = 0.1;\nconst gifSize = 64;\nconst MIN_PIXEL_SPEED = 200;\nconst MAX_PIXEL_SPEED = 300;\nconst TRANSITION_SPEED = 0.002;\nconst RABBIT_SPEED = 5;\nconst MIN_STREAM_SIZE = 130;\nconst MAX_STREAM_SIZE = 250;\nconst VISIBILITY_TOGGLE_CHANCE = 0.02;\nconst SPEECH_CHANCE = 0.6;\n\nconst speechTexts = [\n  \"It's life\",\n  \"Hey!\",\n  \"Well...\",\n  \"Wait...\",\n  \"Ouch!\",\n  \"Wow!\",\n  \"Where am I?\",\n  \"Hold on\",\n  \"You there?\",\n  \"Are we lost?\",\n  \"Sorry...\",\n  \"You're crazy!\",\n  \"Who am I?\",\n  \"Hmmm\",\n  \"I'm late\",\n  \"Have fun\",\n  \"Are we real?\",\n  \"Oops...\",\n  \"Just tired\",\n  \"It's OK\",\n  \"See ya\",\n  \"Awesome!\",\n  \"Good luck!\",\n  \"Are u OK?\",\n  \"So excited\",\n  \"Haha\",\n  \"Let's go!\",\n  \"It's crazy\",\n  \"So confused\",\n  \"I see...\",\n  \"C'mon!\",\n  \"I'm here\",\n  \"Am I dreaming?\",\n  \"Remember?\",\n  \"What?\",\n  \"Wait!\",\n  \"Whatever\",\n  \"Really?\",\n  \"IDK\",\n  \"No worries!\",\n];\n\nconst chineseSpeechTexts = [\n  \"è¿™å°±æ˜¯ç”Ÿæ´»\",\n  \"å˜¿ï¼\",\n  \"å—¯...\",\n  \"å¥½çš„ï¼\",\n  \"ç­‰ç­‰...\",\n  \"é‚£æ˜¯ä»€ä¹ˆï¼Ÿ\",\n  \"å“Žå‘€ï¼\",\n  \"å“‡ï¼\",\n  \"æˆ‘åœ¨å“ªé‡Œï¼Ÿ\",\n  \"å¥½å§\",\n  \"ä½ åœ¨å—ï¼Ÿ\",\n  \"æˆ‘è¿·è·¯äº†å—ï¼Ÿ\",\n  \"å¯¹ä¸èµ·\",\n  \"ä½ å¤ªç–¯ç‹‚äº†ï¼\",\n  \"æˆ‘æ˜¯è°ï¼Ÿ\",\n  \"å—¯...\",\n  \"æˆ‘è¿Ÿåˆ°äº†\",\n  \"çŽ©å¾—å¼€å¿ƒ\",\n  \"æˆ‘æ˜¯çœŸçš„å—ï¼Ÿ\",\n  \"å“Žå‘€...\",\n  \"æˆ‘ç´¯äº†\",\n  \"æ€Žä¹ˆäº†ï¼Ÿ\",\n  \"å¤ªæ£’äº†ï¼\",\n  \"ç¥å¥½è¿ï¼\",\n  \"ä½ è¿˜å¥½å—ï¼Ÿ\",\n  \"å¥½å…´å¥‹\",\n  \"å“ˆå“ˆ\",\n  \"æˆ‘ä»¬èµ°å§ï¼\",\n  \"å¤ªç–¯ç‹‚äº†\",\n  \"å¥½å›°æƒ‘\",\n  \"æƒ³ä½ \",\n  \"æˆ‘æ˜Žç™½äº†...\",\n  \"åŠ æ²¹ï¼\",\n  \"æˆ‘åœ¨è¿™é‡Œ\",\n  \"æˆ‘åœ¨åšæ¢¦å—ï¼Ÿ\",\n  \"è®°å¾—å—ï¼Ÿ\",\n  \"ä»€ä¹ˆï¼Ÿ\",\n  \"ç­‰ç­‰ï¼\",\n  \"æˆ‘å¾ˆå¥½\",\n  \"ç•™åœ¨æˆ‘èº«è¾¹\",\n  \"çœŸçš„å—ï¼Ÿ\",\n  \"æˆ‘ä¸çŸ¥é“\",\n  \"åˆ«æ‹…å¿ƒï¼\",\n];\n\n// Palettes\nconst palettes = [\n  [\n    [0, 255, 0],\n    [0, 200, 0],\n    [20, 60, 20],\n  ],\n  [\n    [255, 0, 0],\n    [255, 20, 147],\n    [255, 105, 180],\n    [255, 192, 203],\n  ],\n\n  [\n    [135, 206, 250],\n    [25, 25, 112],\n    [0, 0, 139],\n  ],\n  [\n    [255, 0, 0],\n    [255, 165, 0],\n    [255, 255, 0],\n    [0, 255, 0],\n    [0, 127, 255],\n    [0, 0, 255],\n    [139, 0, 255],\n  ],\n];\n\n\n//# sourceURL=webpack://particles/./src/const.js?");

  /***/ }),
  
  /***/ "./src/karma.js":
  /*!**********************!*\
    !*** ./src/karma.js ***!
    \**********************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"globalAssets\": () => (/* binding */ globalAssets)\n/* harmony export */ });\nconst { palettes, chineseSpeechTexts } = __webpack_require__(/*! ./const */ \"./src/const.js\");\nconst { Stream } = __webpack_require__(/*! ./lib/stream */ \"./src/lib/stream.js\");\nconst { GifManager } = __webpack_require__(/*! ./lib/gifManager */ \"./src/lib/gifManager.js\");\n\nlet gifManager;\nconst {\n  pixelSize,\n  MIN_PIXEL_SPEED,\n  MAX_PIXEL_SPEED,\n  TRANSITION_SPEED,\n} = __webpack_require__(/*! ./const */ \"./src/const.js\");\n\n// Create a global object to store fonts that can be accessed by other components\nconst globalAssets = {\n  arcadeFont: null,\n  chineseFont: null\n};\n\nconst sketch = (p5) => {\n  // Responsive canvas dimensions\n  let isMobile = p5.windowWidth <= 768; // Mobile breakpoint\n  \n  let canvasWidth, canvasHeight;\n  let canvasContainer = null;\n  \n  if (isMobile) {\n    // Mobile: full width and height\n    canvasWidth = p5.windowWidth;\n    canvasHeight = p5.windowHeight;\n  } else {\n    // Desktop: mobile device dimensions (e.g., iPhone 14 Pro Max)\n    const mobileAspectRatio = 19.5 / 9; // Common modern mobile aspect ratio\n    canvasHeight = p5.windowHeight;\n    canvasWidth = Math.floor(canvasHeight / mobileAspectRatio);\n    \n    // Ensure minimum width for usability\n    canvasWidth = Math.max(canvasWidth, 375); // iPhone SE width as minimum\n  }\n\n  const streams = [];\n\n  let currentPaletteIndex = 0;\n  let nextPaletteIndex = 1;\n  let transitionProgress = 0;\n  let bgColor = p5.color(0);\n  \n  // Variables for the dialogue language system\n  let languageCycleTime = 0;\n  let languageModeChineseIntensity = 0; // 0 = normal, 1 = Chinese mode fully active\n\n  // Helper functions to provide dynamic values\n  const getPaletteIndex = () => ({\n    current: currentPaletteIndex,\n    next: nextPaletteIndex,\n  });\n  const getTransitionProgress = () => transitionProgress;\n\n\n  const updateTransitionProgress = () => {\n    transitionProgress += TRANSITION_SPEED;\n    if (transitionProgress >= 1) {\n      transitionProgress = 0;\n      currentPaletteIndex = nextPaletteIndex;\n      nextPaletteIndex = (nextPaletteIndex + 1) % palettes.length;\n    }\n\n    // Gradually change background to white when using certain palettes\n    if (currentPaletteIndex === 2 || currentPaletteIndex === 3) {\n      bgColor = p5.lerpColor(bgColor, p5.color(255), 0.035);\n    } else {\n      bgColor = p5.lerpColor(bgColor, p5.color(0), 0.035);\n    }\n    \n    // Update language cycle for dialogue system\n    languageCycleTime += 0.001;\n    // Create a sine wave oscillation to control language mode intensity\n    // This makes Chinese text appear more frequently during certain periods\n    languageModeChineseIntensity = (Math.sin(languageCycleTime) + 1) / 2; // Map to 0-1 range\n    \n    // Expose globally for rabbit speech bubble system\n    window.languageModeChineseIntensity = languageModeChineseIntensity;\n    \n    // Every ~40 seconds there will be a peak of Chinese language probability\n    // during these peaks, emit small visual effects in the background\n    if (languageModeChineseIntensity > 0.85 && p5.random() < 0.05) { // Reduced frequency for performance\n      // P5.js optimization: Group all text rendering state changes\n      p5.push();\n      p5.fill(255, 30); // Very subtle\n      p5.textSize(p5.random(15, 40));\n      p5.textFont(chineseFont); // Use proper Chinese font\n      \n      const randomIndex = Math.floor(p5.random(chineseSpeechTexts.length));\n      const char = chineseSpeechTexts[randomIndex].charAt(0); // Just use first character\n      p5.text(char, p5.random(canvasWidth), p5.random(canvasHeight));\n      p5.pop();\n    }\n  };\n\n  let arcadeFont;\n  let chineseFont; // Font for Chinese characters\n\n  p5.preload = () => {\n    arcadeFont = p5.loadFont(\"arcade.ttf\");\n    chineseFont = p5.loadFont(\"zpix.ttf\"); // Load the Chinese font\n    \n    // Store fonts in the global object for access by other components\n    globalAssets.arcadeFont = arcadeFont;\n    globalAssets.chineseFont = chineseFont;\n  };\n\n  p5.setup = () => {\n    // P5.js optimization: Set frame rate early and disable unneeded features\n    p5.frameRate(30);\n    p5.pixelDensity(1); // Force pixel density to 1 for better performance\n    \n    // Create canvas with responsive dimensions\n    const canvas = p5.createCanvas(canvasWidth, canvasHeight, p5.P2D); // Use P2D renderer for better performance\n    \n    // P5.js optimization: Disable right-click context menu\n    canvas.elt.oncontextmenu = () => false;\n    \n    // Center canvas on desktop\n    if (!isMobile) {\n      canvas.parent(document.body);\n      canvas.style('display', 'block');\n      canvas.style('margin', '0 auto');\n      canvas.style('position', 'relative');\n      \n      // Add some styling to the body for better presentation on desktop\n      document.body.style.margin = '0';\n      document.body.style.padding = '0';\n      document.body.style.backgroundColor = '#000';\n      document.body.style.display = 'flex';\n      document.body.style.justifyContent = 'center';\n      document.body.style.alignItems = 'center';\n      document.body.style.minHeight = '100vh';\n    }\n    \n    // P5.js optimization: Set default draw settings once\n    p5.background(0);\n    p5.textFont(arcadeFont);\n    p5.noStroke(); // Default to no stroke for better performance\n    p5.textAlign(p5.LEFT, p5.BASELINE); // Set default text alignment\n    \n    // Initialize systems\n    initializeSystems();\n  };\n  \n  // Separate function to initialize systems (for reuse on resize)\n  const initializeSystems = () => {\n    const numGifs = canvasWidth / 4; // More rabbits (was /8)\n    gifManager = new GifManager(p5, numGifs, {\n      arcade: arcadeFont,\n      chinese: chineseFont\n    });\n    window.gifManager = gifManager;\n\n    // Clear existing streams\n    streams.length = 0;\n    \n    for (let x = 0; x <= canvasWidth; x += pixelSize) {\n      const speed = p5.floor(p5.random(MIN_PIXEL_SPEED, MAX_PIXEL_SPEED));\n      streams.push(\n        new Stream(p5, x, speed, getPaletteIndex, getTransitionProgress),\n      );\n    }\n  };\n\n  p5.draw = () => {\n    // P5.js optimization: Use push/pop sparingly and cache color\n    p5.background(bgColor);\n\n    // P5.js optimization: Render background streams efficiently\n    streams.forEach((stream) => stream.render());\n\n    // Update the autonomous rabbit system (minimal canvas operations)\n    gifManager.update();\n    \n    // P5.js optimization: Group canvas drawing operations\n    p5.push(); // Isolate speech bubble drawing state\n    p5.textFont(arcadeFont); // Ensure font is set for speech bubbles\n    gifManager.drawSpeechBubbles();\n    p5.pop();\n    \n    // Update transitions last to avoid unnecessary redraws\n    updateTransitionProgress();\n  };\n  \n  // Handle window resize\n  p5.windowResized = () => {\n    // Recalculate responsive dimensions\n    const wasMobile = isMobile;\n    isMobile = p5.windowWidth <= 768;\n    \n    // Update canvas dimensions\n    if (isMobile) {\n      // Mobile: full width and height\n      canvasWidth = p5.windowWidth;\n      canvasHeight = p5.windowHeight;\n    } else {\n      // Desktop: mobile device dimensions\n      const mobileAspectRatio = 19.5 / 9;\n      canvasHeight = p5.windowHeight;\n      canvasWidth = Math.floor(canvasHeight / mobileAspectRatio);\n      canvasWidth = Math.max(canvasWidth, 375);\n    }\n    \n    // Resize canvas\n    p5.resizeCanvas(canvasWidth, canvasHeight);\n    \n    // If switching between mobile/desktop modes, reinitialize systems\n    if (wasMobile !== isMobile) {\n      // Update body styling for mode switch\n      if (isMobile) {\n        document.body.style.display = 'block';\n        document.body.style.justifyContent = 'initial';\n        document.body.style.alignItems = 'initial';\n        document.body.style.minHeight = 'initial';\n      } else {\n        document.body.style.display = 'flex';\n        document.body.style.justifyContent = 'center';\n        document.body.style.alignItems = 'center';\n        document.body.style.minHeight = '100vh';\n      }\n      \n      // Reinitialize systems for new dimensions\n      if (gifManager) {\n        // Clean up existing systems\n        gifManager.cleanup?.();\n      }\n      initializeSystems();\n    }\n  };\n};\n\n// Initialize p5\nnew p5(sketch);\n\n// Export the globalAssets object\n\n\n\n//# sourceURL=webpack://particles/./src/karma.js?");
  
  /***/ }),
  
  /***/ "./src/lib/gem.js":
  /*!************************!*\
    !*** ./src/lib/gem.js ***!
    \************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gem\": () => (/* binding */ Gem)\n/* harmony export */ });\nconst {\n  gifSize,\n  RABBIT_SPEED,\n  SPEECH_CHANCE,\n  speechTexts,\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\nclass Gem {\n  constructor(p5, initialX = null, initialY = null) {\n    this.p5 = p5;\n    this.active = false;\n    \n    // Enhanced initial positioning for screen filling\n    if (initialX !== null && initialY !== null) {\n      // Use provided coordinates for initial distribution\n      this.x = initialX;\n      this.y = initialY;\n      this.nextAppearance = p5.millis() + p5.random(100, 500); // Quick initial spawn\n    } else {\n      // Random positioning for dynamic spawns - ensure immediate availability\n      this.nextAppearance = p5.millis() + p5.random(50, 300); // Faster spawning for new gems\n    }\n\n    // Movement system - same speed as rabbits for cohesive illusion\n    this.speed = RABBIT_SPEED;\n\n    this.baseY = 0;\n    this.floatOffset = 13;\n    this.floatStep = 1;\n    this.floatDirection = 1;\n    this.floatDelay = 150 + this.p5.random(50);\n    this.lastFloatTime = 0;\n    this.allSame = null;\n    this.origSrc;\n    \n    // Pure mathematical identity for each gem\n    this.mathSeed = Math.random();\n    this.chaosX = Math.random() * 1000;\n    this.chaosY = Math.random() * 1000;\n    this.gemIndex = Math.floor(Math.random() * 1000);\n    \n    // Mathematical wave parameters - no state tracking\n    this.timeScale = p5.random(0.0001, 0.0003);\n    this.spaceScale = p5.random(0.005, 0.015);\n    this.phaseOffset = p5.random(0, Math.PI * 2);\n    this.frequencyModulator = p5.random(0.8, 1.2);\n    \n    // Extreme mathematical parameters\n    this.extremeFreq = p5.random(0.00001, 0.00005);\n    this.extremePhase = p5.random(0, Math.PI * 2);\n    this.extremeAmplitude = p5.random(0.5, 1.5);\n    \n    // Flash mathematical identity\n    this.flashSeed = Math.random();\n    this.flashFreq = p5.random(0.001, 0.003);\n    this.flashPhase = p5.random(0, Math.PI * 2);\n    \n    this.currentType = null;\n  }\n\n  setAllSame(type) {\n    this.allSame = type;\n    // Mathematical duration calculation instead of conditionals\n    const currentTime = this.p5.millis();\n    const extremeIntensity = Math.max(0, Math.sin(currentTime * this.extremeFreq + this.extremePhase));\n    const duration = 400 + (extremeIntensity * 1100); // 400-1500ms based on math\n    \n    setTimeout(() => {\n      this.setAllSame(null);\n    }, duration);\n  }\n\n  // Get global wave-based type\n  getWaveType() {\n    return window.globalCollectibleType || null;\n  }\n\n  spawn(existingGems, rabbitRows, rabbits = []) {\n    let attempts = 0;\n    const maxAttempts = 30; // Increased attempts for better placement with rabbit avoidance\n    const minDistance = gifSize * 0.8; // Minimum distance from other gems\n    const rabbitAvoidanceDistance = gifSize * 1.5; // Larger distance to avoid rabbits\n    const speechBalloonAvoidanceDistance = gifSize * 2.0; // Even larger distance to avoid speech balloons\n\n    do {\n      // Enhanced positioning with grid-based distribution for better screen filling\n      if (this.x === undefined || this.y === undefined) {\n        // Grid-based initial positioning for better distribution\n        const gridCols = Math.floor(this.p5.width / (gifSize * 1.5));\n        const gridRows = Math.floor(this.p5.height / (gifSize * 1.5));\n        \n        const gridX = (existingGems.length % gridCols) + this.p5.random(-0.3, 0.3);\n        const gridY = Math.floor(existingGems.length / gridCols) % gridRows + this.p5.random(-0.3, 0.3);\n        \n        this.x = (gridX * gifSize * 1.5) + gifSize + this.p5.random(-gifSize * 0.3, gifSize * 0.3);\n        this.y = (gridY * gifSize * 1.5) + gifSize + this.p5.random(-gifSize * 0.3, gifSize * 0.3);\n        \n        // Ensure within screen bounds\n        this.x = Math.max(gifSize, Math.min(this.p5.width - gifSize, this.x));\n        this.y = Math.max(gifSize, Math.min(this.p5.height - gifSize * 2, this.y));\n      } else {\n        // Extended positioning for dynamic spawns - heavily favor right edge and beyond\n        const extendedWidth = this.p5.width + (gifSize * 8); // Much larger extension\n        const rightBias = this.p5.random() < 0.7; // 70% chance to spawn on right side/beyond\n        \n        if (rightBias) {\n          // Spawn from right 30% of screen to well beyond right edge\n          this.x = this.p5.random(this.p5.width * 0.7, extendedWidth);\n        } else {\n          // Occasionally spawn elsewhere for variety\n          this.x = this.p5.random(gifSize, this.p5.width - gifSize);\n        }\n        \n        this.y = this.p5.random(gifSize, this.p5.height - gifSize * 2);\n      }\n      \n      // Remove clustering near rabbit areas to prevent overlaps\n      // Instead, prefer areas away from active rabbits\n      let tooCloseToRabbit = false;\n      \n      // Check for overlap with existing gems\n      const gemOverlap = existingGems.some((gem) => {\n        if (!gem.active) return false;\n        \n        const distance = Math.sqrt(\n          Math.pow(gem.x - this.x, 2) + \n          Math.pow(gem.y - this.y, 2)\n        );\n        return distance < minDistance;\n      });\n      \n      // Check for overlap with active rabbits and their speech balloons\n      const rabbitOverlap = rabbits.some((rabbit) => {\n        if (!rabbit.isVisible()) return false;\n        \n        const rabbitPos = rabbit.getPosition();\n        const distanceToRabbit = Math.sqrt(\n          Math.pow(rabbitPos.x - this.x, 2) + \n          Math.pow(rabbitPos.y - this.y, 2)\n        );\n        \n        // Check rabbit body overlap\n        if (distanceToRabbit < rabbitAvoidanceDistance) {\n          return true;\n        }\n        \n        // Check speech balloon area (above rabbit)\n        const speechBalloonArea = {\n          x: rabbitPos.x,\n          y: rabbitPos.y - gifSize * 0.8, // Speech balloons appear above rabbits\n          width: gifSize * 1.8, // Approximate speech balloon width\n          height: gifSize * 0.6  // Approximate speech balloon height\n        };\n        \n        const distanceToSpeechArea = Math.sqrt(\n          Math.pow(speechBalloonArea.x - this.x, 2) + \n          Math.pow(speechBalloonArea.y - this.y, 2)\n        );\n        \n        return distanceToSpeechArea < speechBalloonAvoidanceDistance;\n      });\n      \n      if (!gemOverlap && !rabbitOverlap) break;\n      attempts++;\n    } while (attempts < maxAttempts);\n\n    if (attempts >= maxAttempts) {\n      // If we can't find a non-overlapping spot, place it in a less crowded area\n      this.x = this.p5.random(gifSize, this.p5.width - gifSize);\n      this.y = this.p5.random(gifSize, this.p5.height - gifSize * 2);\n      console.log(\"Gem placed in fallback position to avoid permanent overlap\");\n    }\n\n    this.active = true;\n    this.baseY = this.y; // Store base Y position\n\n    let randImg;\n    let r = this.p5.random();\n    if (r < 0.3) {\n      randImg = \"gem.gif\";\n      // Remove the extra y offset to keep all collectibles aligned\n    } else if (r < 0.6) {\n      randImg = \"magic.gif\";\n    } else {\n      randImg = \"fire.gif\";\n    }\n\n    this.origSrc = randImg;\n\n    // Check for global wave type first, then local override\n    const globalWaveType = this.getWaveType();\n    if (globalWaveType) {\n      randImg = globalWaveType;\n    } else if (this.allSame) {\n      randImg = this.allSame;\n    } else {\n      randImg = this.origSrc;\n    }\n\n    this.gif = this.p5.createImg(randImg, \"gem-or-fire\");\n    const scaleFactor =\n      randImg === \"magic.gif\" || randImg === \"fire.gif\" ? 0.6 : 0.4;\n    this.gif.size(gifSize * scaleFactor, gifSize * scaleFactor);\n    \n    // Dynamic positioning - center the gif on the calculated coordinates\n    const actualSize = gifSize * scaleFactor;\n    this.gif.position(this.x - actualSize / 2, this.y - actualSize / 2);\n    this.gif.style(\"z-index\", \"999\");\n    \n    // Set initial type for wave system\n    this.currentType = randImg;\n  }\n\n  collect() {\n    this.active = false;\n    if (this.gif) {\n      this.gif.remove();\n      this.gif = null; // Clear reference\n    }\n    // Set next appearance with simple random delay\n    this.nextAppearance = this.p5.millis() + this.p5.random(600, 1500);\n    \n    // Reset current type to ensure fresh spawning\n    this.currentType = null;\n  }\n\n  destroy() {\n    // Complete cleanup for gem removal\n    this.active = false;\n    if (this.gif) {\n      this.gif.remove();\n      this.gif = null;\n    }\n    this.currentType = null;\n  }\n\n  isReadyForCulling() {\n    // Gem is ready for culling if it's been inactive for a while\n    return !this.active && (!this.gif || this.gif === null);\n  }\n\n  checkCollision(rabbits) {\n    // Mathematical early exit - no boolean check\n    const activityMultiplier = this.active ? 1 : 0;\n    if (activityMultiplier === 0) return;\n    \n    // Cache gem properties for mathematical collision\n    const gemHalf = gifSize * 0.2; // Simplified constant size\n    const gemLeft = this.x - gemHalf;\n    const gemRight = this.x + gemHalf;\n    const gemTop = this.y - gemHalf;\n    const gemBottom = this.y + gemHalf;\n    \n    for (let rabbit of rabbits) {\n      // Pure mathematical collision check - no object creation\n      const isAlive = rabbit.state === \"alive\" ? 1 : 0;\n      const rabbitHalf = gifSize * 0.5;\n      \n      // Mathematical distance check - faster than bounds\n      const dx = Math.abs(rabbit.x - this.x) - (rabbitHalf + gemHalf);\n      const dy = Math.abs(rabbit.y - this.y) - (rabbitHalf + gemHalf);\n      const hasCollision = (dx <= 0 && dy <= 0) ? 1 : 0;\n      \n      // Mathematical collision trigger - no conditionals\n      const collisionTrigger = activityMultiplier * isAlive * hasCollision;\n      \n      if (collisionTrigger > 0 && this.gif) {\n        // Mathematical type determination using string hash\n        const src = this.gif.elt.src;\n        const srcHash = src.charCodeAt(src.length - 5); // Character before \".gif\"\n        \n        // Mathematical type mapping using character codes\n        // 'f' = 102 (fire), 'g' = 103 (gem), 'c' = 99 (magic)\n        const typeCode = srcHash % 7; // Modulo for type distribution\n        const gemType = typeCode < 2 ? \"fire\" : \n                       typeCode < 4 ? \"gem\" : \"magic\";\n        \n        rabbit.handleCollision(gemType);\n        this.collect();\n        return; // Early exit after collision\n      }\n    }\n  }\n\n  // Pure mathematical visibility calculation - no conditionals\n  calculateVisibility(currentTime) {\n    const t = currentTime * this.timeScale;\n    \n    // Multi-layered noise for organic behavior\n    const primaryNoise = this.p5.noise(\n      this.chaosX * this.spaceScale,\n      this.chaosY * this.spaceScale,\n      t\n    );\n    \n    const secondaryNoise = this.p5.noise(\n      this.chaosX * this.spaceScale * 0.7,\n      this.chaosY * this.spaceScale * 0.7,\n      t * 1.3 + 100\n    );\n    \n    // Mathematical baseline using gem identity\n    const baseWave = Math.sin(t * 0.5 + this.phaseOffset) * 0.5 + 0.5;\n    const identityWave = Math.sin(this.gemIndex * 0.123 + t * 0.2) * 0.3 + 0.7;\n    const baseline = baseWave * identityWave * 0.4;\n    \n    // Extreme mathematical modulation\n    const extremeWave = Math.sin(t * this.extremeFreq + this.extremePhase) * this.extremeAmplitude;\n    const extremeIntensity = Math.max(0, extremeWave * extremeWave); // Square for sharper peaks\n    \n    // Combine all mathematical layers\n    const totalChaos = primaryNoise * 0.6 + secondaryNoise * 0.3;\n    const visibility = totalChaos + baseline + extremeIntensity * 0.3;\n    \n    return Math.max(0, Math.min(1, visibility));\n  }\n\n  // Pure mathematical type calculation - no conditionals\n  calculateType(currentTime) {\n    const t = currentTime * this.timeScale * this.frequencyModulator;\n    \n    // Multi-frequency type waves\n    const typeWave1 = Math.sin(t * 0.3 + this.mathSeed * 6.28) * 0.5 + 0.5;\n    const typeWave2 = Math.sin(t * 0.7 + this.gemIndex * 0.157) * 0.3 + 0.5;\n    const typeWave3 = this.p5.noise(this.chaosX * 0.01, this.chaosY * 0.01, t * 0.1);\n    \n    // Extreme modulation\n    const extremeWave = Math.sin(t * this.extremeFreq * 3 + this.extremePhase);\n    const extremeBoost = Math.max(0, extremeWave) * 0.4; // Only positive peaks\n    \n    // Combined type value\n    const typeValue = (typeWave1 * 0.5 + typeWave2 * 0.3 + typeWave3 * 0.2) + extremeBoost;\n    \n    return Math.max(0, Math.min(1, typeValue));\n  }\n\n  // Pure mathematical flash calculation - no conditionals\n  calculateFlash(currentTime) {\n    const t = currentTime * this.flashFreq;\n    \n    // Multi-layered flash waves\n    const flashWave1 = Math.sin(t + this.flashPhase) * 0.5 + 0.5;\n    const flashWave2 = Math.sin(t * 1.7 + this.flashSeed * 6.28) * 0.3;\n    const flashWave3 = Math.sin(t * 0.3 + this.extremePhase) * 0.2;\n    \n    // Extreme flash calculation\n    const extremeFlash = Math.sin(t * this.extremeFreq * 50 + this.extremePhase);\n    const extremeIntensity = Math.max(0, Math.sin(currentTime * this.extremeFreq + this.extremePhase));\n    const extremeBoost = extremeFlash * extremeIntensity * 0.4;\n    \n    // Combined flash opacity\n    const baseFlash = flashWave1 + flashWave2 + flashWave3;\n    const totalFlash = 0.7 + (baseFlash + extremeBoost) * 0.3;\n    \n    return Math.max(0.3, Math.min(1.0, totalFlash));\n  }\n\n  // Random vs unified type determination\n  getTypeFromValue(typeValue) {\n    // Check for global unification type first - this takes priority during wave events\n    const globalUnifiedType = this.getWaveType();\n    if (globalUnifiedType) {\n      return globalUnifiedType;\n    }\n    \n    // No unification - use individual random type (original behavior)\n    // Use individual mathematical calculation for variety\n    const gem_weight = Math.max(0, Math.cos(typeValue * Math.PI * 1.5));\n    const magic_weight = Math.max(0, Math.sin(typeValue * Math.PI * 2));\n    const fire_weight = Math.max(0, Math.sin(typeValue * Math.PI * 1.5 + Math.PI));\n    \n    // Find maximum weight mathematically\n    const maxWeight = Math.max(gem_weight, magic_weight, fire_weight);\n    \n    // Return type based on which weight is maximum (random distribution)\n    return gem_weight === maxWeight ? \"gem.gif\" :\n           magic_weight === maxWeight ? \"magic.gif\" : \"fire.gif\";\n  }\n\n  // Mathematical floating animation - no state tracking\n  calculateFloatY(currentTime, baseY) {\n    const t = currentTime * 0.001; // Convert to seconds\n    \n    // Multi-frequency floating waves\n    const floatWave1 = Math.sin(t * 2 + this.mathSeed * 6.28) * this.floatOffset * 0.6;\n    const floatWave2 = Math.sin(t * 3.7 + this.flashSeed * 6.28) * this.floatOffset * 0.3;\n    const floatWave3 = Math.sin(t * 1.3 + this.gemIndex * 0.157) * this.floatOffset * 0.1;\n    \n    // Extreme floating modulation\n    const extremeFloat = Math.sin(t * this.extremeFreq * 100 + this.extremePhase) * this.floatOffset * 0.5;\n    const extremeIntensity = Math.max(0, Math.sin(currentTime * this.extremeFreq + this.extremePhase));\n    \n    return baseY + floatWave1 + floatWave2 + floatWave3 + (extremeFloat * extremeIntensity);\n  }\n\n  // Mathematical type switching - no conditionals\n  switchToType(newType) {\n    // Mathematical type switching without conditionals\n    const typeChanged = (this.currentType !== newType) ? 1 : 0;\n    const hasGif = this.gif ? 1 : 0;\n    const shouldSwitch = typeChanged * hasGif;\n    \n    if (shouldSwitch) {\n      // Remove current gif\n      this.gif.remove();\n      \n      // Create new gif with new type\n      this.gif = this.p5.createImg(newType, \"gem-or-fire\");\n      \n      // Mathematical scale factor calculation\n      const isMagicOrFire = (newType === \"magic.gif\" || newType === \"fire.gif\") ? 1 : 0;\n      const scaleFactor = 0.4 + (isMagicOrFire * 0.2); // 0.4 or 0.6\n      this.gif.size(gifSize * scaleFactor, gifSize * scaleFactor);\n      \n      // Dynamic positioning - center the gif on coordinates\n      const actualSize = gifSize * scaleFactor;\n      this.gif.position(this.x - actualSize / 2, this.y - actualSize / 2);\n      this.gif.style(\"z-index\", \"999\");\n      \n      this.currentType = newType;\n    }\n  }\n\n  update(rabbits, existingGems, rabbitRows) {\n    const now = this.p5.millis();\n\n    // Performance optimization: Early exit for inactive gems\n    const shouldBeActive = now > this.nextAppearance;\n    if (!this.active && !shouldBeActive) return;\n\n    // Mathematical activity determination - no conditionals\n    const activityMultiplier = this.active ? 1 : 0;\n    const spawnMultiplier = shouldBeActive && !this.active ? 1 : 0;\n\n    // Performance optimization: Only calculate complex math for active gems\n    if (this.active) {\n      // Cache time calculation for reuse\n      const timeCache = now * 0.001;\n      \n      // Mathematical flash opacity calculation (simplified)\n      const flashOpacity = 0.7 + Math.sin(timeCache * this.flashFreq + this.flashPhase) * 0.3;\n      \n      // Mathematical type calculation (less frequent)\n      const typeValue = this.calculateType(now);\n      const newType = this.allSame || this.getTypeFromValue(typeValue);\n      \n      // Mathematical position updates (optimized)\n      this.x -= this.speed * 0.125; // Simplified division\n      \n      // Optimized wrap-around check\n      if (this.x < -gifSize) {\n        this.x = this.p5.width + gifSize;\n      }\n      \n      // Mathematical floating Y position (simplified)\n      this.y = this.baseY + Math.sin(timeCache * 2 + this.mathSeed * 6.28) * this.floatOffset * 0.6;\n      \n      // Performance optimization: Batch DOM updates\n      if (this.gif) {\n        // Cache DOM style operations\n        const opacityValue = (flashOpacity * activityMultiplier).toFixed(2);\n        this.gif.style(\"opacity\", opacityValue);\n        \n        // Optimized scale factor calculation\n        const scaleFactor = newType.includes(\"magic\") || newType.includes(\"fire\") ? 0.6 : 0.4;\n        const halfSize = (gifSize * scaleFactor) * 0.5;\n        \n        // Batch position update\n        this.gif.position(\n          Math.round(this.x - halfSize), \n          Math.round(this.y - halfSize)\n        );\n        \n        // Performance optimization: Type switching less frequently\n        if ((now % 3000) < 50 && newType !== this.currentType) {\n          this.switchToType(newType);\n        }\n      }\n\n      // Mathematical collision detection (only for active gems)\n      this.checkCollision(rabbits);\n    }\n    \n    // Mathematical spawning - no conditionals  \n    if (spawnMultiplier) {\n      this.spawn(existingGems, rabbitRows, rabbits);\n    }\n  }\n\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/gem.js?");
  
  /***/ }),
  
  /***/ "./src/lib/gifElement.js":
  /*!*******************************!*\
    !*** ./src/lib/gifElement.js ***!
    \*******************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GifElement\": () => (/* binding */ GifElement)\n/* harmony export */ });\nconst { gifSize, speechTexts, chineseSpeechTexts, RABBIT_SPEED } = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\n// Animation duration constant\nconst ANIMATION_DURATION = 800; // 1.5 seconds for fade animations\n\n// Simple elegant parameters for optimal mathematical chaos\nconst CHAOS_PARAMS = {\n  timeScale: 0.0003,         // How fast time flows through the chaos\n  spaceScale: 0.008,         // Spatial noise scale for detailed patterns\n  threshold: 0.7,           // Balanced threshold for good visibility distribution\n  displayBase: 800,         // Base animation timing (visual only)\n  displayChaos: 1000         // Animation variation (visual only)\n};\n\n// Expose for real-time tuning\nwindow.RABBIT_CHAOS_PARAMS = CHAOS_PARAMS;\n\nclass GifElement {\n  constructor(p5, x, y, fonts = {}) {\n    this.p5 = p5;\n    this.originalSrc = p5.random() < 0.5 ? \"rabbit-white.gif\" : \"rabbit-orange.gif\";\n    this.x = x;\n    this.y = y;\n    this.speed = RABBIT_SPEED;\n    \n    this.state = \"hidden\";\n    this.isActive = false;\n    \n    // Pure mathematical identity - each rabbit is a unique point in mathematical space\n    this.chaosX = Math.random() * 1000;\n    this.chaosY = Math.random() * 1000;\n    this.mathSeed = Math.random(); // Individual mathematical seed [0,1]\n    this.rabbitIndex = Math.floor(Math.random() * 1000); // Unique index for spacing\n    \n    // Timing for visual transitions only\n    this.spawnTime = 0;\n    this.fadeInStartTime = 0;\n    this.fadeOutStartTime = 0;\n    this.displayDuration = 0; // No longer used for logic decisions\n    \n    // Only 50% of rabbits get speech balloons\n    this.hasSpeechBalloon = p5.random() < 0.5;\n    this.speechSystem = this.hasSpeechBalloon ? new SpeechBubbleSystem(p5, fonts) : null;\n    this.activeTimeouts = [];\n    this.createGifLayers();\n    \n    console.log(`ðŸŽ² Pure math rabbit: seed=${this.mathSeed.toFixed(3)}, index=${this.rabbitIndex}`);\n  }\n\n  // Pure mathematical existence function - no conditionals or time-based durations\n  shouldExist(currentTime) {\n    const t = currentTime * CHAOS_PARAMS.timeScale;\n    \n    // Multi-layered noise for organic behavior\n    const primaryChaos = this.p5.noise(\n      this.chaosX * CHAOS_PARAMS.spaceScale,\n      this.chaosY * CHAOS_PARAMS.spaceScale,\n      t\n    );\n    \n    // Secondary chaos layer with different frequency for complexity\n    const secondaryChaos = this.p5.noise(\n      this.chaosX * CHAOS_PARAMS.spaceScale * 0.7,\n      this.chaosY * CHAOS_PARAMS.spaceScale * 0.7,\n      t * 1.3 + 100 // Offset to decorrelate from primary\n    );\n    \n    // Mathematical baseline using individual rabbit identity\n    const individualPhase = this.mathSeed * Math.PI * 2;\n    const spatialPhase = this.rabbitIndex * 0.157; // Prime-like number for good distribution\n    \n    // Baseline existence probability based on rabbit's mathematical identity\n    const baselineWave = Math.sin(t * 0.3 + individualPhase) * 0.5 + 0.5; // [0,1]\n    const spatialWave = Math.sin(spatialPhase + t * 0.1) * 0.3 + 0.7; // [0.4,1]\n    const baseline = baselineWave * spatialWave * 0.5; // Up to 0.40 baseline boost for balanced visibility\n    \n    // Individual personality modulation - each rabbit has unique behavior patterns\n    const personalityA = Math.sin(t * 1.7 + this.mathSeed * 7.3) * 0.1; // Â±0.1\n    const personalityB = Math.sin(t * 2.3 + this.mathSeed * 11.7) * 0.05; // Â±0.05\n    \n    // Combine all layers - primary chaos is main driver, others add character\n    const totalChaos = primaryChaos * 0.6 + secondaryChaos * 0.3;\n    const totalPersonality = personalityA + personalityB;\n    const finalExistence = totalChaos + baseline + totalPersonality;\n    \n    return finalExistence > CHAOS_PARAMS.threshold;\n  }\n\n  // Remove the time-based duration calculation - use pure mathematical modulation instead\n  calculateChaosDisplayDuration(currentTime) {\n    // This is no longer used for time-based logic, but kept for visual effects\n    return CHAOS_PARAMS.displayBase + Math.random() * CHAOS_PARAMS.displayChaos;\n  }\n\n  createGifLayers() {\n    try {\n      // Create container div for all GIF layers\n      this.container = this.p5.createDiv('');\n      this.container.position(this.x - gifSize / 2, this.y - gifSize / 2);\n      this.container.size(gifSize, gifSize);\n      this.container.style('position', 'absolute');\n      this.container.style('z-index', '1000'); // Higher than collectibles\n      \n      // Create all GIF layers stacked on top of each other\n      this.gifs = {\n        normal: this.p5.createImg(this.originalSrc, \"rabbit\"),\n        damage: this.p5.createImg(\"rabbit-damage.gif\", \"rabbit-damage\"),\n        glitch: this.p5.createImg(\"rabbit-glitch.gif\", \"rabbit-glitch\"),\n        spell: this.p5.createImg(\"rabbit-spell.gif\", \"rabbit-spell\"),\n        error: this.p5.createImg(\"err.gif\", \"rabbit-error\")\n      };\n      \n      // Style each GIF layer\n      Object.values(this.gifs).forEach(gif => {\n        gif.parent(this.container);\n        gif.size(gifSize, gifSize);\n        gif.style('position', 'absolute');\n        gif.style('top', '0');\n        gif.style('left', '0');\n        gif.style('transition', 'none');\n        gif.style('opacity', '0');\n      });\n      \n      this.gifs.normal.style('opacity', '1');\n      this.currentGif = 'normal';\n      this.container.hide();\n    } catch (error) {\n      console.error('Error creating GIF layers:', error);\n      this.state = \"error\";\n    }\n  }\n\n  // Cleanup method to prevent memory leaks\n  cleanup() {\n    try {\n      // Clear any pending timeouts\n      this.activeTimeouts.forEach(timeout => clearTimeout(timeout));\n      this.activeTimeouts = [];\n      \n      // Remove all GIF elements\n      if (this.gifs) {\n        Object.values(this.gifs).forEach(gif => {\n          if (gif && gif.remove) {\n            gif.remove();\n          }\n        });\n      }\n      \n      // Remove container\n      if (this.container && this.container.remove) {\n        this.container.remove();\n      }\n      \n      // Reset speech system\n      if (this.speechSystem) {\n        this.speechSystem.cleanup();\n      }\n      \n      console.log('ðŸ§¹ Rabbit cleaned up successfully');\n    } catch (error) {\n      console.error('Error during cleanup:', error);\n    }\n  }\n\n  // Public interface for collision detection\n  handleCollision(itemType) {\n    if (this.state !== \"alive\") return;\n\n    try {\n      // Simple effect - just switch GIF briefly\n      const gifMap = {\n        fire: 'damage',\n        gem: 'glitch', \n        magic: 'spell'\n      };\n      \n      const newGif = gifMap[itemType] || 'normal';\n      this.switchToGif(newGif);\n      \n      // Return to normal after brief delay with timeout tracking\n      const timeoutId = setTimeout(() => {\n        if (this.state === \"alive\") {\n          this.switchToGif('normal');\n        }\n        // Remove from active timeouts\n        this.activeTimeouts = this.activeTimeouts.filter(id => id !== timeoutId);\n      }, 800);\n      \n      this.activeTimeouts.push(timeoutId);\n    } catch (error) {\n      console.error('Error handling collision:', error);\n    }\n  }\n\n  update() {\n    try {\n      const now = this.p5.millis();\n      \n      // Core mathematical state decision - no complex conditional logic\n      const shouldBeVisible = this.shouldExist(now);\n      const currentlyVisible = this.state !== \"hidden\";\n      \n      // Simple state machine based on mathematical existence\n      if (shouldBeVisible && !currentlyVisible) {\n        // Math says exist, but we're hidden -> start appearing\n        this.transitionToVisible(now);\n      } else if (!shouldBeVisible && currentlyVisible) {\n        // Math says don't exist, but we're visible -> start disappearing  \n        this.transitionToHidden(now);\n      }\n      \n      // Update visual transitions (fade in/out animations)\n      this.updateVisualTransition(now);\n      \n          // Always update position and speech when not hidden\n    if (this.state !== \"hidden\") {\n      if (this.speechSystem) {\n        this.speechSystem.update(this.x, this.y);\n      }\n      this.updatePosition();\n    }\n    } catch (error) {\n      console.error('Error in rabbit update:', error);\n      this.resetToHidden(now);\n    }\n  }\n\n  setState(newState) {\n    if (this.state !== newState) {\n      this.state = newState;\n    }\n  }\n\n  // Robust transition to visible state\n  transitionToVisible(now) {\n    if (this.state === \"hidden\") {\n      this.setState(\"spawning\");\n      this.spawnTime = now;\n      this.fadeInStartTime = now;\n      this.displayDuration = this.calculateChaosDisplayDuration(now);\n      \n      // Reset position and prepare visual elements\n      this.resetPosition();\n      if (this.speechSystem) {\n        this.speechSystem.reset();\n        this.speechSystem.isActive = true;\n        this.speechSystem.generateNewText();\n        this.speechSystem.opacity = 0;\n      }\n      \n      this.container.show();\n      this.switchToGif('normal');\n      this.container.style(\"opacity\", \"0\");\n    }\n  }\n\n  // Robust transition to hidden state\n  transitionToHidden(now) {\n    if (this.state === \"alive\") {\n      this.setState(\"dying\");\n      this.fadeOutStartTime = now;\n      this.switchToGif('normal');\n    }\n  }\n\n  // Unified visual transition handler - prevents stuck states\n  updateVisualTransition(now) {\n    if (this.state === \"spawning\") {\n      const elapsed = now - this.fadeInStartTime;\n      const progress = Math.min(elapsed / ANIMATION_DURATION, 1.0);\n      \n      if (progress >= 1.0) {\n        // Fade in complete\n        this.setState(\"alive\");\n        this.isActive = true;\n        this.container.style(\"opacity\", \"1\");\n        if (this.speechSystem) {\n          this.speechSystem.opacity = 255;\n        }\n      } else {\n        // Continue fade in\n        const easeProgress = 1 - Math.pow(1 - progress, 1.8);\n        const opacity = Math.max(0, Math.min(1, easeProgress));\n        this.container.style(\"opacity\", opacity.toFixed(3));\n        if (this.speechSystem) {\n          this.speechSystem.opacity = opacity * 255;\n        }\n      }\n    } else if (this.state === \"dying\") {\n      const elapsed = now - this.fadeOutStartTime;\n      const progress = Math.min(elapsed / ANIMATION_DURATION, 1.0);\n      \n      if (progress >= 1.0) {\n        // Fade out complete\n        this.resetToHidden(now);\n      } else {\n        // Continue fade out\n        const easeProgress = 1 - Math.pow(progress, 1.8);\n        const opacity = Math.max(0, Math.min(1, easeProgress));\n        this.container.style(\"opacity\", opacity.toFixed(3));\n        if (this.speechSystem) {\n          this.speechSystem.opacity = opacity * 255;\n        }\n      }\n    }\n  }\n\n  // Optimized reset to hidden state\n  resetToHidden(now) {\n    this.setState(\"hidden\");\n    this.isActive = false;\n    \n    // Clean visual state\n    if (this.container) {\n      this.container.style(\"opacity\", \"0\");\n      this.container.hide();\n    }\n    \n    // Reset speech system\n    if (this.speechSystem) {\n      this.speechSystem.reset();\n    }\n    \n    // Clear any pending timeouts to prevent memory leaks\n    this.activeTimeouts.forEach(timeout => clearTimeout(timeout));\n    this.activeTimeouts = [];\n  }\n\n  resetPosition() {\n    try {\n      // Generate new random position with bounds checking\n      const cols = Math.max(1, Math.floor(this.p5.width / gifSize));\n      const rows = Math.max(1, Math.floor(this.p5.height / gifSize));\n      \n      const col = Math.floor(this.p5.random(cols));\n      const minRow = Math.max(0, Math.floor(rows * 0.05));\n      const maxRow = Math.min(rows - 1, Math.floor(rows * 0.95));\n      const row = Math.floor(this.p5.random(minRow, maxRow + 1));\n      \n      this.x = col * gifSize + gifSize / 2;\n      this.y = row * gifSize + gifSize / 2;\n      \n      // Bounds checking\n      this.x = Math.max(gifSize / 2, Math.min(this.p5.width - gifSize / 2, this.x));\n      this.y = Math.max(gifSize / 2, Math.min(this.p5.height - gifSize / 2, this.y));\n    } catch (error) {\n      console.error('Error in resetPosition:', error);\n      // Fallback to center\n      this.x = this.p5.width / 2;\n      this.y = this.p5.height / 2;\n    }\n  }\n\n  updatePosition() {\n    try {\n      // Simple horizontal movement\n      this.x += this.speed;\n      \n      // Wrap around screen\n      if (this.x > this.p5.width + gifSize / 2) {\n        this.x = -gifSize / 2;\n      }\n      \n      // Update container position with bounds checking\n      const newX = Math.max(-gifSize, Math.min(this.p5.width, this.x - gifSize / 2));\n      const newY = Math.max(-gifSize, Math.min(this.p5.height, this.y - gifSize / 2));\n      \n      this.container.position(newX, newY);\n    } catch (error) {\n      console.error('Error updating position:', error);\n    }\n  }\n\n  switchToGif(gifType) {\n    try {\n      if (this.currentGif !== gifType && this.gifs && this.gifs[gifType]) {\n        Object.keys(this.gifs).forEach(key => {\n          if (this.gifs[key] && this.gifs[key].style) {\n            this.gifs[key].style('opacity', '0');\n          }\n        });\n        this.gifs[gifType].style('opacity', '1');\n        this.currentGif = gifType;\n      }\n    } catch (error) {\n      console.error('Error switching GIF:', error);\n    }\n  }\n\n  // Public getters\n  getState() { return this.state; }\n  isAlive() { return this.state === \"alive\"; }\n  isVisible() { return this.state !== \"hidden\" && this.state !== \"error\"; }\n  getPosition() { return { x: this.x, y: this.y }; }\n  \n  // Public method for speech bubble rendering\n  drawSpeechBubble() {\n    try {\n      if (this.speechSystem && this.speechSystem.opacity > 0) {\n        this.speechSystem.draw(this.x, this.y);\n      }\n    } catch (error) {\n      console.error('Error drawing speech bubble:', error);\n    }\n  }\n}\n\n// Simplified Speech Bubble System\nclass SpeechBubbleSystem {\n  constructor(p5, fonts) {\n    this.p5 = p5;\n    this.fonts = fonts;\n    this.reset();\n  }\n\n  reset() {\n    this.isActive = false;\n    this.opacity = 0;\n    this.speechText = \"\";\n    this.useChineseText = this.p5.random() < 0.3;\n    this.lastTextChange = 0;\n    this.textChangeInterval = this.p5.random(3000, 6000);\n  }\n\n  cleanup() {\n    // Clean up any resources if needed\n    this.reset();\n  }\n\n  generateNewText() {\n    try {\n      this.useChineseText = this.p5.random() < 0.3;\n      this.speechText = this.useChineseText\n        ? chineseSpeechTexts[Math.floor(this.p5.random(chineseSpeechTexts.length))]\n        : speechTexts[Math.floor(this.p5.random(speechTexts.length))];\n    } catch (error) {\n      console.error('Error generating speech text:', error);\n      this.speechText = \"...\";\n      this.useChineseText = false;\n    }\n  }\n\n  update(x, y) {\n    if (!this.isActive) return;\n    \n    try {\n      const now = this.p5.millis();\n      \n      // Occasionally change text\n      if (now - this.lastTextChange > this.textChangeInterval && this.textChangeInterval > 0) {\n        this.generateNewText();\n        this.lastTextChange = now;\n        this.textChangeInterval = this.p5.random(3000, 6000);\n      }\n    } catch (error) {\n      console.error('Error updating speech system:', error);\n    }\n  }\n\n  draw(x, y) {\n    if (this.opacity <= 0) return;\n    \n    try {\n      // P5.js optimization: Cache frequently used values\n      const drawOpacity = Math.max(0, Math.min(255, this.opacity));\n      const textPadding = 10;\n      \n      // P5.js optimization: Minimize font switches and calculations\n      if (this.useChineseText && this.fonts.chinese) {\n        this.p5.textFont(this.fonts.chinese);\n      } else if (this.fonts.arcade) {\n        this.p5.textFont(this.fonts.arcade);\n      }\n      this.p5.textSize(14);\n      \n      // P5.js optimization: Cache expensive textWidth calculation\n      if (!this._cachedTextWidth || this._lastText !== this.speechText) {\n        this._cachedTextWidth = this.p5.textWidth(this.speechText) + textPadding * 2;\n        this._lastText = this.speechText;\n      }\n      const textWidth = this._cachedTextWidth;\n      \n      // P5.js optimization: Use constants for static values\n      const textHeight = 30;\n      const tailSize = 8;\n      const radius = 8;\n      const bubbleX = x + 2;\n      const bubbleY = y - (this.useChineseText ? 10 : 20);\n\n      // P5.js optimization: Cache colors and minimize shadow operations\n      if (!this._cachedColors) {\n        this._cachedColors = {\n          bubble: this.p5.color(255),\n          text: this.p5.color(0)\n        };\n      }\n      \n      // P5.js optimization: Only set shadow if needed, minimize context changes\n      this.p5.drawingContext.shadowBlur = 3;\n      this.p5.drawingContext.shadowColor = 'rgba(0, 0, 0, 0.2)';\n      // P5.js optimization: Use cached colors and minimize fill/stroke calls\n      this.p5.fill(255, 255, 255, drawOpacity);\n      this.p5.stroke(0, drawOpacity);\n      this.p5.strokeWeight(2);\n      this.p5.beginShape();\n      this.p5.vertex(bubbleX + radius, bubbleY - textHeight);\n      this.p5.quadraticVertex(bubbleX, bubbleY - textHeight, bubbleX, bubbleY - textHeight + radius);\n      this.p5.vertex(bubbleX, bubbleY - radius);\n      this.p5.quadraticVertex(bubbleX, bubbleY, bubbleX + radius, bubbleY);\n      this.p5.vertex(bubbleX + 10, bubbleY);\n      this.p5.vertex(bubbleX + 7, bubbleY + tailSize);\n      this.p5.vertex(bubbleX + 20, bubbleY);\n      this.p5.vertex(bubbleX + textWidth - radius, bubbleY);\n      this.p5.quadraticVertex(bubbleX + textWidth, bubbleY, bubbleX + textWidth, bubbleY - radius);\n      this.p5.vertex(bubbleX + textWidth, bubbleY - textHeight + radius);\n      this.p5.quadraticVertex(bubbleX + textWidth, bubbleY - textHeight, bubbleX + textWidth - radius, bubbleY - textHeight);\n      this.p5.endShape(this.p5.CLOSE);\n\n      // P5.js optimization: Clear shadow efficiently and batch text operations\n      this.p5.drawingContext.shadowBlur = 0;\n\n      // P5.js optimization: Batch text drawing state changes\n      this.p5.fill(0, 0, 0, drawOpacity);\n      this.p5.noStroke();\n      this.p5.textAlign(this.p5.CENTER, this.p5.CENTER);\n      \n      // P5.js optimization: Reduce conditional calculations\n      const textY = bubbleY - (textHeight * 0.5) + (this.useChineseText ? -2 : 0);\n      this.p5.text(this.speechText, bubbleX + (textWidth * 0.5), textY);\n    } catch (error) {\n      console.error('Error drawing speech bubble:', error);\n    }\n  }\n} \n\n//# sourceURL=webpack://particles/./src/lib/gifElement.js?");
  
  /***/ }),
  
  /***/ "./src/lib/gifManager.js":
  /*!*******************************!*\
    !*** ./src/lib/gifManager.js ***!
    \*******************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GifManager\": () => (/* binding */ GifManager)\n/* harmony export */ });\nconst {\n  gifSize,\n  speechTexts,\n  chineseSpeechTexts\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\nconst { GifElement } = __webpack_require__(/*! ./gifElement */ \"./src/lib/gifElement.js\");\nconst { Gem } = __webpack_require__(/*! ./gem */ \"./src/lib/gem.js\");\n\nclass GifManager {\n  constructor(p5, numGifs, fonts = { arcade: null, chinese: null }) {\n    this.p5 = p5;\n    this.numGifs = numGifs;\n    this.gifElements = [];\n    this.fonts = fonts;\n    \n    // Create individual autonomous rabbit instances\n    this.createGifs();\n    \n    // Global frequency wave for system-wide effects\n    this.globalWave = new GlobalFrequencyWave(p5);\n    \n    // Initialize gems array with dynamic wave system\n    this.gems = [];\n    this.populationWaveSystem = new DynamicPopulationWave(p5);\n    \n    // Initialize collectible flow system\n    this.collectibleFlowSystem = new CollectibleFlowSystem(p5);\n    \n    // Version check for debugging\n    console.log(\"ðŸ”§ GifManager v2.0 - Unification Wave System loaded\");\n    \n    // Create initial gems with distributed positioning for screen filling\n    this.createInitialGems();\n    \n    this.lastPopulationUpdateTime = p5.millis();\n    this.populationUpdateInterval = 1000;\n    \n    // Performance optimization caches\n    this._cachedVisibleRabbits = null;\n    this._cachedAliveRabbits = null;\n    \n    console.log(`ðŸŒ€ Pure Mathematical GifManager: ${numGifs} autonomous rabbits with optimal chaos algorithms`);\n  }\n\n  createGifs() {\n    const canvasWidth = this.p5.width;\n    const canvasHeight = this.p5.height;\n    \n    // Create autonomous rabbit instances distributed across the screen\n    for (let i = 0; i < this.numGifs; i++) {\n      // Distribute rabbits across the width\n      const x = (i * (canvasWidth / this.numGifs)) + this.p5.random(-10, 10);\n      \n      // Better Y distribution - avoid top and bottom areas (middle 60% of screen)\n      const minY = canvasHeight * 0.05;\n      const maxY = canvasHeight * 0.95;\n      const y = this.p5.random(minY, maxY);\n      \n      const rabbit = new GifElement(this.p5, x, y, this.fonts);\n      this.gifElements.push(rabbit);\n    }\n    \n    console.log(`ðŸŽ¯ Created ${this.numGifs} mathematically-governed autonomous rabbits`);\n  }\n\n  createInitialGems() {\n    const canvasWidth = this.p5.width;\n    const canvasHeight = this.p5.height;\n    \n    // Calculate optimal grid for screen filling with much larger right-edge extension\n    const gemSpacing = gifSize * 1.8; // Spacing between gems\n    const extendedWidth = canvasWidth + (gemSpacing * 10); // Much larger extension beyond right edge\n    const gridCols = Math.floor(extendedWidth / gemSpacing);\n    const gridRows = Math.floor((canvasHeight - gifSize * 2) / gemSpacing); // Account for top/bottom margins\n    \n    // Create gems in a distributed grid pattern extending beyond screen\n    const totalGridSlots = gridCols * gridRows;\n    const initialGemCount = Math.min(Math.floor(this.p5.random(25, 40)), Math.floor(totalGridSlots * 0.7)); // Fill 70% of available slots\n    \n    // Create array of all possible grid positions\n    const gridPositions = [];\n    for (let row = 0; row < gridRows; row++) {\n      for (let col = 0; col < gridCols; col++) {\n        gridPositions.push({ col, row });\n      }\n    }\n    \n    // Shuffle positions for random but distributed placement\n    for (let i = gridPositions.length - 1; i > 0; i--) {\n      const j = Math.floor(this.p5.random() * (i + 1));\n      [gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]];\n    }\n    \n    // Create gems at selected grid positions, favoring right side for natural flow\n    for (let i = 0; i < initialGemCount; i++) {\n      const { col, row } = gridPositions[i];\n      \n      // Calculate position with slight randomization, starting from right edge\n      const baseX = col * gemSpacing + gemSpacing / 2;\n      const baseY = row * gemSpacing + gemSpacing / 2 + gifSize; // Add top margin\n      \n      const x = baseX + this.p5.random(-gemSpacing * 0.2, gemSpacing * 0.2);\n      const y = baseY + this.p5.random(-gemSpacing * 0.2, gemSpacing * 0.2);\n      \n      // Allow gems to spawn well beyond right edge of screen for natural flow\n      const clampedX = Math.max(-gifSize * 2, Math.min(extendedWidth, x)); // Allow more off-screen spawning on both sides\n      const clampedY = Math.max(gifSize, Math.min(canvasHeight - gifSize * 2, y));\n      \n      this.gems.push(new Gem(this.p5, clampedX, clampedY));\n    }\n    \n    console.log(`ðŸ’Ž Created ${initialGemCount} gems distributed across ${gridCols}x${gridRows} extended grid with right-edge flow`);\n  }\n\n  update() {\n    const now = this.p5.millis();\n    \n    // Update global frequency wave\n    this.globalWave.update();\n    \n    // Update collectible flow system\n    this.collectibleFlowSystem.update();\n    \n    // Pure mathematical chaos - each rabbit decides independently\n    this.gifElements.forEach(rabbit => {\n      rabbit.update();\n    });\n    \n    // Update gems with rabbit collision detection\n    this.updateGems();\n    \n    // Log status periodically for monitoring\n    if (now % 30000 < 100) {\n      this.logSystemStatus();\n    }\n  }\n\n  updateGems() {\n    // Cache expensive calculations to avoid repeated work\n    const activeRabbits = this.gifElements.filter(rabbit => rabbit.isVisible());\n    const rabbitRows = this.getActiveRabbitRows();\n    \n    // Update gem population based on wave (less frequently for performance)\n    if (this.p5.frameCount % 2 === 0) { // Every other frame\n      this.updateGemPopulation();\n    }\n    \n    // Update individual gems with cached rabbit data\n    this.gems.forEach(gem => {\n      gem.update(activeRabbits, this.gems, rabbitRows);\n    });\n    \n    // Periodic cleanup to prevent leftovers\n    this.performMaintenanceCleanup();\n  }\n\n  performMaintenanceCleanup() {\n    const now = this.p5.millis();\n    \n    // Mathematical cleanup trigger - no modulo, use sine wave\n    const cleanupCycle = Math.sin(now * 0.0012566) > 0.98; // ~5 second intervals mathematically\n    \n    if (cleanupCycle) {\n      const beforeCount = this.gems.length;\n      let activeCount = 0, cleanedCount = 0;\n      \n      // Mathematical gem filtering - single pass with math instead of multiple filters\n      this.gems = this.gems.filter(gem => {\n        const isActive = gem.active ? 1 : 0;\n        const hasGif = (gem.gif && gem.gif !== null) ? 1 : 0;\n        const timeDelta = gem.nextAppearance ? (now - gem.nextAppearance) : 0;\n        const isStale = timeDelta > 60000 ? 1 : 0;\n        \n        // Mathematical cleanup decision - no conditionals\n        const shouldKeep = isActive + (1 - isActive) * hasGif * (1 - isStale);\n        \n        if (shouldKeep < 0.5) {\n          gem.destroy();\n          cleanedCount++;\n          return false;\n        }\n        \n        activeCount += isActive;\n        return true;\n      });\n      \n      const inactiveCount = beforeCount - activeCount;\n      console.log(`ðŸ§¹ Maintenance: ${beforeCount} total (${activeCount} active, ${inactiveCount} inactive) â†’ cleaned ${cleanedCount} â†’ ${this.gems.length} remaining`);\n    }\n  }\n\n  updateGemPopulation() {\n    const now = this.p5.millis();\n    \n    // Update wave system every frame for smooth dynamics\n    this.populationWaveSystem.update();\n    \n    // Mathematical update trigger - no threshold comparison\n    const timeDelta = now - this.lastPopulationUpdateTime;\n    const updateTrigger = Math.max(0, Math.sign(timeDelta - this.populationUpdateInterval));\n    \n    if (updateTrigger > 0) {\n      this.lastPopulationUpdateTime = now;\n      \n      const { targetGemCount, spawnBurst, cullRate } = this.populationWaveSystem.getPopulationData();\n      \n      // Apply unification population boost\n      const unificationBoost = window.globalUnificationPopulationBoost || 1.0;\n      const boostedTargetCount = Math.floor(targetGemCount * unificationBoost);\n      \n      const currentGemCount = this.gems.length;\n      const gemDelta = boostedTargetCount - currentGemCount;\n      \n      // Mathematical spawning - no conditionals\n      const deltaSign = Math.sign(gemDelta);\n      const deltaAbs = Math.abs(gemDelta);\n      const baseSpawnAmount = Math.ceil(deltaAbs * spawnBurst);\n      \n      // Mathematical unification boost - no conditional\n      const unificationFactor = Math.max(0, Math.sign(unificationBoost - 1.5));\n      const unificationSpeedBoost = 1.0 + unificationFactor;\n      const spawnAmount = Math.floor(baseSpawnAmount * unificationSpeedBoost);\n      const spawnChunks = Math.min(spawnAmount, Math.max(1, Math.floor(spawnAmount * 0.5)));\n      \n      // Mathematical spawning trigger - multiply by positive delta sign\n      const shouldSpawn = Math.max(0, deltaSign) * spawnChunks;\n      \n      if (shouldSpawn > 0) {\n        const newGems = Array.from({length: shouldSpawn}, () => new Gem(this.p5));\n        this.gems.push(...newGems);\n        console.log(`ðŸŒ± Spawned ${shouldSpawn} new gems (delta: ${gemDelta})`);\n      }\n      \n      // Mathematical culling - no conditionals\n      const cullTrigger = Math.max(0, Math.sign(-gemDelta - 3)); // Only when delta < -3\n      const gemsToRemove = Math.floor(deltaAbs * cullRate) * cullTrigger;\n      \n      if (gemsToRemove > 0) {\n        let removedCount = 0, markedCount = 0;\n        \n        // Single pass removal with mathematical selection\n        this.gems = this.gems.filter(gem => {\n          if (removedCount >= gemsToRemove) return true;\n          \n          const isReadyForCull = gem.isReadyForCulling() ? 1 : 0;\n          const isActive = gem.active ? 1 : 0;\n          \n          // Mathematical removal priority - inactive first, then active\n          const removalWeight = (1 - isActive) + isActive * 0.5;\n          const shouldRemove = removedCount < gemsToRemove && Math.random() < removalWeight * 0.3;\n          \n          if (shouldRemove) {\n            if (isReadyForCull) {\n              gem.destroy();\n              removedCount++;\n            } else if (isActive) {\n              gem.collect();\n              markedCount++;\n            }\n            return false;\n          }\n          return true;\n        });\n        \n        console.log(`ðŸ§¹ Cleaned ${removedCount} inactive gems, marked ${markedCount} for collection`);\n      }\n      \n      console.log(`ðŸ’Ž Population: ${this.gems.length}/${boostedTargetCount} (base: ${targetGemCount}) | Unification boost: ${unificationBoost.toFixed(2)}x`);\n      \n      // Emergency spawning if population gets too low - more aggressive thresholds\n      if (this.gems.length < 15) {\n        const emergencyGems = Array.from({length: 20}, () => new Gem(this.p5));\n        this.gems.push(...emergencyGems);\n        console.log(`ðŸš¨ Emergency spawn: Added 20 gems (total now: ${this.gems.length})`);\n      }\n    }\n  }\n\n  getActiveRabbitRows() {\n    // Mathematical row calculation - no conditionals\n    const rows = new Set();\n    \n    this.gifElements.forEach(rabbit => {\n      // Mathematical visibility check - convert state to number\n      const isVisible = rabbit.isVisible() ? 1 : 0;\n      \n      if (isVisible) {\n        const pos = rabbit.getPosition();\n        const rowIndex = Math.floor(pos.y / gifSize) * gifSize;\n        rows.add(rowIndex);\n      }\n    });\n    \n    return Array.from(rows);\n  }\n\n  logSystemStatus() {\n    // Mathematical counting - no conditionals in loop\n    let visibleRabbits = 0, aliveRabbits = 0, hiddenRabbits = 0;\n    this.gifElements.forEach(r => {\n      // Convert boolean checks to mathematical operations\n      visibleRabbits += r.isVisible() ? 1 : 0;\n      aliveRabbits += r.isAlive() ? 1 : 0;\n      hiddenRabbits += (r.getState() === \"hidden\") ? 1 : 0;\n    });\n    \n    // Safety check for collectible flow system\n    if (!this.collectibleFlowSystem || typeof this.collectibleFlowSystem.getUnificationInfo !== 'function') {\n      console.log(`ðŸŽ² Mathematical Chaos: ${visibleRabbits} visible through pure mathematical algorithms`);\n      console.log(`ðŸ“Š Distribution: ${aliveRabbits} alive | ${hiddenRabbits} hidden | optimal performance`);\n      console.log(`ðŸŒŠ Global wave intensity: ${(this.globalWave.getIntensity() * 100).toFixed(1)}%`);\n      console.log(`ðŸŒŠ Collectible System: ERROR - Flow system not properly initialized`);\n      return;\n    }\n    \n    const unificationInfo = this.collectibleFlowSystem.getUnificationInfo();\n    const currentState = this.collectibleFlowSystem.getCurrentState();\n    \n    console.log(`ðŸŽ² Mathematical Chaos: ${visibleRabbits} visible through pure mathematical algorithms`);\n    console.log(`ðŸ“Š Distribution: ${aliveRabbits} alive | ${hiddenRabbits} hidden | optimal performance`);\n    console.log(`ðŸŒŠ Global wave intensity: ${(this.globalWave.getIntensity() * 100).toFixed(1)}%`);\n    console.log(`ðŸŒŠ Collectible System: ${currentState} | Unification: ${(unificationInfo.unificationStrength * 100).toFixed(0)}% | Wave: ${(unificationInfo.rawWaveIntensity * 100).toFixed(0)}%`);\n  }\n\n  // Public interface for drawing speech bubbles (called from main loop)\n  drawSpeechBubbles() {\n    this.gifElements.forEach(rabbit => {\n      rabbit.drawSpeechBubble();\n    });\n  }\n\n  // Public getters for external systems - mathematical caching\n  getVisibleRabbits() {\n    // Mathematical cache trigger - no modulo operation\n    const cachePhase = Math.sin(this.p5.frameCount * 0.2094) > 0.5 ? 1 : 0; // ~3 frame cycle\n    \n    if (!this._cachedVisibleRabbits || cachePhase) {\n      this._cachedVisibleRabbits = this.gifElements.filter(rabbit => rabbit.isVisible());\n    }\n    return this._cachedVisibleRabbits;\n  }\n\n  getAliveRabbits() {\n    // Mathematical cache trigger - no modulo operation\n    const cachePhase = Math.sin(this.p5.frameCount * 0.2094 + 1) > 0.5 ? 1 : 0;\n    \n    if (!this._cachedAliveRabbits || cachePhase) {\n      this._cachedAliveRabbits = this.gifElements.filter(rabbit => rabbit.isAlive());\n    }\n    return this._cachedAliveRabbits;\n  }\n\n  getAllRabbits() {\n    return this.gifElements;\n  }\n\n  getSystemInfo() {\n    const visible = this.getVisibleRabbits().length;\n    const alive = this.getAliveRabbits().length;\n    \n    return {\n      total: this.numGifs,\n      visible,\n      alive,\n      hidden: this.numGifs - visible,\n      globalWaveIntensity: this.globalWave.getIntensity()\n    };\n  }\n}\n\n// Unified Type Wave System - normally random types, occasional wave unification\nclass CollectibleFlowSystem {\n  constructor(p5) {\n    this.p5 = p5;\n    \n    // Wave system for occasional type unification - faster for shorter events\n    this.unificationWave = {\n      frequency: 0.0004, // Faster wave for shorter, more frequent events\n      amplitude: 1.0,\n      phase: p5.random(0, Math.PI * 2)\n    };\n    \n    this.breathingWave = {\n      frequency: 0.0002,\n      amplitude: 0.3,\n      phase: p5.random(0, Math.PI * 2)\n    };\n    \n    // Wave intensity calculation\n    this.waveIntensity = 0;\n    this.smoothedIntensity = 0;\n    \n    // Unification state\n    this.isUnified = false;\n    this.unificationThreshold = 0.88; // Higher threshold for shorter, punchier events\n    this.unificationStrength = 0; // 0-1, how strongly unified\n    this.currentUnifiedType = null;\n    \n    // Faster smoothing for quicker transitions\n    this.smoothingFactor = 0.985; // Less smoothing for faster response\n    \n    // Type rotation for unification events\n    this.typeRotation = [\"gem.gif\", \"fire.gif\", \"magic.gif\"];\n    this.currentTypeIndex = 0;\n    \n    // Population boost during unification\n    this.unificationPopulationMultiplier = 6.0; // 6x more collectibles during unified events for maximum screen filling\n    \n    // Initialize global state - null means random types\n    window.globalCollectibleType = null;\n    window.globalUnificationStrength = 0;\n    window.globalUnificationPopulationBoost = 1.0;\n    \n    console.log(\"ðŸŒŠ Unified Type Wave System initialized - random types with wave events\");\n  }\n\n  update() {\n    const time = this.p5.millis();\n    \n    // Calculate unification wave intensity\n    this.calculateUnificationWave(time);\n    \n    // Update unification state\n    this.updateUnificationState();\n    \n    // Apply smooth transitions\n    this.applySmoothing();\n  }\n\n  calculateUnificationWave(time) {\n    // Calculate unification wave\n    const unificationRaw = Math.sin(time * this.unificationWave.frequency + this.unificationWave.phase);\n    const breathingRaw = Math.sin(time * this.breathingWave.frequency + this.breathingWave.phase);\n    \n    // Combine waves - breathing adds variation to unification timing\n    const combinedWave = unificationRaw + (breathingRaw * 0.3);\n    \n    // Normalize to 0-1 range\n    const normalizedWave = (combinedWave + 1.3) / 2.6; // Account for breathing wave addition\n    this.waveIntensity = Math.max(0, Math.min(1, normalizedWave));\n  }\n\n  updateUnificationState() {\n    // Check if wave crosses unification threshold\n    if (this.waveIntensity > this.unificationThreshold && !this.isUnified) {\n      // Start unification event\n      this.isUnified = true;\n      this.currentTypeIndex = (this.currentTypeIndex + 1) % this.typeRotation.length;\n      this.currentUnifiedType = this.typeRotation[this.currentTypeIndex];\n      \n      const typeName = this.currentUnifiedType.replace('.gif', '').toUpperCase();\n      console.log(`ðŸŒŠ Unification wave started: ${typeName} surge (intensity: ${(this.waveIntensity*100).toFixed(1)}%)`);\n      \n    } else if (this.waveIntensity < this.unificationThreshold && this.isUnified) {\n      // End unification event\n      this.isUnified = false;\n      this.currentUnifiedType = null;\n      console.log(`ðŸŒŠ Unification wave ended - returning to random types`);\n    }\n    \n    // Calculate unification strength for smooth transitions\n    if (this.isUnified) {\n      // When unified, strength ramps up based on how far above threshold we are\n      const overThreshold = this.waveIntensity - this.unificationThreshold;\n      const strengthRange = 1.0 - this.unificationThreshold;\n      this.unificationStrength = Math.min(1.0, overThreshold / strengthRange);\n    } else {\n      // When not unified, strength ramps down\n      this.unificationStrength = 0;\n    }\n  }\n\n  applySmoothing() {\n    // Apply faster transitions to unification strength\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.unificationStrength * (1 - this.smoothingFactor);\n    \n    // Calculate population boost based on unification strength\n    const populationBoost = 1.0 + (this.smoothedIntensity * (this.unificationPopulationMultiplier - 1.0));\n    \n    // Update global state for gems to use - faster thresholds for quicker response\n    if (this.isUnified && this.smoothedIntensity > 0.05) {\n      // When unified and strength is significant, set global type (lower threshold for faster start)\n      window.globalCollectibleType = this.currentUnifiedType;\n    } else if (!this.isUnified && this.smoothedIntensity < 0.15) {\n      // When not unified and strength is minimal, clear global type (higher threshold for faster end)\n      window.globalCollectibleType = null;\n    }\n    \n    // Update global unification strength and population boost\n    window.globalUnificationStrength = this.smoothedIntensity;\n    window.globalUnificationPopulationBoost = populationBoost;\n  }\n\n  // Public getters for monitoring\n  getUnificationInfo() {\n    return {\n      isUnified: this.isUnified,\n      unificationStrength: this.smoothedIntensity,\n      currentType: this.currentUnifiedType,\n      rawWaveIntensity: this.waveIntensity,\n      phase: this.isUnified ? \"UNIFIED\" : \"RANDOM\"\n    };\n  }\n\n  getIntensity() {\n    return this.smoothedIntensity;\n  }\n\n  getCurrentState() {\n    return this.isUnified ? `UNIFIED_${this.currentUnifiedType?.replace('.gif', '').toUpperCase()}` : \"RANDOM_TYPES\";\n  }\n}\n\n// Smooth Global Wave System with organic flow\nclass GlobalFrequencyWave {\n  constructor(p5) {\n    this.p5 = p5;\n    this.phase = p5.random(0, Math.PI * 2);\n    this.frequency = 0.000015; // Ultra slow frequency for very gradual changes\n    this.amplitude = 1.0;\n    this.intensity = 0.5;\n    this.smoothedIntensity = 0.5;\n    this.targetIntensity = 0.5;\n    \n    // Smoothing system for ultra-smooth transitions\n    this.smoothingFactor = 0.98; // High smoothing for gentle changes\n    this.lastUpdateTime = 0;\n    this.deltaAccumulator = 0;\n    \n    // Organic wave components for natural feeling\n    this.baseWave = { frequency: 0.000012, amplitude: 0.7, phase: p5.random(0, Math.PI * 2) };\n    this.breathWave = { frequency: 0.000008, amplitude: 0.3, phase: p5.random(0, Math.PI * 2) };\n    this.driftWave = { frequency: 0.000025, amplitude: 0.2, phase: p5.random(0, Math.PI * 2) };\n    \n    // Expose to global scope for rabbit coordination\n    window.globalRabbitWaveIntensity = 0.5;\n  }\n\n  update() {\n    const time = this.p5.millis();\n    const deltaTime = time - this.lastUpdateTime;\n    this.lastUpdateTime = time;\n    \n    // Calculate multiple organic wave layers\n    const baseValue = Math.sin(time * this.baseWave.frequency + this.baseWave.phase) * this.baseWave.amplitude;\n    const breathValue = Math.sin(time * this.breathWave.frequency + this.breathWave.phase) * this.breathWave.amplitude;\n    const driftValue = Math.sin(time * this.driftWave.frequency + this.driftWave.phase) * this.driftWave.amplitude;\n    \n    // Combine waves with organic weighting\n    const rawWave = baseValue + breathValue * 0.6 + driftValue * 0.4;\n    \n    // Apply smooth easing curve for more natural feeling\n    const normalizedWave = (rawWave + 1) / 2; // 0-1 range\n    const easedWave = this.smoothEasing(normalizedWave);\n    \n    // Ultra-smooth interpolation to target\n    this.targetIntensity = easedWave;\n    const lerpFactor = Math.min(deltaTime * 0.0008, 0.05); // Very slow lerp\n    this.intensity = this.p5.lerp(this.intensity, this.targetIntensity, lerpFactor);\n    \n    // Additional smoothing layer for glass-smooth transitions\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.intensity * (1 - this.smoothingFactor);\n    \n    // Update global intensity with smoothed value\n    window.globalRabbitWaveIntensity = this.smoothedIntensity;\n    \n    // Gentle activity periods with smooth transitions\n    if (this.smoothedIntensity > 0.75) {\n      window.globalSpawnBoost = 1.0 + (this.smoothedIntensity - 0.75) * 2; // Gradual boost\n    } else if (this.smoothedIntensity < 0.25) {\n      window.globalSpawnBoost = 0.3 + this.smoothedIntensity * 2.8; // Gradual reduction\n    } else {\n      window.globalSpawnBoost = 1.0;\n    }\n  }\n\n  // Smooth easing function for natural wave curves\n  smoothEasing(t) {\n    // Combination of ease-in-out curves for organic feeling\n    const easeInOut = t * t * (3 - 2 * t); // Smooth step\n    const gentleCurve = Math.sin(t * Math.PI * 0.5); // Gentle sine curve\n    return easeInOut * 0.7 + gentleCurve * 0.3;\n  }\n\n  getIntensity() {\n    return this.smoothedIntensity;\n  }\n\n  getPeriodInfo() {\n    if (this.smoothedIntensity > 0.8) return \"HIGH ACTIVITY\";\n    if (this.smoothedIntensity < 0.2) return \"LOW ACTIVITY\";\n    return \"NORMAL ACTIVITY\";\n  }\n}\n\n// Ultra-Smooth Population Wave System\nclass DynamicPopulationWave {\n  constructor(p5) {\n    this.p5 = p5;\n    \n    // Multiple organic wave layers with ultra-slow frequencies\n    this.tideWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000012, // Ultra-slow tide-like changes\n      amplitude: 1.2,\n      smoothValue: 0\n    };\n    \n    this.currentWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000035, // Slow flowing current\n      amplitude: 0.8,\n      smoothValue: 0\n    };\n    \n    this.pulseWave = {\n      phase: p5.random(0, Math.PI * 2),\n      frequency: 0.000055, // Gentle pulse\n      amplitude: 0.4,\n      smoothValue: 0\n    };\n    \n    // Smooth interpolation system\n    this.intensity = 0.5;\n    this.smoothedIntensity = 0.5;\n    this.targetIntensity = 0.5;\n    this.smoothingFactor = 0.995; // Ultra-high smoothing\n    this.lastUpdateTime = 0;\n    \n    // Population parameters - increased minimums to prevent empty screens\n    this.minGems = 25; // Increased from 8 to ensure always visible collectibles\n    this.maxGems = 120; // Reduced max for calmer experience\n    this.basePopulation = 45; // Increased base population\n    \n    // Gentle surge system\n    this.lastSurgeTime = 0;\n    this.surgeCooldown = 45000; // Much longer - 45 seconds between surges\n    this.surgeIntensity = 0;\n    this.surgeDecay = 0.99; // Slow surge decay\n  }\n\n  update() {\n    const time = this.p5.millis();\n    const deltaTime = time - this.lastUpdateTime;\n    this.lastUpdateTime = time;\n    \n    // Calculate each wave layer with individual smoothing\n    this.updateWaveLayer(this.tideWave, time);\n    this.updateWaveLayer(this.currentWave, time);\n    this.updateWaveLayer(this.pulseWave, time);\n    \n    // Combine smoothed wave layers with organic weighting\n    const combinedWave = (\n      this.tideWave.smoothValue * this.tideWave.amplitude +\n      this.currentWave.smoothValue * this.currentWave.amplitude * 0.7 +\n      this.pulseWave.smoothValue * this.pulseWave.amplitude * 0.4\n    ) / (this.tideWave.amplitude + this.currentWave.amplitude * 0.7 + this.pulseWave.amplitude * 0.4);\n    \n    // Apply gentle organic curve\n    const normalizedWave = (combinedWave + 1) / 2;\n    const organicCurve = this.organicEasing(normalizedWave);\n    \n    // Ultra-smooth interpolation\n    this.targetIntensity = organicCurve;\n    const lerpFactor = Math.min(deltaTime * 0.0005, 0.02);\n    this.intensity = this.p5.lerp(this.intensity, this.targetIntensity, lerpFactor);\n    \n    // Additional smoothing for glass-smooth transitions\n    this.smoothedIntensity = this.smoothedIntensity * this.smoothingFactor + this.intensity * (1 - this.smoothingFactor);\n    \n    // Gentle surge system - much less aggressive\n    this.updateSurgeSystem(time);\n    \n    // Final intensity with gentle surge influence\n    this.finalIntensity = Math.min(1.0, this.smoothedIntensity + this.surgeIntensity * 0.2);\n  }\n\n  updateWaveLayer(wave, time) {\n    const rawValue = Math.sin(time * wave.frequency + wave.phase);\n    // Individual smoothing for each wave layer\n    wave.smoothValue = wave.smoothValue * 0.98 + rawValue * 0.02;\n  }\n\n  updateSurgeSystem(time) {\n    // Decay existing surge gently\n    this.surgeIntensity *= this.surgeDecay;\n    \n    // Very gentle surge triggers\n    const timeSinceLastSurge = time - this.lastSurgeTime;\n    const surgeReady = timeSinceLastSurge > this.surgeCooldown;\n    const surgeChance = this.p5.random() < 0.008; // Very low chance\n    \n    if (surgeReady && surgeChance && this.smoothedIntensity > 0.6) {\n      this.lastSurgeTime = time;\n      this.surgeIntensity = Math.min(0.3, this.p5.random(0.1, 0.25)); // Gentle surge\n      console.log('ðŸŒŠ Gentle population flow shift');\n    }\n  }\n\n  // Organic easing for natural population curves\n  organicEasing(t) {\n    // Multiple curve layers for organic feeling\n    const smooth1 = t * t * (3 - 2 * t);\n    const smooth2 = Math.sin(t * Math.PI * 0.5);\n    const smooth3 = 1 - Math.pow(1 - t, 1.6);\n    return smooth1 * 0.4 + smooth2 * 0.3 + smooth3 * 0.3;\n  }\n\n  getPopulationData() {\n    // Much gentler population scaling\n    const populationRange = this.maxGems - this.minGems;\n    const gentleIntensity = this.organicEasing(this.finalIntensity);\n    const targetGemCount = Math.floor(this.minGems + (gentleIntensity * populationRange));\n    \n    // Gentle spawn behavior\n    const spawnBurst = 0.15 + (this.finalIntensity * 0.4); // Much gentler burst\n    const cullRate = Math.pow(1 - this.finalIntensity, 1.5) * 0.25; // Gentler culling\n    \n    return {\n      targetGemCount,\n      spawnBurst,\n      cullRate\n    };\n  }\n\n  getIntensity() {\n    return this.finalIntensity;\n  }\n\n  getPopulationInfo() {\n    const { targetGemCount } = this.getPopulationData();\n    return {\n      intensity: this.finalIntensity,\n      targetPopulation: targetGemCount,\n      phase: this.finalIntensity > 0.75 ? 'FLOWING' : \n             this.finalIntensity < 0.25 ? 'CALM' : 'GENTLE'\n    };\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/gifManager.js?");
  
  /***/ }),
  
  /***/ "./src/lib/pixel.js":
  /*!**************************!*\
    !*** ./src/lib/pixel.js ***!
    \**************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pixel\": () => (/* binding */ Pixel)\n/* harmony export */ });\nconst { palettes, pixelSize } = __webpack_require__(/*! ../const */ \"./src/const.js\");\n\nclass Pixel {\n  constructor(p5, x, y, getPaletteIndex, getTransitionProgress) {\n    this.p5 = p5;\n    this.x = x;\n    this.y = y;\n    this.color = p5.color(0, 255, 0);\n    this.opacity = p5.random(50, 255);\n\n    // Functions to retrieve global values dynamically\n    this.getPaletteIndex = getPaletteIndex;\n    this.getTransitionProgress = getTransitionProgress;\n  }\n\n  updateColor() {\n    const { current, next } = this.getPaletteIndex(); // Get dynamic palette index\n    const transitionProgress = this.getTransitionProgress(); // Get dynamic transition progress\n\n    const fromPalette = palettes[current];\n    const toPalette = palettes[next];\n    const fromColor = this.p5.color(\n      ...fromPalette[Math.floor(this.p5.random(fromPalette.length))]\n    );\n    const toColor = this.p5.color(\n      ...toPalette[Math.floor(this.p5.random(toPalette.length))]\n    );\n\n    // Smoothly transition between colors\n    this.color = this.p5.lerpColor(fromColor, toColor, transitionProgress);\n  }\n\n  display() {\n    this.p5.fill(\n      this.color.levels[0],\n      this.color.levels[1],\n      this.color.levels[2],\n      this.opacity\n    );\n    this.p5.noStroke();\n    this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/pixel.js?");
  
  /***/ }),
  
  /***/ "./src/lib/stream.js":
  /*!***************************!*\
    !*** ./src/lib/stream.js ***!
    \***************************/
  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
  
  eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stream\": () => (/* binding */ Stream)\n/* harmony export */ });\nconst {\n  MIN_STREAM_SIZE,\n  MAX_STREAM_SIZE,\n  pixelSize,\n  blinkChance,\n} = __webpack_require__(/*! ../const */ \"./src/const.js\");\nconst { Pixel } = __webpack_require__(/*! ./pixel */ \"./src/lib/pixel.js\");\n\nclass Firework {\n  constructor(p5) {\n    this.p5 = p5;\n    this.reset(); // Initialize firework properties\n  }\n\n  reset() {\n    this.x = this.p5.random(this.p5.width);\n    this.y = this.p5.random(this.p5.height / 2); // Appear randomly in the sky\n    this.stage = 0; // Controls expansion stages\n    this.opacity = 255; // Fully visible at start\n    this.active = true; // If it's currently visible\n    this.pattern = Math.floor(this.p5.random(1, 4)); // Different expansion patterns\n    this.lifetime = this.p5.millis() + this.p5.random(800, 2000); // Short lifespan\n  }\n\n  update() {\n    if (!this.active) return;\n\n    const now = this.p5.millis();\n    if (now > this.lifetime) {\n      this.active = false; // Disappear after time\n      if (this.p5.random() < 0.005) {\n        this.reset(); // Small chance to reappear randomly\n      }\n      return;\n    }\n\n    this.stage += 1; // Expand every update\n    this.opacity -= 10; // Gradually fade out\n  }\n\n  display() {\n    if (!this.active) return;\n\n    this.p5.fill(255, this.opacity);\n    this.p5.noStroke();\n\n    // **Stage 1: Single Pixel (Initial Flash)**\n    if (this.stage < 3) {\n      this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n    }\n\n    // **Stage 2: Small Expansion (4 surrounding pixels)**\n    else if (this.stage < 6) {\n      this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n      this.p5.rect(this.x - pixelSize, this.y, pixelSize, pixelSize);\n      this.p5.rect(this.x + pixelSize, this.y, pixelSize, pixelSize);\n      this.p5.rect(this.x, this.y - pixelSize, pixelSize, pixelSize);\n      this.p5.rect(this.x, this.y + pixelSize, pixelSize, pixelSize);\n    }\n\n    // **Stage 3: Full Expansion Based on Pattern**\n    else if (this.stage < 9) {\n      if (this.pattern === 1) {\n        // **Cross Pattern**\n        this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x, this.y - pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x, this.y + pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize * 2, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize * 2, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x, this.y - pixelSize * 2, pixelSize, pixelSize);\n        this.p5.rect(this.x, this.y + pixelSize * 2, pixelSize, pixelSize);\n      } else if (this.pattern === 2) {\n        // **Square Expansion**\n        for (let dx = -pixelSize; dx <= pixelSize; dx += pixelSize) {\n          for (let dy = -pixelSize; dy <= pixelSize; dy += pixelSize) {\n            this.p5.rect(this.x + dx, this.y + dy, pixelSize, pixelSize);\n          }\n        }\n      } else {\n        // **Diagonal Burst**\n        this.p5.rect(this.x, this.y, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize, this.y - pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize, this.y + pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize, this.y + pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize, this.y - pixelSize, pixelSize, pixelSize);\n        this.p5.rect(this.x - pixelSize * 2, this.y - pixelSize * 2, pixelSize, pixelSize);\n        this.p5.rect(this.x + pixelSize * 2, this.y + pixelSize * 2, pixelSize, pixelSize);\n      }\n    }\n  }\n}\n\nclass Stream {\n  constructor(p5, x, speed, getPaletteIndex, getTransitionProgress) {\n    this.p5 = p5;\n    this.pixels = [];\n    this.fireworks = []; // Array for occasional pixel fireworks\n    this.totalPixels = Math.floor(p5.random(MIN_STREAM_SIZE, MAX_STREAM_SIZE));\n    this.speed = speed;\n    this.headIndex = Math.floor(p5.random(this.totalPixels));\n    this.lastUpdate = p5.millis();\n    this.getPaletteIndex = getPaletteIndex;\n    this.getTransitionProgress = getTransitionProgress;\n    \n    // Horizontal movement for parallax effect\n    this.x = x;\n    this.horizontalSpeed = -0.5; // Slow leftward drift for background parallax\n\n    this.generatePixels(x);\n    //this.generateFireworks(); // Create firework effects\n  }\n\n  generatePixels(x) {\n    for (let i = 0; i < this.totalPixels; i++) {\n      this.pixels.push(\n        new Pixel(\n          this.p5,\n          x,\n          i * pixelSize,\n          this.getPaletteIndex,\n          this.getTransitionProgress,\n        ),\n      );\n    }\n  }\n\n  updateHorizontalPosition() {\n    // Move the entire stream horizontally for parallax effect\n    this.x += this.horizontalSpeed;\n    \n    // Wrap around screen when stream moves off the left edge\n    if (this.x < -pixelSize) {\n      this.x = this.p5.width + pixelSize;\n    }\n    \n    // Update all pixel positions in this stream\n    this.pixels.forEach(pixel => {\n      pixel.x = this.x;\n    });\n    \n    // Update firework positions too\n    this.fireworks.forEach(firework => {\n      if (firework.active) {\n        firework.x += this.horizontalSpeed;\n        // Wrap fireworks too\n        if (firework.x < -pixelSize) {\n          firework.x = this.p5.width + pixelSize;\n        }\n      }\n    });\n  }\n\n  generateFireworks() {\n    const fireworkCount = 50; // Very rare appearance\n    for (let i = 0; i < fireworkCount; i++) {\n      this.fireworks.push(new Firework(this.p5));\n    }\n  }\n\n  update() {\n    const now = this.p5.millis();\n    if (now - this.lastUpdate >= this.speed) {\n      this.headIndex = (this.headIndex + 1) % this.totalPixels;\n      this.lastUpdate = now;\n\n      for (let i = 0; i < this.pixels.length; i++) {\n        const distance =\n          (this.headIndex - i + this.totalPixels) % this.totalPixels;\n\n        this.pixels[i].opacity =\n          distance === 0\n            ? 255\n            : this.p5.map(distance, 1, this.totalPixels / 2, 255, 0);\n\n        if (this.p5.random() < blinkChance) {\n          this.pixels[i].opacity = this.p5.random(50, 255);\n        }\n\n        this.pixels[i].updateColor();\n      }\n    }\n\n    // Update fireworks\n    this.fireworks.forEach((firework) => firework.update());\n  }\n\n  render() {\n    // **ðŸŒŠ Step 0: Update horizontal position for parallax effect**\n    this.updateHorizontalPosition();\n    \n    // **ðŸŸ¡ Step 1: Draw Fireworks Behind Stream**\n    this.fireworks.forEach((firework) => firework.display());\n\n    // **ðŸŸ¢ Step 2: Draw Stream Pixels on Top**\n    this.update();\n    this.pixels.forEach((pixel) => pixel.display());\n  }\n}\n\n\n//# sourceURL=webpack://particles/./src/lib/stream.js?");
  
  /***/ })
  
  /******/ 	});
  /************************************************************************/
  /******/ 	// The module cache
  /******/ 	var __webpack_module_cache__ = {};
  /******/ 	
  /******/ 	// The require function
  /******/ 	function __webpack_require__(moduleId) {
  /******/ 		// Check if module is in cache
  /******/ 		var cachedModule = __webpack_module_cache__[moduleId];
  /******/ 		if (cachedModule !== undefined) {
  /******/ 			return cachedModule.exports;
  /******/ 		}
  /******/ 		// Create a new module (and put it into the cache)
  /******/ 		var module = __webpack_module_cache__[moduleId] = {
  /******/ 			// no module.id needed
  /******/ 			// no module.loaded needed
  /******/ 			exports: {}
  /******/ 		};
  /******/ 	
  /******/ 		// Execute the module function
  /******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
  /******/ 	
  /******/ 		// Return the exports of the module
  /******/ 		return module.exports;
  /******/ 	}
  /******/ 	
  /************************************************************************/
  /******/ 	/* webpack/runtime/define property getters */
  /******/ 	(() => {
  /******/ 		// define getter functions for harmony exports
  /******/ 		__webpack_require__.d = (exports, definition) => {
  /******/ 			for(var key in definition) {
  /******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
  /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
  /******/ 				}
  /******/ 			}
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/hasOwnProperty shorthand */
  /******/ 	(() => {
  /******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
  /******/ 	})();
  /******/ 	
  /******/ 	/* webpack/runtime/make namespace object */
  /******/ 	(() => {
  /******/ 		// define __esModule on exports
  /******/ 		__webpack_require__.r = (exports) => {
  /******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
  /******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
  /******/ 			}
  /******/ 			Object.defineProperty(exports, '__esModule', { value: true });
  /******/ 		};
  /******/ 	})();
  /******/ 	
  /************************************************************************/
  /******/ 	
  /******/ 	// startup
  /******/ 	// Load entry module and return exports
  /******/ 	// This entry module can't be inlined because the eval devtool is used.
  /******/ 	var __webpack_exports__ = __webpack_require__("./src/karma.js");
  /******/ 	
  /******/ })()
  ;